<!DOCTYPE html>
<html lang="ko-KR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>🩶</title>
    <meta name="mobile-web-app-capable" content="yes">
    <link rel="apple-touch-icon" href="https://i.postimg.cc/nzP9sgxr/chan-125.png">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <style>

        :root {
            --bg-color: #fce4ec;
            --primary-color: #ff80ab;
            --secondary-color: #f48fb1;
            --accent-color: #90caf9;
            --text-color: #444;
            --white-color: #fff;
            --border-radius: 18px;
            --phone-corner-radius: 0px;
            --font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            --font-family-monospace: 'Courier New', 'Monaco', 'Menlo', 'Consolas', monospace;
            --top-pinned-bg: #fff0f5;
            --online-status-color: #4CAF50;
        }

        *,
        *::before,
        *::after {
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-family);
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #fce4ec, #f8bbd0);
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
        }

        .phone-screen {
            width: 100%;
            height: 100vh;
            /* max-height: 850px; */
            background-color: var(--white-color);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            border-radius: var(--phone-corner-radius);
            overflow: hidden;
            position: relative;
            display: flex;
            flex-direction: column;
        }

        .screen {
            display: none;
            flex-direction: column;
            width: 100%;
            height: 100%;
            animation: fadeIn 0.3s ease;
        }

        .screen.active {
            display: flex;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: scale(0.95);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        /* --- START: .app-header로 시작하는 모든 CSS를 이 블록으로 교체하세요 --- */

/* 헤더 기본 컨테이너 */
.app-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 20px;
    background-color: rgba(255, 255, 255, 0.8);
    backdrop-filter: blur(10px);
    border-bottom: 1px solid #eee;
    flex-shrink: 0;
    position: relative;
    z-index: 10;
}

/* 헤더 내 모든 버튼의 기본 스타일 (뒤로가기, 액션 버튼 공통) */
.app-header .back-btn,
.app-header .action-btn {
    background: none;
    border: none;
    color: var(--primary-color);
    cursor: pointer;
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0;
    border-radius: 50%;
}

/* 뒤로가기 버튼 안의 SVG 아이콘 크기 */
.app-header .back-btn svg {
    width: 32px;
    height: 32px;
}

/* 멀티선택 취소 버튼 특별 스타일 */
#cancel-multi-select-btn {
    font-size: 14px !important;
    font-weight: 500 !important;
    color: var(--white-color) !important;
    background-color: var(--primary-color) !important;
    border-radius: 10px !important;
    padding: 5px 10px !important;
    width: auto !important;
    height: auto !important;
}

/* 오른쪽 액션 버튼 그룹 */
.app-header .action-btn-group {
    display: flex;
    align-items: center;
    gap: 5px;
}

/* (사용자가 질문한 부분) 액션 버튼 그룹 안의 개별 버튼 스타일 */
.app-header .action-btn-group .action-btn {
    font-size: 14px;
    font-weight: 400;
    width: 40px; /* 크기 통일 */
    height: 40px; /* 크기 통일 */
    border-radius: 50%;
    padding: 0; /* 패딩 제거 */
}

/* SVG 아이콘 크기 (그룹채팅, 새 채팅, 세계관 추가) */
.app-header .action-btn-group #create-group-btn svg,
.app-header .action-btn-group #add-chat-btn svg,
.app-header #add-world-book-btn svg {
    width: 28px;
    height: 28px;
}

/* 설정(톱니바퀴) 버튼 안의 이미지 아이콘 크기 */
.app-header .action-btn img {
    width: 28px;
    height: 28px;
}

/* 헤더 중앙 제목 컨테이너 */
.app-header .title-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    text-align: center;
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
}

/* (사용자가 질문한 부분) 헤더 제목 */
.app-header .title {
    font-size: 16px;
    font-weight: 500;
    color: var(--text-color);
    margin: 0;
}

/* (사용자가 질문한 부분) 헤더 부제목 (온라인 상태 등) */
.app-header .subtitle {
    font-size: 11px;
    color: #888;
    display: flex;
    align-items: center;
    margin-top: 2px;
}

/* 온라인 상태 표시 점 */
.online-indicator {
    width: 6px;
    height: 6px;
    border-radius: 50%;
    background-color: var(--online-status-color);
    margin-right: 5px;
}

/* 헤더 좌우 균형을 위한 빈 공간 */
.app-header .placeholder {
    width: 40px;
}

/* --- END: 교체할 CSS 블록 --- */

        #cancel-multi-select-btn {
            font-size: 14px !important;
            font-weight: 500 !important;
            color: var(--white-color) !important;
            background-color: var(--primary-color) !important;
            border-radius: 10px !important;
            padding: 5px 10px !important;
            width: auto !important;
            height: auto !important;
        }

        .online-indicator {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background-color: var(--online-status-color);
            margin-right: 5px;
        }

        #home-screen {
            justify-content: space-between;
            background-size: cover;
            background-position: center;
            transition: background-image 0.5s ease-in-out;
            padding: 50px 0;
        }

        .time-widget {
            text-align: center;
            padding: 0 20px;
            color: var(--text-color);
        }

        .time-widget .time {
            font-size: 72px;
            font-weight: 600;
        }

        .time-widget .date {
            font-size: 18px;
            color: #666;
        }

        #home-screen.day-mode .time-widget,
        #home-screen.day-mode .time-widget .date,
        #home-screen.day-mode .app-icon .app-name {
            color: var(--white-color);
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.4);
        }

        .app-grid {
            width: 100%;
            padding: 20px 40px;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            justify-content: center;
            align-content: center;
            margin-top: 40px;
        }

        #home-screen.day-mode .time-widget,
        #home-screen.day-mode .time-widget .date,
        #home-screen.day-mode .app-icon .app-name {
            color: var(--white-color);
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.4);
        }

        .dock {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 10px;
            background-color: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(10px);
            border-radius: var(--border-radius);
            margin: 0 20px;
            min-height: 80px;
            gap: 15px;
        }

        .app-icon {
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
            text-decoration: none;
        }

        .icon-img {
            width: 60px;
            height: 60px;
            border-radius: 15px;
            margin-bottom: 8px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s ease;
            object-fit: cover;
        }

        .app-icon:hover .icon-img {
            transform: translateY(-5px);
        }

        .app-icon .app-name {
            font-size: 12px;
            color: var(--text-color);
            font-weight: 500;
        }

        .content {
            flex-grow: 1;
            overflow-y: auto;
            padding: 20px;
            position: relative;
        }

        .placeholder-text {
            text-align: center;
            color: #aaa;
            margin-top: 50px;
        }

        .modal-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.4);
            z-index: 100;
            display: none;
            align-items: center;
            justify-content: center;
            animation: fadeIn 0.3s ease;
        }

        .modal-overlay.visible {
            display: flex;
        }

        .modal-window {
            background: var(--white-color);
            padding: 20px;
            border-radius: var(--border-radius);
            box-shadow: 0 5px 25px rgba(0, 0, 0, 0.15);
            width: 85%;
            max-width: 340px;
            animation: slideUp 0.2s ease-out;
        }

        .modal-window h3 {
            margin-top: 0;
            text-align: center;
            color: var(--primary-color);
            font-size: 15px;
            font-weight: 500;
        }

        @keyframes slideUp {
            from {
                transform: translateY(20px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        #edit-group-member-modal,
        #create-member-for-group-modal {
            z-index: 102;
        }

        #edit-group-member-modal .avatar-preview,
        #create-member-for-group-modal .avatar-preview {
            width: 80px;
            height: 80px;
        }

        .context-menu {
            position: fixed;
            z-index: 1000;
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.15);
            overflow: hidden;
            padding: 5px 0;
            animation: fadeIn 0.1s ease;
        }

        .context-menu-item {
            padding: 10px 20px;
            cursor: pointer;
        }

        .context-menu-item:hover {
            background-color: #f5f5f5;
        }

        .context-menu-item.danger {
            color: #e53935;
        }

        .action-sheet-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.4);
            z-index: 200;
            display: none;
            align-items: flex-end;
            animation: fadeIn 0.3s ease;
        }

        .action-sheet-overlay.visible {
            display: flex;
        }

        .action-sheet {
            background: #f7f7f7;
            width: 100%;
            border-top-left-radius: 20px;
            border-top-right-radius: 20px;
            padding: 10px;
            padding-bottom: calc(40px + env(safe-area-inset-bottom));
            animation: slideUp 0.3s ease-out;
        }

        .action-sheet-button {
            width: 100%;
            background: white;
            border: none;
            padding: 15px;
            font-size: 16px;
            color: var(--primary-color);
            font-weight: 500;
            cursor: pointer;
            border-radius: 10px;
            margin-bottom: 8px;
        }

        .action-sheet-button.danger {
            color: #e53935;
        }

        .action-sheet-button:last-child {
            margin-bottom: 0;
        }

        #world-book-screen .content {
            padding: 10px 0 0 0;
        }

        .list-container {
            list-style: none;
            margin: 0;
            padding: 0;
        }

        .list-item {
            display: flex;
            align-items: center;
            padding: 12px 18px;
            cursor: pointer;
            border-bottom: 1px solid #f0f0f0;
            transition: background-color 0.2s ease;
            position: relative;
        }

        .list-item:hover {
            background-color: #fdf6f8;
        }

        .chat-item.pinned {
            background-color: var(--top-pinned-bg);
        }

        .unread-badge { margin-left: auto; background-color: #ff554c; color: white; font-size: 12px; font-weight: bold; padding: 2px 7px; border-radius: 20px; }

        .chat-avatar {
            width: 50px;
            height: 50px;
            border-radius: 40%;
            margin-right: 12px;
            object-fit: cover;
            flex-shrink: 0;
            background-color: #eee;
        }

        .group-avatar {
            border-radius: 10px;
        }

        .item-details {
            flex-grow: 1;
            overflow: hidden;
        }

        .item-details-row {
            display: flex;
            justify-content: space-between;
            align-items: center; 
            gap: 8px; 
        }

        .item-time {
            font-size: 11px;
            color: #aaa;
            white-space: nowrap; 
            flex-shrink: 0; 
        }

        .item-name {
            font-weight: 500;
            color: var(--text-color);
            font-size: 16px;
        }

        .item-preview-wrapper {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 4px;
        }

        .item-preview {
            font-size: 12px;
            color: #888;
            overflow: hidden;
            text-overflow: ellipsis;
            line-height: 1.2;
            padding-right: 40px;
            display: -webkit-box;
            -webkit-line-clamp: 2; 
            -webkit-box-orient: vertical;
        }

        .pin-badge {
            background-color: var(--primary-color);
            color: white;
            font-size: 10px;
            font-weight: bold;
            padding: 2px 6px;
            border-radius: 5px;
            white-space: nowrap;
            flex-shrink: 0;
        }

        #chat-room-screen {
            background-size: cover;
            background-position: center;
        }

        #chat-room-screen .content {
            display: flex;
            flex-direction: column;
            padding: 0 10px;
            padding-bottom: 0px;
            transition: padding-bottom 0.3s ease;
        }

        #chat-room-screen.multi-select-active .content {
            padding-bottom: 70px;
        }

        .message-area {
            flex-grow: 1;
            overflow-y: auto;
            padding: 0 5px;
            scroll-behavior: smooth;
        }

        .message-wrapper {
            display: flex;
            margin-bottom: 8px;
            align-items: flex-start;
            transition: background-color 0.2s;
            flex-direction: column;
        }

        .message-wrapper.group-message {
            margin-bottom: 18px;
        }

        .message-wrapper.sent {
            align-items: flex-end;
        }

        .message-wrapper.received {
            align-items: flex-start;
        }

        .message-wrapper.system-notification {
            align-items: center;
        }

        .message-bubble-row {
            display: flex;
            width: 100%;
        }

        #message-area > .message-wrapper:first-of-type {
            margin-top: 10px;
        }

        .message-wrapper.sent .message-bubble-row {
            flex-direction: row-reverse;
        }

        .message-wrapper.multi-select-selected {
            background-color: rgba(144, 202, 249, 0.2);
            border-radius: var(--border-radius);
        }

        .message-info {
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
        }

        .group-nickname {
            position: absolute;
            top: -15px;
            font-size: 11px;
            color: #888;
            white-space: nowrap;
            width: 70px;
            text-align: center;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .message-avatar {
            width: 36px;
            height: 36px;
            border-radius: 40%;
            object-fit: cover;
        }

        .message-time {
            font-size: 9px;
            color: #aaa;
            margin: 10px 0px;
        }

        .message-bubble {
            max-width: 60%;
            padding: 9px 12px;
            border-radius: var(--border-radius);
            word-wrap: break-word;
            line-height: 1.3;
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            margin: 7px;
            cursor: pointer;
            font-size: var(--bubble-font-size, 14px);
        }

        .message-bubble.sent {
            border-top-right-radius: 5px;
        }

        .message-bubble.received {
            border-top-left-radius: 5px;
        }

        .message-bubble.grouped-bubble.sent,
        .message-bubble.grouped-bubble.received {
            border-radius: var(--border-radius);
         
        }

        .message-bubble.grouped-bubble::first-child {
            margin-bottom: 2px;
        }

        .message-wrapper.grouped .message-info {
            visibility: hidden; 
        }
        
        .message-wrapper.grouped {
            margin-top: -16px; 
            margin-bottom: 12px;
        }
        
        .system-notification-bubble {
            background-color: rgba(200, 200, 200, 0.5);
            color: #666;
            font-size: 12px;
            margin: 6px;
            padding: 4px 10px;
            border-radius: 10px;
            text-align: center;
        }

        .sticker-bubble {
            width: 120px;
            margin: 8px;
            cursor: pointer;
        }

        .sticker-bubble img {
            width: 100%;
            height: auto;
            display: block;
            border-radius: var(--border-radius);
        }

        
        .photo-bubble {
            width: 60%;
            max-width: 400px;
            border-radius: var(--border-radius);
            margin: 8px;
            cursor: pointer;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .photo-bubble img {
            width: 100%;
            height: 100%;
            display: block;
            object-fit: cover; 
        }

        .message-wrapper.sent .photo-bubble {
            border-top-right-radius: 5px;
        }

        .message-wrapper.received .photo-bubble {
            border-top-left-radius: 5px;
        }

        .voice-bubble {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 9px 12px;
            border-radius: var(--border-radius);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            margin: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            min-width: 90px;
            max-width: 200px;
        }

        .message-wrapper.sent .voice-bubble {
            border-top-right-radius: 5px;
            flex-direction: row-reverse;
        }

        .message-wrapper.received .voice-bubble {
            border-top-left-radius: 5px;
        }

        .voice-bubble .play-icon {
            width: 18px;
            height: 18px;
            flex-shrink: 0;
        }

        .voice-bubble .duration {
            font-size: 12px;
            margin: 0 4px;
            white-space: nowrap;
        }

        .message-wrapper.sent .play-icon {
            transform: scaleX(-1);
        }

        .voice-transcript {
            font-size: 14px;
            color: #555;
            background-color: rgba(255, 255, 255, 0.7);
            padding: 8px 12px;
            margin-top: 5px;
            margin-left: 54px;
            margin-right: 54px;
            border-radius: 10px;
            line-height: 1.6;
            max-width: calc(100% - 108px);
            display: none;
            animation: fadeIn 0.3s ease;
        }

        .voice-transcript.active {
            display: block;
        }

        .message-wrapper.sent .voice-transcript {
            align-self: flex-end;
            margin-right: 54px;
            margin-left: auto;
        }

        .message-wrapper.received .voice-transcript {
            align-self: flex-start;
            margin-left: 54px;
            margin-right: auto;
        }


.pv-card {
    width: 60%;
    max-width: 400px; 
    border-radius: var(--border-radius);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    overflow: hidden;
    position: relative; 
    cursor: pointer;
    margin: 8px;
    background-color: #eee; 
}


.pv-card-img {
    display: block; 
    width: 100%;    
    height: auto;   
}

.message-wrapper.sent .pv-card {
    border-top-right-radius: 5px;
}

.message-wrapper.received .pv-card {
    border-top-left-radius: 5px;
}


.pv-card-content {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    padding: 15px;
    overflow-y: auto;
    color: var(--text-color);
    line-height: 1.6;
    font-size: 15px;
    background-color: rgba(255, 255, 255, 0.95); 
    backdrop-filter: blur(4px);
    z-index: 2; 
    opacity: 0; 
    pointer-events: none; 
    transition: opacity 0.3s ease;
}


.pv-card-content.visible {
    opacity: 1;
    pointer-events: auto;
}

.pv-card-footer {
    background: linear-gradient(to top, rgba(0, 0, 0, 0.6), transparent);
    color: white;
    padding: 20px 10px 8px;
    font-size: 12px;
    display: flex;
    align-items: center;
    gap: 5px;
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    z-index: 1; 
    pointer-events: none;
    transition: opacity 0.3s ease-in-out;
}

.pv-card-footer.hidden {
    opacity: 0;
}

.pv-card-footer svg {
    width: 14px;
    height: 14px;
    fill: white;
    flex-shrink: 0;
}

        .transfer-card {
            width: 230px;
            height: auto;
            border-radius: var(--border-radius);
            margin: 8px;
            overflow: hidden;
            position: relative;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            color: white;
        }

        .message-wrapper.sent .transfer-card {
            border-top-right-radius: 5px;
        }

        .message-wrapper.received .transfer-card {
            border-top-left-radius: 5px;
            cursor: pointer;
        }

        .transfer-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-size: cover;
            background-position: center;
            filter: blur(4px);
            transform: scale(1.1);
            z-index: 1;
        }

        .transfer-card.sent-transfer::before {
            background-image: url('https://i.postimg.cc/sxN893WF/IMG-20250712.png');
        }

        .transfer-card.received-transfer::before {
            background-image: url('https://i.postimg.cc/FzR8LY7g/IMG-20250712-170703.png');
        }

        .transfer-card .overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.3);
            z-index: 2;
            transition: background-color 0.5s ease;
        }

        .transfer-card.received .overlay {
            background-color: rgba(255, 182, 193, 0.4);
        }

        .transfer-card.returned .overlay {
            background-color: rgba(100, 100, 100, 0.5);
        }

        .transfer-content {
            position: relative;
            z-index: 3;
            padding: 16px;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
        }

        .transfer-title {
            font-size: 14px;
            margin: 0 0 5px 0;
            opacity: 0.9;
        }

        .transfer-amount {
            font-size: 24px;
            font-weight: bold;
            margin: 0;
        }

        .transfer-remark {
            font-size: 14px;
            margin-top: 10px;
            opacity: 0.9;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .transfer-status {
            font-size: 12px;
            margin-top: 15px;
            margin-block-end: 0px;
            padding-top: 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.3);
            opacity: 0.8;
        }

        .gift-card {
            width: 230px;
            background-color: #fff;
            border: 2px solid #333;
            border-radius: var(--border-radius);
            box-shadow: 4px 4px 0px #ddd;
            padding: 8px;
            display: flex;
            align-items: center;
            cursor: pointer;
            margin: 8px;
            position: relative;
            overflow: hidden;
        }

        .message-wrapper.sent .gift-card {
            border-top-right-radius: 5px;
        }

        .message-wrapper.received .gift-card {
            border-top-left-radius: 5px;
        }

        .gift-card-icon {
            width: 50px;
            height: 50px;
            margin-right: 8%;
            flex-shrink: 0;
        }

        .gift-card-text {
            font-size: 14px;
            font-weight: bold;
            color: #333;
            font-family: var(--font-family);
        }

        .gift-card-description {
            font-size: 12px;
            color: #555;
            background-color: rgba(240, 240, 240, 0.9);
            padding: 9px 12px;
            margin-top: 5px;
            margin-left: 54px;
            margin-right: 54px;
            border-radius: 10px;
            line-height: 1.2;
            max-width: calc(100% - 108px);
            display: none;
            animation: fadeIn 0.3s ease;
        }

        .gift-card-description.active {
            display: block;
        }

        .message-wrapper.sent .gift-card-description {
            align-self: flex-end;
            margin-right: 54px;
            margin-left: auto;
        }

        .message-wrapper.received .gift-card-description {
            align-self: flex-start;
            margin-left: 54px;
            margin-right: auto;
        }

        .gift-card-received-stamp {
            position: absolute;
            top: 5px;
            right: 5px;
            font-size: 14px;
            font-weight: bold;
            color: var(--primary-color);
            border: 2px solid var(--primary-color);
            border-radius: 8px;
            padding: 2px 6px;
            transform: rotate(15deg);
            opacity: 0;
            transition: opacity 0.3s ease;
            font-family: var(--font-family);
        }

        .gift-card.received .gift-card-received-stamp {
            opacity: 1;
        }

        .load-more-btn {
            background-color: #e0e0e0;
            color: #757575;
            border: none;
            padding: 8px 16px;
            margin: 10px auto;
            border-radius: 15px;
            cursor: pointer;
            display: block;
            font-size: 13px;
            font-weight: 500;
        }

        .load-more-btn:hover {
            background-color: #d1d1d1;
        }

        .typing-indicator {
            text-align: center;
            color: #aaa;
            font-style: italic;
            font-size: 14px;
            padding: 10px 0;
            display: none;
        }

        #sticker-bar {
            position: absolute;
            bottom: 100%; 
            left: 0;
            width: 100%;
            padding: 3px 10px;
            display: none; 
            align-items: center;
            justify-content: flex-start; 
            background: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            gap: 5px;
            flex-wrap: wrap; 
            z-index: 5;
        }

        #sticker-bar.visible {
            display: flex;
        }

        .sticker-bar-btn {
            background: none;
            border: none;
            padding: 5px 6px;
            cursor: pointer;
        }

        .sticker-bar-btn svg {
            width: 22px;
            height: 22px;
            fill: #888;
        }

        .message-input-area .sticker-toggle-btn-wrapper {
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            z-index: 2;
        }
        
        .message-input-area #sticker-toggle-btn {
            background: none;
            border: none;
            padding: 5px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transform: translateX(10px);
        }

        .message-input-area #sticker-toggle-btn svg {
            width: 24px;
            height: 24px;
            fill: #888;
        }

        #sticker-modal {
            position: absolute;
            bottom: calc(88px + env(safe-area-inset-bottom)); 
            left: 0;
            right: 0;
            height: 35%;
            max-height: 450px;
            background: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(5px);
            border-top-left-radius: 20px;
            border-top-right-radius: 20px;
            box-shadow: 0 -5px 15px rgba(0, 0, 0, 0.1);
            z-index: 4;
            display: none;
            flex-direction: column;
        }

        #sticker-modal.visible {
            display: flex;
            animation: slideUp 0.15s ease-out;
        }

        #sticker-modal .header {
            padding: 10px 20px 10px 25px;
            font-weight: bold;
            color: var(--text-color);
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .sticker-grid {
            flex-grow: 1;
            overflow-y: auto;
            padding: 15px;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(70px, 1fr));
            gap: 15px;
        }

        .sticker-item {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
        }

        .sticker-item img {
            width: 60px;
            height: 60px;
            object-fit: contain;
        }

        .sticker-item span {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
            text-align: center;
        }

        #add-sticker-modal .modal-window {
            max-width: 360px;
        }

        #sticker-preview {
            width: 100px;
            height: 100px;
            border: 2px dashed #ddd;
            border-radius: 10px;
            margin: 0 auto 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #aaa;
            background-color: #f9f9f9;
        }

        #sticker-preview img {
            max-width: 100%;
            max-height: 100%;
        }

        .chat-input-wrapper {
            flex-shrink: 0;
            position: relative; 
        }

        .message-input-area {
            display: flex;
            align-items: center;
            padding: 10px;
            padding-bottom: calc(40px + env(safe-area-inset-bottom));
            border-top: 1px solid #eee;
            background: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(10px);
            flex-shrink: 0;
            gap: 8px;
            border-bottom-left-radius: var(--phone-corner-radius);
            border-bottom-right-radius: var(--phone-corner-radius);
            overflow: hidden;
        }

        .textarea-container {
            position: relative;
            flex-grow: 1;
            display: flex;
            align-items: center;
        }

        .message-input-area textarea {
            width: 100%; 
            border: none;
            padding: 10px 45px 10px 12px;
            border-radius: 18px;
            background-color: #f0f0f0;
            resize: none; 
            font-family: inherit; 
            line-height: 1.2;
            max-height: 120px;
            box-sizing: border-box; 
            -ms-overflow-style: none;
            scrollbar-width: none;
        }

        .message-input-area textarea::-webkit-scrollbar {
            display: none;
        }

        .message-input-area input:focus {
            outline: none;
        }

        .message-input-area .icon-btn {
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 50%;
            width: 34px;
            height: 34px;
            cursor: pointer;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s;
        }

        .message-input-area .icon-btn:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        .message-input-area .icon-btn svg {
            width: 25px;
            height: 25px;
            fill: currentColor;
        }

        #attachment-toggle-btn {
            background-color: #f0f0f0 !important;
            color: #555 !important;
            font-size: 24px;
            font-weight: bold;
        }
        #attachment-toggle-btn.active {
            transform: rotate(45deg);
            background-color: var(--primary-color) !important;
            color: white !important;
        }

        .message-input-area .icon-btn.send-btn {
            font-size: 17px;
        }

        #multi-select-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            display: none;
            justify-content: space-between;
            align-items: center;
            padding: 10px 20px;
            padding-bottom: calc(40px + env(safe-area-inset-bottom));
            border-top: 1px solid #eee;
            z-index: 20;
            border-bottom-left-radius: var(--phone-corner-radius);
            border-bottom-right-radius: var(--phone-corner-radius);
            animation: slideUp 0.3s ease-out;
        }

        #multi-select-bar.visible {
            display: flex;
        }

        .settings-sidebar {
            position: absolute;
            top: 0;
            right: -100%;
            width: 80%;
            height: 100%;
            background: #fff;
            box-shadow: -5px 0 15px rgba(0, 0, 0, 0.1);
            transition: right 0.4s ease-in-out;
            z-index: 101;
            display: flex;
            flex-direction: column;
        }

        .settings-sidebar.open {
            right: 0;
        }

        .settings-sidebar .header {
            padding: 15px;
            border-bottom: 1px solid #eee;
            font-weight: 500;
            text-align: center;
            color: var(--primary-color);
        }

        .settings-sidebar .content {
            padding: 20px;
            overflow-y: auto;
            flex-grow: 1;
        }

        .settings-sidebar .form-group textarea {
            height: 150px;
            resize: vertical;
        }

        .settings-sidebar .avatar-setting {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
        }

        .settings-sidebar .avatar-preview {
            width: 50px;
            height: 50px;
            border-radius: 40%;
            object-fit: cover;
            border: 2px solid var(--primary-color);
            cursor: pointer;
            aspect-ratio: 1 / 1;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group-checkbox {
            padding: 0px 5px 12px 5px;
            border-radius: 10px;
            transition: border-color 0.3s;
            font-family: var(--font-family);
            font-size: 14px;
        }

        .form-group label {
            font-size: 13px;
            display: block;
            margin-bottom: 6px;
            padding-left: 5px;
            color: var(--secondary-color);
            font-weight: 400;
        }

        .form-group input,
        .form-group select,
        .form-group textarea {
            width: 100%;
            padding: 10px;
            border: 2px solid #fce4ec;
            border-radius: 10px;
            background-color: #fff;
            transition: border-color 0.3s;
            font-family: var(--font-family);
            font-size: 12px;
        }

        .form-group input:focus,
        .form-group select:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: var(--primary-color);
        }

        .form-group.radio-group {
            display: flex;
            align-items: center;
        }

        .form-group.radio-group label {
            display: flex;
            align-items: center;
            gap: 5px;
            margin-bottom: 0;
        }

        .btn {
            width: 100%;
            padding: 15px;
            border-radius: 10px;
            border: none;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            text-align: center;
        }

        .btn-primary {
            background-color: var(--primary-color);
            color: var(--white-color);
        }

        .btn-primary:hover {
            background-color: var(--secondary-color);
            box-shadow: 0 4px 15px rgba(255, 128, 171, 0.5);
        }

        label.btn-primary {
            color: var(--white-color) !important;
        }

        .btn-small {
            padding: 8px 16px;
            font-size: 14px;
            width: auto;
        }

        .btn-secondary {
            background-color: var(--accent-color);
            color: var(--white-color);
            
        }

        .btn-secondary:hover {
            background-color: #64b5f6;
            box-shadow: 0 4px 15px rgba(144, 202, 249, 0.5);
        }

        .btn-neutral {
            background-color: #bdbdbd;
            color: var(--white-color);
        }

        .btn-neutral:hover {
            background-color: #9e9e9e;
        }

        
        .github-sync-section {
            border: 1px solid #eee;
            border-radius: 10px;
            padding: 15px;
            background-color: #fafafa;
            margin-top: 20px;
        }

        .github-sync-section h4 {
            margin: 0 0 15px 0;
            padding: 10px;
            background-color: #f0f0f0;
            border-radius: 8px;
            transition: background-color 0.3s ease;
        }

        .github-sync-section h4:hover {
            background-color: #e0e0e0;
        }

        .github-sync-section h4 span {
            float: right;
            transition: transform 0.3s ease;
        }

        #github-sync-content {
            transition: all 0.3s ease;
            overflow: hidden;
        }

        #github-sync-content .form-group {
            margin-bottom: 15px;
        }

        #github-sync-content .css-actions {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        #github-sync-content .btn {
            margin-bottom: 0;
        }

        .btn-danger {
            background-color: #ef5350;
            color: white;
        }

        .btn .spinner {
            display: none;
            width: 16px;
            height: 16px;
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-top-color: var(--white-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        .btn.loading .spinner {
            display: block;
        }

        .btn.loading .btn-text {
            display: none;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .wallpaper-preview {
            width: 100%;
            aspect-ratio: 9 / 16;
            max-height: 400px;
            border-radius: var(--border-radius);
            margin-bottom: 25px;
            background-size: cover;
            background-position: center;
            border: 3px dashed var(--primary-color);
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--secondary-color);
            font-style: italic;
            background-color: #fff8fa;
        }

        .toast {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 15px;
            font-size: 14px;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s, visibility 0.5s;
            z-index: 1000;
        }

        .toast.show {
            opacity: 1;
            visibility: visible;
        }

        #world-book-selection-modal,
        #invite-member-modal,
        #group-recipient-selection-modal {
            z-index: 102;
        }

        #world-book-selection-modal .modal-window,
        #invite-member-modal .modal-window,
        #group-recipient-selection-modal .modal-window {
            width: 90%;
            max-width: 380px;
        }

        #world-book-selection-list,
        #invite-member-selection-list,
        #group-recipient-selection-list {
            list-style: none;
            padding: 0;
            margin: 0;
            max-height: 40vh;
            overflow-y: auto;
        }

        .world-book-select-item,
        .invite-member-select-item,
        .group-recipient-select-item {
            display: flex;
            align-items: center;
            padding: 12px 5px;
            border-bottom: 1px solid #f0f0f0;
        }

        .world-book-select-item:last-child,
        .invite-member-select-item:last-child,
        .group-recipient-select-item:last-child {
            border-bottom: none;
        }

        .world-book-select-item input[type="checkbox"],
        .invite-member-select-item input[type="checkbox"],
        .group-recipient-select-item input[type="checkbox"] {
            margin-right: 15px;
            width: 20px;
            height: 20px;
        }

        .world-book-select-item label,
        .invite-member-select-item label,
        .group-recipient-select-item label {
            font-weight: 500;
            color: var(--text-color);
            display: flex;
            align-items: center;
            gap: 10px;
            width: 100%;
        }

        .invite-member-select-item img,
        .group-recipient-select-item img {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            object-fit: cover;
        }

        
        .member-selection-list {
            list-style: none;
            padding: 0;
            margin: 15px 0;
            max-height: 40vh;
            overflow-y: auto;
        }

        .member-selection-item {
            display: flex;
            align-items: center;
            padding: 10px 5px;
            border-bottom: 1px solid #f0f0f0;
        }

        .member-selection-item:last-child {
            border-bottom: none;
        }

        .member-selection-item input[type="checkbox"] {
            margin-right: 10px;
            width: 15px;
            height: 15px;
            flex-shrink: 0;
        }

        .member-selection-item img {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            object-fit: cover;
            margin-right: 8px;
        }

        .member-selection-item label {
            font-weight: 500;
            color: var(--text-color);
        }

        #group-settings-sidebar .group-avatar-setting {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
        }

        #group-settings-sidebar .group-avatar-preview {
            width: 60px;
            height: 60px;
            border-radius: 10px;
            object-fit: cover;
            border: 2px solid var(--primary-color);
            cursor: pointer;
        }

        #group-settings-sidebar .group-members-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
            gap: 15px;
            margin-top: 10px;
        }

        #group-settings-sidebar .group-member,
        #group-settings-sidebar .add-member-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
        }

        #group-settings-sidebar .group-member img {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            object-fit: cover;
            margin-bottom: 5px;
            border: 2px solid #eee;
        }

        #group-settings-sidebar .add-member-btn .add-icon {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: 2px dashed #ccc;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: #ccc;
            margin-bottom: 5px;
            transition: all 0.2s ease;
        }

        #group-settings-sidebar .add-member-btn:hover .add-icon {
            color: var(--primary-color);
            border-color: var(--primary-color);
        }

        #group-settings-sidebar .group-member span,
        #group-settings-sidebar .add-member-btn span {
            font-size: 12px;
            text-align: center;
            color: var(--text-color);
        }

        #customize-screen .icon-custom-item {
            display: flex;
            align-items: center;
            gap: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid #f0f0f0;
        }

        #customize-screen .icon-custom-item:last-child {
            border-bottom: none;
        }

        #customize-screen .icon-preview {
            width: 50px;
            height: 50px;
            border-radius: 12px;
            object-fit: cover;
            flex-shrink: 0;
        }

        #customize-screen .icon-details {
            flex-grow: 1;
        }

        #customize-screen .icon-details p {
            margin: 0 0 8px 0;
            font-weight: 500;
        }

        #customize-screen .reset-icon-btn {
            background: #e0e0e0;
            color: #555;
            border: none;
            border-radius: 8px;
            padding: 8px 10px;
            font-size: 12px;
            cursor: pointer;
            margin-left: 10px;
        }

        
        .customize-section {
            margin-bottom: 30px;
            padding: 20px;
            background: #fff;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .section-title {
            margin: 0 0 20px 0;
            font-size: 14px;
            font-weight: 500;
            color: var(--primary-color);
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 8px;
        }

        .section-content {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .css-toggle-section {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .toggle-label {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            font-weight: 500;
        }

        .toggle-label input[type="checkbox"] {
            width: 20px;
            height: 20px;
            accent-color: var(--primary-color);
        }

        .toggle-text {
            font-size: 16px;
            color: var(--text-color);
        }

        .css-preset-section {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .form-label {
            font-weight: 500;
            color: var(--text-color);
            font-size: 14px;
        }

        .form-select {
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 14px;
            background: #fff;
            color: var(--text-color);
        }

        .css-input-section {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .form-textarea {
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 13px;
            font-family: var(--font-family-monospace);
            background: #fff;
            color: var(--text-color);
            resize: vertical;
            min-height: 120px;
        }

        .css-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 10px 16px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .btn-primary {
            background: var(--primary-color);
            color: white;
        }

        .btn-primary:hover {
            background: var(--secondary-color);
        }

        .btn-secondary {
            background: var(--accent-color);
            color: white;
        }

        .btn-secondary:hover {
            background: #64b5f6;
        }

        .btn-danger {
            background: #f44336;
            color: white;
        }

        .btn-danger:hover {
            background: #d32f2f;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .css-info {
            padding: 12px;
            background: #e3f2fd;
            border-radius: 8px;
            border-left: 4px solid var(--accent-color);
        }

        .info-text {
            margin: 0;
            font-size: 13px;
            color: #1976d2;
            line-height: 1.4;
        }

        
        .tutorial-item {
            margin-bottom: 15px;
            border: 1px solid #fce4ec;
            border-radius: 12px;
            overflow: hidden;
            background-color: #fff8fa;
        }

        .tutorial-header {
            padding: 12px 18px;
            font-weight: 500;
            color: var(--secondary-color);
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .tutorial-header::after {
            content: '▼';
            font-size: 12px;
            transition: transform 0.3s ease;
        }

        .tutorial-item.open .tutorial-header::after {
            transform: rotate(180deg);
        }

        .tutorial-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s ease-in-out, padding 0.5s ease;
            padding: 0 10px;
        }

        .tutorial-item.open .tutorial-content {
            padding: 10px 10px;
            
            max-height: 5000px;
        }

        .tutorial-content img {
            width: 100%;
            height: auto;
            border-radius: 8px;
            display: block;
        }

        
        .form-select {
            width: 100%;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 16px;
            background-color: white;
            cursor: pointer;
        }
        .form-select:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25);
        }
        .font-description {
            font-style: italic;
        }

        .message-meta {
            display: flex;
            align-items: flex-end;
            flex-shrink: 0;
        }

        .message-time {
            font-size: 9px;
            color: #aaa;
            white-space: nowrap;
        }

        
button:focus, a:focus, input:focus, textarea:focus, select:focus {
    outline: none;
    -webkit-tap-highlight-color: transparent; 
}


.back-btn:focus, .action-btn:focus, .icon-btn:focus, .sticker-bar-btn:focus, .app-icon:focus {
    outline: none !important;
    box-shadow: none !important; 
    -webkit-tap-highlight-color: transparent;
}

/* --- START: 이 코드로 CSS를 교체 또는 추가하세요 --- */
.phone-screen.has-bottom-nav .content {
    padding: 10px 0px 120px 0px; /* 하단 네비게이션 바 높이만큼 여백 추가 */
}

.bottom-nav {
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    padding-bottom: calc(40px + env(safe-area-inset-bottom));
    background-color: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(10px);
    border-top: 1px solid #dbdbdb;
    display: flex;
    justify-content: space-around;
    align-items: flex-start;
    padding-top: 8px;
    z-index: 50;
}
.nav-btn {
    flex: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    text-decoration: none;
    color: #8e8e8e;
    font-size: 10px;
    gap: 2px;
}
.nav-btn svg {
    width: 26px;
    height: 26px;
    fill: currentColor;
}
.nav-btn.active {
    color: var(--primary-color);
}

/* 채팅 목록 검색창 */
.search-bar-container {
    padding: 10px 15px;
    background-color: #fff;
    border-bottom: 1px solid #f0f0f0;
}
.search-input {
    width: 100%;
    padding: 8px 15px;
    border: none;
    background-color: #f0f2f5;
    border-radius: 10px;
    font-size: 14px;
}
.search-input:focus {
    outline: none;
}

/* 피드 화면 스타일 개선 */
#feed-screen .content {
    padding: 0;
    background-color: #fafafa;
}
.feed-post {
    background: var(--white-color);
    border-bottom: 1px solid #dbdbdb;
    margin-bottom: 10px;
}
.post-header {
    display: flex;
    align-items: center;
    padding: 12px 15px;
    gap: 12px;
    cursor: pointer;
}
.post-avatar {
    width: 38px;
    height: 38px;
    border-radius: 50%;
    object-fit: cover;
}
.post-author {
    font-weight: 500;
    font-size: 14px;
    color: var(--text-color);
}
.post-image img {
    width: 100%;
    height: auto;
    max-height: 70vh;
    object-fit: cover;
    display: block;
}
.post-actions {
    padding: 10px 15px;
    display: flex;
    gap: 18px;
}
.post-actions svg {
    width: 26px;
    height: 26px;
    fill: #262626;
    cursor: pointer;
}
.post-footer {
    padding: 0 15px 15px;
}
.post-likes {
    font-size: 14px;
    font-weight: 500;
    margin-bottom: 8px;
}
.post-content {
    font-size: 14px;
    line-height: 1.5;
    margin-bottom: 8px;
}
.post-content .author {
    font-weight: 500;
    margin-right: 5px;
}
.view-comments {
    font-size: 14px;
    color: #8e8e8e;
    cursor: pointer;
    margin-bottom: 8px;
}
.post-timestamp {
    font-size: 11px;
    color: #c7c7c7;
    text-transform: uppercase;
}
.comment-input-area {
    display: flex;
    align-items: center;
    padding: 8px 15px;
    border-top: 1px solid #efefef;
    gap: 10px;
}
.comment-input-area .my-avatar {
    width: 28px;
    height: 28px;
    border-radius: 50%;
}
.comment-input {
    border: none;
    background: none;
    flex-grow: 1;
    font-size: 14px;
    color: #8e8e8e;
}

/* 프로필 화면 스타일 개선 */
#profile-screen .content {
    background-color: #fafafa;
}
.profile-header {
    background: var(--white-color);
    padding: 20px 15px;
    display: flex;
    align-items: center;
    gap: 25px;
    border-bottom: 1px solid #dbdbdb;
}
.profile-avatar-lg {
    width: 80px;
    height: 80px;
    border-radius: 50%;
    object-fit: cover;
}
.profile-details {
    flex-grow: 1;
}
.profile-details .username {
    font-size: 22px;
    font-weight: 300;
    margin: 0 0 10px;
}
.profile-buttons {
    display: flex;
    gap: 8px;
}
.profile-buttons .btn {
    flex: 1;
    padding: 8px;
    font-size: 14px;
    font-weight: 500;
    border-radius: 8px;
}
.btn-follow { background-color: #0095f6; color: white; }
.btn-message { background-color: #efefef; color: #262626; }

.profile-bio {
    padding: 15px;
    background: var(--white-color);
}
.profile-bio .name { font-weight: 500; }
.profile-bio .bio-text { font-size: 14px; line-height: 1.4; }

.profile-stats {
    display: flex;
    justify-content: space-around;
    padding: 15px 0;
    background: var(--white-color);
    border-top: 1px solid #dbdbdb;
    border-bottom: 1px solid #dbdbdb;
}
.stat-item { text-align: center; }
.stat-item .count { font-weight: 500; font-size: 16px; }
.stat-item .label { font-size: 14px; color: #8e8e8e; }

.story-highlights {
    padding: 15px;
    background: white;
    display: flex;
    gap: 20px;
    overflow-x: auto;
}
.highlight-item { text-align: center; }
.highlight-circle {
    width: 60px;
    height: 60px;
    border-radius: 50%;
    background: #f0f0f0;
    margin-bottom: 5px;
    border: 1px solid #dbdbdb;
}
.highlight-item span { font-size: 12px; }

.profile-tabs {
    display: flex;
    border-top: 1px solid #dbdbdb;
    background: white;
}
.tab-btn {
    flex: 1;
    padding: 15px;
    border: none;
    background: none;
    cursor: pointer;
    border-bottom: 2px solid transparent;
}
.tab-btn.active {
    border-bottom-color: #262626;
}
.tab-btn svg { width: 24px; height: 24px; fill: #8e8e8e; }
.tab-btn.active svg { fill: #262626; }

.profile-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 3px;
    padding-top: 3px;
}
.grid-item img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    aspect-ratio: 1 / 1;
}

.phone-screen.hide-user-icons .message-wrapper.sent .message-info {
    display: none;
}

/* 캐릭터(received) 아이콘 숨기기 */
.phone-screen.hide-character-icons .message-wrapper.received .message-info {
    display: none;
}

/* --- START: 추가할 CSS --- */
/* 채팅방별 메시지 숨기기 */
#chat-room-screen.hide-my-icons .message-wrapper.sent .message-info {
    display: none;
}
#chat-room-screen.hide-char-icons .message-wrapper.received .message-info {
    display: none;
}

    </style>
</head>
<body>
<div class="phone-screen">
    <div id="home-screen" class="screen active"></div>
    <div id="chat-list-screen" class="screen">
        <!-- START: chat-list-screen의 header 태그를 이걸로 교체 -->
        <header class="app-header">
            <button class="back-btn" data-target="home-screen">
                <svg viewBox="0 0 24 24" fill="currentColor"><path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"></path></svg>
            </button>
            <div class="title-container">
                <h1 class="title">채팅</h1>
            </div>
            <div class="action-btn-group">
                <button class="action-btn" id="create-group-btn" title="그룹채팅">
                    <svg viewBox="0 0 24 24" fill="currentColor"><path d="M16 11c1.66 0 2.99-1.34 2.99-3S17.66 5 16 5c-1.66 0-3 1.34-3 3s1.34 3 3 3zm-8 0c1.66 0 2.99-1.34 2.99-3S9.66 5 8 5C6.34 5 5 6.34 5 8s1.34 3 3 3zm0 2c-2.33 0-7 1.17-7 3.5V19h14v-2.5c0-2.33-4.67-3.5-7-3.5zm8 0c-.29 0-.62.02-.97.05 1.16.84 1.97 1.97 1.97 3.45V19h6v-2.5c0-2.33-4.67-3.5-7-3.5z"></path></svg>
                </button>
                <button class="action-btn" id="add-chat-btn" title="새 채팅">
                    <svg viewBox="0 0 24 24" fill="currentColor"><path d="M19 13H13V19H11V13H5V11H11V5H13V11H19V13Z"></path></svg>
                </button>
            </div>
        </header>
<!-- END: header 태그 교체 -->
        <main class="content">
            <ul class="list-container" id="chat-list-container"></ul>
            <div class="placeholder-text" id="no-chats-placeholder" style="display: none;">
                <p>아직 채팅 상대가 없네요~</p>
                <p>오른쪽 상단의 "+"를 클릭하여 만들어보세요!</p>
            </div>
        </main>
    </div>
    <div id="chat-room-screen" class="screen">
        <header class="app-header" id="chat-room-header-default">
            <button class="back-btn" data-target="chat-list-screen">
    <svg viewBox="0 0 24 24" fill="currentColor"><path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"></path></svg>
</button>
            <div class="title-container">
                <h1 class="title" id="chat-room-title">...</h1>
                <div class="subtitle" id="chat-room-subtitle">
                    <div class="online-indicator"></div><span id="chat-room-status-text">온라인</span>
                </div>
            </div>
            <button class="action-btn" id="chat-settings-btn"><img src="https://i.postimg.cc/nhwP4pQy/chan-73.png" alt="설정"></button>
        </header>
        <header class="app-header" id="chat-room-header-select" style="display: none;">
            <button class="action-btn" id="cancel-multi-select-btn">취소</button>
            <div class="title-container">
                <h1 class="title" id="multi-select-title">메시지 선택</h1>
            </div>
            <div class="placeholder"></div>
        </header>
        <main class="content">
            <div class="message-area" id="message-area"></div>
            <div class="typing-indicator" id="typing-indicator"></div>
        </main>
        <div class="chat-input-wrapper">
    <div id="sticker-bar">
        <button class="sticker-bar-btn" id="photo-video-btn" title="사진/영상">
            <svg viewBox="0 0 24 24"><path d="M4,4H7L9,2H15L17,4H20A2,2 0 0,1 22,6V18A2,2 0 0,1 20,20H4A2,2 0 0,1 2,18V6A2,2 0 0,1 4,4M12,7A5,5 0 0,0 7,12A5,5 0 0,0 12,17A5,5 0 0,0 17,12A5,5 0 0,0 12,7M12,9A3,3 0 0,1 15,12A3,3 0 0,1 12,15A3,3 0 0,1 9,12A3,3 0 0,1 12,9Z" /></svg>
        </button>
        <button class="sticker-bar-btn" id="voice-message-btn" title="음성 메시지">
            <svg viewBox="0 0 24 24"><path d="M12 14c1.66 0 2.99-1.34 2.99-3L15 5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm5.3-3c0 3-2.54 5.1-5.3 5.1S6.7 14 6.7 11H5c0 3.41 2.72 6.23 6 6.72V21h2v-3.28c3.28-.48 6-3.3 6-6.72h-1.7z" /></svg>
        </button>
        <button class="sticker-bar-btn" id="wallet-btn" title="송금">
            <svg viewBox="0 0 24 24"><path d="M20 4H4C2.9 4 2 4.9 2 6V18C2 19.1 2.9 20 4 20H20C21.1 20 22 19.1 22 18V6C22 4.9 21.1 4 20 4ZM20 18H4V8H20V18ZM4 6H20V6H4Z" /></svg>
        </button>
        <button class="sticker-bar-btn" id="gift-btn" title="선물">
            <svg viewBox="0 0 24 24"><path d="M20,8L12,13L4,8V6H20M20,4H4A2,2 0 0,0 2,6V18A2,2 0 0,0 4,20H20A2,2 0 0,0 22,18V6A2,2 0 0,0 20,4M12.5,18C12.5,17.29 12.17,16.65 11.64,16.27C12.17,15.89 12.5,15.26 12.5,14.55C12.5,13.6 11.83,12.79 11,12.58V12H13V10H11V8H13V6H11V5C11,4.45 10.55,4 10,4H8C7.45,4 7,4.45 7,5V6H9V8H7V10H9V12H7V12.58C6.17,12.79 5.5,13.6 5.5,14.55C5.5,15.26 5.83,15.89 6.36,16.27C5.83,16.65 5.5,17.29 5.5,18H12.5Z" /></svg>
        </button>
        <button class="sticker-bar-btn" id="time-skip-btn" title="시간 보내기">
            <svg viewBox="0 0 24 24"><path d="M4 5v14l7-7-7-7zm9 0v14l7-7-7-7z"></path></svg>
        </button>
    </div>
    <div class="message-input-area" id="message-input-area-container">
        <button id="attachment-toggle-btn" class="icon-btn">+</button>
        <div class="textarea-container">
            <textarea rows="1" id="message-input" placeholder="메시지 입력..."></textarea>
            <div class="sticker-toggle-btn-wrapper">
                <button class="sticker-bar-btn" id="sticker-toggle-btn" title="이모티콘">
                    <svg viewBox="0 0 24 24"><path d="M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zm3.5-9c.83 0 1.5-.67 1.5-1.5S16.33 8 15.5 8 14 8.67 14 9.5s.67 1.5 1.5 1.5zm-7 0c.83 0 1.5-.67 1.5-1.5S9.33 8 8.5 8 7 8.67 7 9.5 7.67 11 8.5 11zm3.5 6.5c2.33 0 4.31-1.46 5.11-3.5H6.89c.8 2.04 2.78 3.5 5.11 3.5z" /></svg>
                </button>
            </div>
        </div>
        <!-- 일반 모드 버튼 -->
        <button id="send-message-btn" class="icon-btn send-btn">➤</button>
        <button id="get-reply-btn" class="icon-btn">
            <svg viewBox="0 0 24 24"><path d="M12,2A10,10 0 1,0 22,12A10,10 0 0,0 12,2M12,20A8,8 0 1,1 20,12A8,8 0 0,1 12,20M16.24,7.76C15.07,6.58 13.53,6 12,6V12L7.76,16.24C10.1,18.58 13.9,18.58 16.24,16.24C18.58,13.9 18.58,10.1 16.24,7.76Z" /></svg>
        </button>
        <!-- 편집 모드 버튼 (초기 숨김) -->
        <button id="save-edit-btn" class="icon-btn send-btn" style="display: none;">✓</button>
        <button id="cancel-edit-btn" class="icon-btn" style="background-color: #aaa; display: none;">✗</button>
    </div>
</div>
        <div id="multi-select-bar"><span id="select-count">0개 항목 선택됨</span><button class="btn btn-danger" id="delete-selected-btn" style="width: auto; padding: 8px 16px;">선택 항목 삭제</button></div>
        <div id="sticker-modal">
            <div class="header"><span>내 이모티콘</span><button class="btn btn-primary btn-small" id="add-new-sticker-btn" style="font-size: 18px; padding: 6px 10px;">+</button></div>
            <div class="sticker-grid" id="sticker-grid-container"></div>
        </div>
    </div>
    <div id="world-book-screen" class="screen">
        <header class="app-header">
            <button class="back-btn" data-target="home-screen">
                <svg viewBox="0 0 24 24" fill="currentColor"><path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"></path></svg>
            </button>
            <div class="title-container">
                <h1 class="title">세계관</h1>
            </div>
            <button class="action-btn" id="add-world-book-btn" title="새 항목 추가">
                <svg viewBox="0 0 24 24" fill="currentColor"><path d="M19 13H13V19H11V13H5V11H11V5H13V11H19V13Z"></path></svg>
            </button>
        </header>
        <main class="content">
            <ul class="list-container" id="world-book-list-container"></ul>
            <div class="placeholder-text" id="no-world-books-placeholder" style="display: none;">
                <p>당신의 세계는 혼돈에 빠져 있습니다...</p>
                <p>오른쪽 상단의 "+"를 클릭하여 첫 설정을 만들어보세요!</p>
            </div>
        </main>
    </div>
    <div id="edit-world-book-screen" class="screen">
        <header class="app-header">
            <button class="back-btn" data-target="world-book-screen">
                <svg viewBox="0 0 24 24" fill="currentColor"><path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"></path></svg>
            </button>
            <div class="title-container">
                <h1 class="title" id="edit-world-book-title">항목 생성/편집</h1>
            </div>
            <div class="placeholder"></div>
        </header>
        <main class="content">
            <form id="edit-world-book-form">
                <input type="hidden" id="world-book-id">
                <div class="form-group">
                    <label for="world-book-name">항목 이름</label>
                    <input type="text" id="world-book-name" placeholder="예: 세계관 배경, 마법 체계" required>
                </div>
                <div class="form-group">
                    <label for="world-book-content">항목 내용</label>
                    <textarea id="world-book-content" rows="8" placeholder="이 설정을 자세히 설명해주세요..." required></textarea>
                </div>
                <div class="form-group">
                    <label>주입 위치</label>
                    <div class="form-group radio-group">
                        <label><input type="radio" name="world-book-position" value="before" checked> 앞</label>
                        <label><input type="radio" name="world-book-position" value="after"> 뒤</label>
                    </div>
                </div>
                <button type="submit" class="btn btn-primary">항목 저장</button>
            </form>

        </main>
    </div>
    <div id="api-settings-screen" class="screen"></div>
    <div id="wallpaper-screen" class="screen"></div>
    <!-- START: 추가할 HTML -->
<div id="wallpaper-font-screen" class="screen">
    <header class="app-header">
        <button class="back-btn" data-target="home-screen">
                <svg viewBox="0 0 24 24" fill="currentColor"><path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"></path></svg>
            </button>
        <div class="title-container">
            <h1 class="title">배경화면 & 글꼴</h1>
        </div>
        <div class="placeholder"></div>
    </header>
    <main class="content">
        <!-- 배경화면 설정이 여기에 위치합니다 -->
        <div class="customize-section" style="margin-top:0;">
             <h3 class="section-title">배경화면 변경</h3>
             <div class="wallpaper-preview" id="wallpaper-preview"><span>현재 배경화면 미리보기</span></div>
             <input type="file" id="wallpaper-upload" accept="image/*" style="display: none;">
             <label for="wallpaper-upload" class="btn btn-primary">앨범에서 새 배경화면 선택</label>
        </div>
        <!-- 글꼴 설정이 여기에 위치합니다 -->
        <div class="customize-section">
            <h3 class="section-title">글꼴 설정</h3>
            <div class="form-group">
                <label for="font-preset-selector">저장된 폰트 선택</label>
                <select id="font-preset-selector" class="form-select"></select>
                <p class="font-description" id="font-description" style="font-size:12px; color:#666; margin-top:8px; margin-bottom:15px;">프리셋을 선택해주세요</p>
            </div>
            <hr style="margin: 20px 0; border: none; border-top: 1px solid #eee;">
            <form id="font-settings-form">
                <div class="form-group">
                    <label for="font-url">폰트 URL</label>
                    <input type="url" id="font-url" placeholder="여기에 폰트 URL을 입력하세요" style="width: 100%; padding: 12px; border: 1px solid #ddd; border-radius: 6px; margin-bottom: 8px;">
                    <p style="font-size:12px; color:#888;">폰트 파일 URL을 입력하세요</p>
                </div>
                <div class="form-group" style="display: grid; grid-template-columns: 2fr 1fr; gap: 10px; margin-top: 15px;">
                    <input type="text" id="new-preset-name" placeholder="폰트 이름 (예: 나눔고딕)" style="padding: 12px; border: 1px solid #ddd; border-radius: 6px;">
                    <input type="text" id="new-preset-description" placeholder="설명 (선택)" style="padding: 12px; border: 1px solid #ddd; border-radius: 6px;">
                </div>
                <div class="font-actions" style="display: flex; gap: 10px; margin-top: 20px;">
                    <button type="button" class="btn btn-primary" id="apply-font-btn" style="flex: 1;">폰트 적용</button>
                    <button type="button" class="btn btn-neutral" id="restore-default-font-btn" style="flex: 0.7;">기본 폰트</button>
                </div>
            </form>
            <hr style="margin: 30px 0; border: none; border-top: 1px solid #eee;">
            <div style="margin-bottom: 20px;">
                <h3 style="margin: 13px 5px; color: var(--text-color); font-size: 16px; font-weight: 500;">프리셋 관리</h3>
                <button type="button" class="btn btn-secondary" id="save-preset-btn" style="width: 100%; margin-bottom: 10px;">프리셋 등록</button>
                <button type="button" class="btn btn-danger" id="delete-preset-btn" style="width: 100%;" disabled>프리셋 삭제</button>
            </div>
        </div>
    </main>
</div>

<div id="settings-screen" class="screen">
    <header class="app-header">
        <button class="back-btn" data-target="home-screen">
                <svg viewBox="0 0 24 24" fill="currentColor"><path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"></path></svg>
            </button>
        <div class="title-container">
            <h1 class="title">설정</h1>
        </div>
        <div class="placeholder"></div>
    </header>
    <main class="content">
        <div class="customize-section">
            <h3 class="section-title">전역 설정</h3>
            <div class="section-content" id="global-settings-container">
                 <div class="form-group-checkbox" style="display: flex; justify-content: space-between; align-items: center; padding: 15px 5px;">
                    <label for="ai-can-use-system-toggle" style="margin:0; font-weight: 500;">AI 시스템 메시지 사용</label>
                    <input type="checkbox" id="ai-can-use-system-toggle" style="width: 20px; height: 20px; accent-color: var(--primary-color);">
                </div>
                 <div class="form-group-checkbox" style="display: flex; justify-content: space-between; align-items: center; padding: 15px 5px;">
                    <label for="hide-user-icons-toggle" style="margin:0; font-weight: 500;">유저 아이콘 숨기기</label>
                    <input type="checkbox" id="hide-user-icons-toggle" style="width: 20px; height: 20px; accent-color: var(--primary-color);">
                </div>
                 <div class="form-group-checkbox" style="display: flex; justify-content: space-between; align-items: center; padding: 15px 5px;">
                    <label for="hide-character-icons-toggle" style="margin:0; font-weight: 500;">캐릭터 아이콘 숨기기</label>
                    <input type="checkbox" id="hide-character-icons-toggle" style="width: 20px; height: 20px; accent-color: var(--primary-color);">
                </div>
            </div>
        </div>
    </main>
</div>
<!-- END: 추가할 HTML -->
    <div id="customize-screen" class="screen"></div>
    <div id="tutorial-screen" class="screen"></div>
    <div id="toast-notification" class="toast"></div>
    <input type="file" id="image-upload-input" accept="image/*" style="display:none;">
    <div id="add-char-modal" class="modal-overlay">
        <div class="modal-window">
            <h3>새 캐릭터 만들기</h3>
            <form id="add-char-form">
                <div class="form-group">
                    <label for="char-real-name">캐릭터 이름</label><input type="text" id="char-real-name" placeholder="캐릭터의 실제 이름" required>
                </div>
                <div class="form-group">
                    <label for="char-remark-name">캐릭터 메모 (별명)</label><input type="text" id="char-remark-name" placeholder="당신이 부를 호칭" required>
                </div>
                <div class="form-group">
                    <label for="my-name-for-char">내 이름</label><input type="text" id="my-name-for-char" placeholder="상대방이 당신을 부를 호칭" required>
                </div><button type="submit" class="btn btn-primary">만들기</button>
            </form>
        </div>
    </div>
    <div id="add-sticker-modal" class="modal-overlay">
        <div class="modal-window">
            <h3 id="add-sticker-modal-title">새 이모티콘 추가</h3>
            
            
            <div class="sticker-tabs" style="display: flex; margin-bottom: 15px; border-bottom: 1px solid #ddd;">
                <button type="button" id="single-sticker-tab" class="sticker-tab-btn active" style="flex: 1; padding: 10px; border: none; background: none; cursor: pointer; border-bottom: 2px solid #4CAF50;">단일 등록</button>
                <button type="button" id="bulk-sticker-tab" class="sticker-tab-btn" style="flex: 1; padding: 10px; border: none; background: none; cursor: pointer; border-bottom: 2px solid transparent;">일괄 등록</button>
            </div>

            
            <div id="single-sticker-content" class="sticker-tab-content">
                <form id="add-sticker-form"><input type="hidden" id="sticker-edit-id">
                    <div id="sticker-preview"><span>미리보기</span></div>
                    <div class="form-group"><label for="sticker-name">이모티콘 이름</label><input type="text" id="sticker-name" placeholder="예: 기쁨" required></div>
                    <div class="form-group"><label for="sticker-url-input">이모티콘 URL</label><input type="url" id="sticker-url-input" placeholder="이미지 URL 붙여넣기"></div>
                    <p style="text-align:center; color:#888; margin: -10px 0 15px; font-size: 14px;">또는</p><input type="file" id="sticker-file-upload" accept="image/*" style="display:none;"><label for="sticker-file-upload" class="btn btn-secondary" style="width:100%; margin-bottom: 10px;">로컬에서 업로드</label><button type="submit" class="btn btn-primary">저장</button>
                </form>
            </div>

            
            <div id="bulk-sticker-content" class="sticker-tab-content" style="display: none;">
                <form id="bulk-sticker-form">
                    <div class="form-group">
                        <label for="bulk-sticker-input">일괄 이모티콘 등록</label>
                        <textarea id="bulk-sticker-input" rows="8" placeholder="한 줄에 하나씩 입력하세요:&#10;물음표https://i.postimg.cc/d0YWDkN4/ajsv2e.gif&#10;놀람./images/emoji.png&#10;기쁨data:image/png;base64,iVBORw0K...&#10;웃음file:///C:/happy.jpg" style="width: 100%; resize: vertical; font-family: monospace; font-size: 12px;"></textarea>
                    </div>
                    <div style="background: #f5f5f5; padding: 10px; border-radius: 5px; margin-bottom: 15px; font-size: 12px; color: #666;">
                        <strong>사용법:</strong><br>
                        • 한 줄에 하나씩 이모티콘을 입력하여 여러 개를 한번에 등록<br>
                        • 각 줄은 "이름URL" 형식으로 입력<br>
                        • <strong>지원 형식:</strong><br>
                        &nbsp;&nbsp;- 웹 URL: 물음표https://example.com/image.gif<br>
                        &nbsp;&nbsp;- 상대경로: 놀람./images/emoji.png<br>
                        &nbsp;&nbsp;- 파일경로: 기쁨file:///C:/images/happy.jpg<br>
                        &nbsp;&nbsp;- Base64: 웃음data:image/png;base64,iVBORw0K...<br>
                        • 빈 줄은 자동으로 건너뜁니다
                    </div>
                    <div id="bulk-preview-container" style="max-height: 200px; overflow-y: auto; border: 1px solid #ddd; padding: 10px; margin-bottom: 15px; display: none;">
                        <strong>미리보기 (파싱 결과):</strong>
                        <div id="bulk-preview-content"></div>
                    </div>
                    <button type="button" id="preview-bulk-btn" class="btn btn-secondary" style="width: 100%; margin-bottom: 10px;">미리보기</button>
                    <button type="submit" class="btn btn-primary" style="width: 100%;">일괄 저장</button>
                </form>
            </div>
        </div>
    </div>
    <div id="sticker-actionsheet" class="action-sheet-overlay">
        <div class="action-sheet"><button class="action-sheet-button" id="edit-sticker-btn">편집</button><button class="action-sheet-button danger" id="delete-sticker-btn">삭제</button></div>
    </div>
    <div id="send-voice-modal" class="modal-overlay">
        <div class="modal-window">
            <h3>음성 메시지 보내기</h3>
            <form id="send-voice-form">
                <div class="form-group">
                    <label for="voice-text-input">음성 텍스트 입력</label>
                    <textarea id="voice-text-input" placeholder="여기에 하고 싶은 말을 입력하세요..." required rows="4"></textarea>
                </div>
                <div class="form-group" style="text-align:center; color:#888; font-size: 14px;">
                    예상 시간: <span id="voice-duration-preview">0"</span>
                </div>
                <button type="submit" class="btn btn-primary">보내기</button>
            </form>
        </div>
    </div>
<div id="send-pv-modal" class="modal-overlay">
    <div class="modal-window">
        <h3>사진/영상 공유</h3>
        <form id="send-pv-form">
            <div class="wallpaper-preview" id="pv-image-preview" style="height: 200px; margin-bottom: 15px; border-style: solid; border-width: 2px;">
                <span>사진/영상 미리보기</span>
            </div>
            <input type="file" id="pv-image-upload" accept="image/*" style="display:none;">
            <label for="pv-image-upload" class="btn btn-secondary" style="width: 100%; margin-bottom: 15px;">앨범에서 선택</label>
            <div class="form-group">
                <label for="pv-text-input">설명 입력</label>
                <textarea id="pv-text-input" placeholder="여기에 사진이나 영상 내용을 설명해주세요..." required rows="4"></textarea>
            </div>
            
            <div class="form-group-checkbox" id="pv-ai-recog-wrapper" style="display: none;">
                <label style="display: flex; align-items: center; gap: 10px; justify-content: center;">
                    <input type="checkbox" id="pv-ai-recog-checkbox">
                    AI에게 이미지 인식 요청
                </label>
            </div>
            <button type="submit" class="btn btn-primary">보내기</button>
        </form>
    </div>
</div>
    <div id="send-transfer-modal" class="modal-overlay">
        <div class="modal-window">
            <h3>송금</h3>
            <form id="send-transfer-form">
                <div class="form-group">
                    <label for="transfer-amount-input">금액 (원)</label>
                    <input type="number" id="transfer-amount-input" placeholder="0.00" required step="0.01" min="0.01">
                </div>
                <div class="form-group">
                    <label for="transfer-remark-input">메모</label>
                    <input type="text" id="transfer-remark-input" placeholder="(선택 사항)">
                </div>
                <button type="submit" class="btn btn-primary">보내기</button>
            </form>
        </div>
    </div>
    <div id="send-gift-modal" class="modal-overlay">
        <div class="modal-window">
            <h3>선물 보내기</h3>
            <form id="send-gift-form">
                <div class="form-group">
                    <label for="gift-description-input">선물 설명</label>
                    <textarea id="gift-description-input" placeholder="특별한 선물을 보냈다고 알려주세요..." required rows="4"></textarea>
                </div>
                <button type="submit" class="btn btn-primary">보내기</button>
            </form>
        </div>
    </div>
    
    <div id="time-skip-modal" class="modal-overlay">
        <div class="modal-window">
            <h3>오늘 있었던 일 기록하기</h3>
            <form id="time-skip-form">
                <div class="form-group">
                    <label for="time-skip-input">이벤트 설명 (이 메시지는 AI에게 보이며, 컨텍스트로 사용됩니다)</label>
                    <textarea id="time-skip-input" placeholder="예: 우리는 함께 산 정상에 올라가 일몰을 보고 바베큐를 먹었어요." required rows="4"></textarea>
                </div>
                <button type="submit" class="btn btn-primary">보내기</button>
            </form>
        </div>
    </div>
    
    <div id="group-recipient-selection-modal" class="modal-overlay">
        <div class="modal-window">
            <h3 id="group-recipient-selection-title">받는 사람 선택</h3>
            <ul id="group-recipient-selection-list"></ul>
            <button class="btn btn-primary" id="confirm-group-recipient-btn" style="margin-top: 20px;">확인</button>
        </div>
    </div>
    <div id="receive-transfer-actionsheet" class="action-sheet-overlay">
        <div class="action-sheet">
            <button class="action-sheet-button" id="accept-transfer-btn">받기</button>
            <button class="action-sheet-button danger" id="return-transfer-btn">반환</button>
        </div>
    </div>
    
    <div id="chat-settings-sidebar" class="settings-sidebar">
        <div class="header">채팅 설정</div>
        <div class="content">
            <form id="chat-settings-form">
                <div class="avatar-setting"><img src="" alt="캐릭터 아바타" id="setting-char-avatar-preview" class="avatar-preview"><input type="file" id="setting-char-avatar-upload" accept="image/*" style="display:none;"><label for="setting-char-avatar-upload" class="btn btn-primary" style="flex-grow:1;">캐릭터 아바타 변경</label></div>
                <div class="form-group"><label for="setting-char-remark">캐릭터 메모 (별명)</label><input type="text" id="setting-char-remark"></div>
                <div class="form-group"><label for="setting-char-persona">캐릭터 설정</label><textarea id="setting-char-persona" placeholder="캐릭터의 성격, 배경, 말투 등을 자세히 설명해주세요."></textarea></div>
                <hr style="border:none; border-top:1px solid #eee; margin: 20px 0;">
                <div class="avatar-setting"><img src="" alt="내 아바타" id="setting-my-avatar-preview" class="avatar-preview"><input type="file" id="setting-my-avatar-upload" accept="image/*" style="display:none;"><label for="setting-my-avatar-upload" class="btn btn-secondary" style="flex-grow:1;">내 아바타 변경</label></div>
                <div class="form-group"><label for="setting-my-name">내 이름</label><input type="text" id="setting-my-name"></div>
                <div class="form-group"><label for="setting-my-persona">내 설정</label><textarea id="setting-my-persona" placeholder="대화에서 연기하고 싶은 이미지를 설명해주세요."></textarea></div>
                <hr style="border:none; border-top:1px solid #eee; margin: 20px 0;">
                <div class="form-group"><button type="button" class="btn btn-secondary" id="link-world-book-btn">세계관 연결</button></div>
                <div class="form-group"><label for="setting-theme-color">테마 색상 (상대방/나)</label><select id="setting-theme-color"></select></div>

                <hr style="border:none; border-top:1px solid #eee; margin: 20px 0;">
                <div class="form-group">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <label for="setting-use-custom-css" style="margin-bottom:0;">말풍선 스타일 커스텀</label>
                        <input type="checkbox" id="setting-use-custom-css" style="width: auto;">
                    </div>
                    <div id="bubble-display-options" style="background: #f9f9f9; border-radius: 8px; padding: 5px 15px; margin-bottom: 10px;">
        <div class="form-group-checkbox" style="display: flex; justify-content: space-between; align-items: center; padding: 10px 0px; border-bottom: 1px solid #eee;">
            <label for="setting-hide-my-bubbles-toggle" style="margin:0; font-size: 14px;">내 아이콘 숨기기</label>
            <input type="checkbox" id="setting-hide-my-bubbles-toggle" style="width: 20px; height: 20px; accent-color: var(--primary-color);">
        </div>
        <div class="form-group-checkbox" style="display: flex; justify-content: space-between; align-items: center; padding: 10px 0px; border-bottom: 1px solid #eee;">
            <label for="setting-hide-char-bubbles-toggle" style="margin:0; font-size: 14px;">상대방 아이콘 숨기기</label>
            <input type="checkbox" id="setting-hide-char-bubbles-toggle" style="width: 20px; height: 20px; accent-color: var(--primary-color);">
        </div>
        <div class="form-group-checkbox" style="display: flex; flex-direction: column; align-items: stretch; padding: 10px 0px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                <label for="setting-font-size-slider" style="margin:0; font-size: 14px;">폰트 크기</label>
                <span id="setting-font-size-value" style="font-size: 14px; color: var(--primary-color); font-weight: 500;">14px</span>
            </div>
            <input type="range" id="setting-font-size-slider" min="10" max="20" value="14" step="1" style="width: 100%;">
        </div>
    </div>
                    <div id="private-bubble-css-preview" class="bubble-css-preview" style="background: #fff; border: 1px solid #eee; border-radius: 10px; padding: 15px; margin-bottom: 10px; display: flex; flex-direction: column; gap: 10px;">
                    </div>
                    <textarea id="setting-custom-bubble-css" rows="6" placeholder="여기에 CSS 코드를 입력하세요...&#10;예시:&#10;.message-bubble.sent { background-color: #A5D6A7; }&#10;.message-bubble.received { background-color: #E1E1E1; }" disabled></textarea>
                    <button type="button" class="btn btn-neutral" id="reset-custom-bubble-css-btn" style="margin-top: 10px; width: auto; padding: 5px 15px; font-size: 14px;">기본값으로 복원</button>
                </div>

                <div class="form-group"><label for="setting-max-memory">최대 기억 턴 수</label><input type="number" id="setting-max-memory" value="100" min="1"></div>
                <div class="form-group">
                    <input type="file" id="setting-chat-bg-upload" accept="image/*" style="display:none;">
                    <button type="button" id="setting-chat-bg-btn" class="btn btn-primary">채팅 배경 변경</button>
                </div><button type="submit" class="btn btn-primary">설정 저장</button>
            </form>
            <hr style="border:none; border-top:1px solid #eee; margin: 20px 0;"><button type="button" class="btn btn-danger" id="clear-chat-history-btn">채팅 기록 삭제</button>
        </div>
    </div>
    <div id="world-book-selection-modal" class="modal-overlay">
        <div class="modal-window">
            <h3>연결할 세계관 선택</h3>
            <ul id="world-book-selection-list"></ul>
            <button class="btn btn-primary" id="save-world-book-selection-btn" style="margin-top: 20px;">확인</button>
        </div>
    </div>
    
    <div id="create-group-modal" class="modal-overlay">
        <div class="modal-window">
            <h3>그룹채팅 만들기</h3>
            <form id="create-group-form">
                <div class="form-group">
                    <label>그룹 멤버 선택</label>
                    <ul id="member-selection-list" class="member-selection-list"></ul>
                </div>
                <div class="form-group">
                    <label for="group-name-input">그룹채팅 이름</label>
                    <input type="text" id="group-name-input" placeholder="그룹채팅 이름을 지어주세요" required>
                </div>
                <button type="submit" class="btn btn-primary">그룹채팅 만들기</button>
            </form>
        </div>
    </div>
    
    <div id="group-settings-sidebar" class="settings-sidebar">
        <div class="header">그룹채팅 설정</div>
        <div class="content">
            <form id="group-settings-form">
                <div class="group-avatar-setting">
                    <img src="" alt="그룹 아바타" id="setting-group-avatar-preview" class="group-avatar-preview">
                    <input type="file" id="setting-group-avatar-upload" accept="image/*" style="display:none;">
                    <label for="setting-group-avatar-upload" class="btn btn-primary" style="flex-grow:1;">그룹 아바타 변경</label>
                </div>
                <div class="form-group">
                    <label for="setting-group-name">그룹 이름 (AI에게도 보임)</label>
                    <input type="text" id="setting-group-name">
                </div>
                <hr style="border:none; border-top:1px solid #eee; margin: 20px 0;">
                <div class="avatar-setting">
                    <img src="" alt="내 아바타" id="setting-group-my-avatar-preview" class="avatar-preview">
                    <input type="file" id="setting-group-my-avatar-upload" accept="image/*" style="display:none;">
                    <label for="setting-group-my-avatar-upload" class="btn btn-secondary" style="flex-grow:1;">내 아바타 변경</label>
                </div>
                <div class="form-group">
                    <label for="setting-group-my-nickname">내 그룹 닉네임</label>
                    <input type="text" id="setting-group-my-nickname">
                </div>
                <div class="form-group">
                    <label for="setting-group-my-persona">내 설정</label>
                    <textarea id="setting-group-my-persona" placeholder="이 그룹채팅에서 연기하고 싶은 이미지를 설명해주세요."></textarea>
                </div>
                <hr style="border:none; border-top:1px solid #eee; margin: 20px 0;">
                <div class="form-group">
                    <label>그룹 멤버</label>
                    <div class="group-members-list" id="group-members-list-container"></div>
                </div>
                <hr style="border:none; border-top:1px solid #eee; margin: 20px 0;">
                <div class="form-group"><button type="button" class="btn btn-secondary" id="link-group-world-book-btn">세계관 연결</button></div>
                <div class="form-group"><label for="setting-group-theme-color">테마 색상 (상대방/나)</label><select id="setting-group-theme-color"></select></div>

                <hr style="border:none; border-top:1px solid #eee; margin: 20px 0;">
                <div class="form-group">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <label for="setting-group-use-custom-css" style="margin-bottom:0;">말풍선 스타일 커스텀</label>
                        <input type="checkbox" id="setting-group-use-custom-css" style="width: auto;">
                    </div>
        <div id="group-bubble-display-options" style="background: #f9f9f9; border-radius: 8px; padding: 5px 15px; margin-bottom: 10px;">
        <div class="form-group-checkbox" style="display: flex; justify-content: space-between; align-items: center; padding: 10px 0px; border-bottom: 1px solid #eee;">
            <label for="setting-group-hide-my-bubbles-toggle" style="margin:0; font-size: 14px;">내 아이콘 숨기기</label>
            <input type="checkbox" id="setting-group-hide-my-bubbles-toggle" style="width: 20px; height: 20px; accent-color: var(--primary-color);">
        </div>
        <div class="form-group-checkbox" style="display: flex; justify-content: space-between; align-items: center; padding: 10px 0px; border-bottom: 1px solid #eee;">
            <label for="setting-group-hide-char-bubbles-toggle" style="margin:0; font-size: 14px;">상대방 아이콘 숨기기</label>
            <input type="checkbox" id="setting-group-hide-char-bubbles-toggle" style="width: 20px; height: 20px; accent-color: var(--primary-color);">
        </div>
        <div class="form-group-checkbox" style="display: flex; flex-direction: column; align-items: stretch; padding: 10px 0px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                <label for="setting-group-font-size-slider" style="margin:0; font-size: 14px;">폰트 크기</label>
                <span id="setting-group-font-size-value" style="font-size: 14px; color: var(--primary-color); font-weight: 500;">14px</span>
            </div>
            <input type="range" id="setting-group-font-size-slider" min="10" max="20" value="14" step="1" style="width: 100%;">
        </div>
    </div>
                    <div id="group-bubble-css-preview" class="bubble-css-preview" style="background: #fff; border: 1px solid #eee; border-radius: 10px; padding: 15px; margin-bottom: 10px; display: flex; flex-direction: column; gap: 10px;">
                    </div>
                    <textarea id="setting-group-custom-bubble-css" rows="6" placeholder="여기에 CSS 코드를 입력하세요...&#10;예시:&#10;.message-bubble.sent { background-color: #A5D6A7; }&#10;.message-bubble.received { background-color: #E1E1E1; }" disabled></textarea>
                    <button type="button" class="btn btn-neutral" id="reset-group-custom-bubble-css-btn" style="margin-top: 10px; width: auto; padding: 5px 15px; font-size: 14px;">기본값으로 복원</button>
                </div>

                <div class="form-group"><label for="setting-group-max-memory">최대 기억 턴 수</label><input type="number" id="setting-group-max-memory" value="10" min="1"></div>
                <div class="form-group"><label for="setting-group-chat-bg-upload" class="btn btn-primary">채팅 배경 변경</label><input type="file" id="setting-group-chat-bg-upload" accept="image/*" style="display:none;"></div>
                <button type="submit" class="btn btn-primary">설정 저장</button>
            </form>
            <hr style="border:none; border-top:1px solid #eee; margin: 20px 0;">
            <button type="button" class="btn btn-danger" id="clear-group-chat-history-btn">채팅 기록 삭제</button>
        </div>
    </div>
    
    <div id="edit-group-member-modal" class="modal-overlay">
        <div class="modal-window">
            <h3 id="edit-group-member-title">그룹 멤버 편집</h3>
            <form id="edit-group-member-form">
                <input type="hidden" id="editing-member-id">
                <div class="avatar-setting" style="justify-content: center;">
                    <img src="" alt="멤버 아바타" id="edit-member-avatar-preview" class="avatar-preview" style="cursor: pointer;">
                    <input type="file" id="edit-member-avatar-upload" accept="image/*" style="display:none;">
                </div>
                <div class="form-group">
                    <label for="edit-member-group-nickname">그룹 닉네임</label>
                    <input type="text" id="edit-member-group-nickname" required>
                </div>
                <div class="form-group">
                    <label for="edit-member-real-name">실명</label>
                    <input type="text" id="edit-member-real-name" required>
                </div>
                <div class="form-group">
                    <label for="edit-member-persona">설정</label>
                    <textarea id="edit-member-persona" placeholder="캐릭터의 성격, 배경 등을 자세히 설명해주세요."></textarea>
                </div>
                <button type="submit" class="btn btn-primary">저장</button>
            </form>
        </div>
    </div>
    
    <div id="add-member-actionsheet" class="action-sheet-overlay">
        <div class="action-sheet">
            <button class="action-sheet-button" id="invite-existing-member-btn">기존 캐릭터 초대</button>
            <button class="action-sheet-button" id="create-new-member-btn">새 캐릭터 만들어 초대하기</button>
        </div>
    </div>
    
    <div id="invite-member-modal" class="modal-overlay">
        <div class="modal-window">
            <h3>그룹채팅에 멤버 초대</h3>
            <ul id="invite-member-selection-list"></ul>
            <button class="btn btn-primary" id="confirm-invite-btn" style="margin-top: 20px;">초대 확인</button>
        </div>
    </div>
    
    <div id="create-member-for-group-modal" class="modal-overlay">
        <div class="modal-window">
            <h3>새 캐릭터 만들어 그룹에 추가</h3>
            <form id="create-member-for-group-form">
                <div class="avatar-setting" style="justify-content: center;">
                    <img src="https://i.postimg.cc/Y96LPskq/o-o-2.jpg" alt="새 멤버 아바타" id="create-group-member-avatar-preview" class="avatar-preview" style="cursor: pointer;">
                    <input type="file" id="create-group-member-avatar-upload" accept="image/*" style="display:none;">
                </div>
                <div class="form-group">
                    <label for="create-group-member-nickname">그룹 닉네임</label>
                    <input type="text" id="create-group-member-nickname" required>
                </div>
                <div class="form-group">
                    <label for="create-group-member-realname">실명</label>
                    <input type="text" id="create-group-member-realname" required>
                </div>
                <div class="form-group">
                    <label for="create-group-member-persona">설정</label>
                    <textarea id="create-group-member-persona" placeholder="캐릭터의 성격, 배경 등을 자세히 설명해주세요."></textarea>
                </div>
                <button type="submit" class="btn btn-primary">만들어서 추가</button>
            </form>
        </div>
    </div>
    <!-- START: 추가할 HTML (새로운 화면들) -->
    <div id="feed-screen" class="screen">
        <header class="app-header">
            <div class="placeholder"></div>
            <div class="title-container">
                <h1 class="title">피드</h1>
            </div>
            <div class="placeholder"></div>
        </header>
        <main class="content" id="feed-container" style="padding: 10px; padding-bottom: calc(120px + env(safe-area-inset-bottom));background-color: #f0f2f5;">
            <!-- 피드 게시물은 JS로 렌더링 됩니다 -->
        </main>
    </div>

    <div id="schedule-screen" class="screen">
        <header class="app-header">
            <div class="placeholder"></div>
            <div class="title-container">
                <h1 class="title">일정</h1>
            </div>
            <div class="placeholder"></div>
        </header>
        <main class="content">
            <div class="placeholder-text" style="margin-top: 50px;">
                <p>일정 기능은 준비 중입니다.</p>
            </div>
        </main>
    </div>

    <div id="profile-screen" class="screen">
        <header class="app-header">
            <button class="back-btn" data-target="feed-screen">
                <svg viewBox="0 0 24 24" fill="currentColor"><path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"></path></svg>
            </button>
            <div class="title-container">
                <h1 class="title" id="profile-name"></h1>
            </div>
            <div class="placeholder"></div>
        </header>
        <main class="content" id="profile-container" style="padding: 0; background-color: #f0f2f5;"></main>
    </div>

    <nav class="bottom-nav" id="bottom-nav-bar" style="display: none;">
        <a href="#" class="nav-btn active" data-target="chat-list-screen">
            <svg viewBox="0 0 24 24"><path d="M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2z"></path></svg>
            <span>채팅</span>
        </a>
        <a href="#" class="nav-btn" data-target="feed-screen">
            <svg viewBox="0 0 24 24"><path d="M3 13h8V3H3v10zm0 8h8v-6H3v6zm10 0h8V11h-8v10zm0-18v6h8V3h-8z"></path></svg>
            <span>피드</span>
        </a>
        <a href="#" class="nav-btn" data-target="schedule-screen">
            <svg viewBox="0 0 24 24"><path d="M17 12h-5v5h5v-5zM16 1v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2h-1V1h-2zm3 18H5V8h14v11z"></path></svg>
            <span>일정</span>
        </a>
    </nav>
<!-- END: 추가할 HTML -->
</div>

<script>
    
    function getRandomValue(str) {
        
        if (str.includes(',')) {
            
            const arr = str.split(',').map(item => item.trim());
            
            const randomIndex = Math.floor(Math.random() * arr.length);
            
            return arr[randomIndex];
        }
        
        return str;
    }
    document.addEventListener('DOMContentLoaded', () => {
        
        const IS_DEVELOPMENT_MODE = false; 
        console.log('현재 빌드 모드:', IS_DEVELOPMENT_MODE ? '개발용 (Development)' : '배포용 (Production)');
        
        async function compressImage(file, options = {}) {
            const {
                quality = 0.8, maxWidth = 800, maxHeight = 800
            } = options;

            
            
            if (file.type === 'image/gif') {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.readAsDataURL(file);
                    reader.onload = () => resolve(reader.result);
                    reader.onerror = error => reject(error);
                });
            }

            
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onerror = reject;
                reader.onload = (event) => {
                    const img = new Image();
                    img.src = event.target.result;
                    img.onerror = reject;
                    img.onload = () => {
                        let width = img.width;
                        let height = img.height;

                        if (width > height) {
                            if (width > maxWidth) {
                                height = Math.round(height * (maxWidth / width));
                                width = maxWidth;
                            }
                        } else {
                            if (height > maxHeight) {
                                width = Math.round(width * (maxHeight / height));
                                height = maxHeight;
                            }
                        }

                        const canvas = document.createElement('canvas');
                        canvas.width = width;
                        canvas.height = height;
                        const ctx = canvas.getContext('2d');

                        
                        
                        if (file.type === 'image/png') {
                            ctx.fillStyle = '#FFFFFF'; 
                            ctx.fillRect(0, 0, width, height);
                        }
                        
                        ctx.drawImage(img, 0, 0, width, height);
                        
                        
                        
                        const compressedDataUrl = canvas.toDataURL('image/jpeg', quality); 
                        resolve(compressedDataUrl);
                    };
                };
            });
        }
        
        
        function initializeFontPresets() {
            
            console.log('폰트 프리셋 초기화 시작');
            
            
            if (!db.globalFontPresets.presets.custom) {
                db.globalFontPresets.presets.custom = {
                    name: '커스텀 폰트',
                    url: '',
                    description: '직접 입력한 폰트 URL을 사용합니다',
                    deletable: false 
                };
                console.log('커스텀 폰트 프리셋 추가됨');
            } else {
                
                if (db.globalFontPresets.presets.custom.deletable === undefined) {
                    db.globalFontPresets.presets.custom.deletable = false;
                }
                console.log('기존 커스텀 폰트 프리셋 확인됨:', db.globalFontPresets.presets.custom);
            }
            
            
            const defaultFonts = [
                {
                    id: 'default_1',
                    name: '노토 산스 KR',
                    url: 'https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@100;300;400;500;700;900&display=swap',
                    description: '한국어에 최적화된 고품질 폰트'
                },
                {
                    id: 'default_2',
                    name: '나눔 고딕',
                    url: 'https://fonts.googleapis.com/css2?family=Nanum+Gothic:wght@400;700;800&display=swap',
                    description: '가독성이 좋은 고딕체'
                },
                {
                    id: 'default_3',
                    name: '나눔 명조',
                    url: 'https://fonts.googleapis.com/css2?family=Nanum+Myeongjo:wght@400;700;800&display=swap',
                    description: '전통적인 명조체'
                },
                {
                    id: 'default_4',
                    name: '싱글 데이',
                    url: 'https://fonts.googleapis.com/css2?family=Single+Day&display=swap',
                    description: '귀여운 손글씨 스타일'
                },
                {
                    id: 'default_5',
                    name: '구기',
                    url: 'https://fonts.googleapis.com/css2?family=Gugi&display=swap',
                    description: '둥글둥글한 귀여운 폰트'
                },
                {
                    id: 'default_6',
                    name: '주아',
                    url: 'https://fonts.googleapis.com/css2?family=Jua&display=swap',
                    description: '부드러운 손글씨 스타일'
                },
                {
                    id: 'default_7',
                    name: '검은 한산',
                    url: 'https://fonts.googleapis.com/css2?family=Black+Han+Sans&display=swap',
                    description: '굵고 강렬한 인상의 폰트'
                },
                {
                    id: 'default_8',
                    name: '해바라기',
                    url: 'https://fonts.googleapis.com/css2?family=Sunflower:wght@300;500;700&display=swap',
                    description: '밝고 경쾌한 느낌의 폰트'
                },
                {
                    id: 'default_9',
                    name: '연성',
                    url: 'https://fonts.googleapis.com/css2?family=Yeon+Sung&display=swap',
                    description: '전통적인 느낌의 폰트'
                },
                {
                    id: 'default_10',
                    name: 'IBM 플렉스 산스 KR',
                    url: 'https://fonts.googleapis.com/css2?family=IBM+Plex+Sans+KR:wght@100;200;300;400;500;600;700&display=swap',
                    description: '기업용으로 적합한 전문적인 폰트'
                },
                {
                    id: 'default_11',
                    name: '고운바탕',
                    url: 'https://fonts.googleapis.com/css2?family=Gowun+Batang:wght@400;700&display=swap',
                    description: '구글 폰트 고운바탕 - 깔끔하고 가독성 좋은 폰트'
                },
                {
                    id: 'default_12',
                    name: '프리텐다드',
                    url: 'https://fastly.jsdelivr.net/gh/Project-Noonnu/noonfonts_2107@1.1/Pretendard-Regular.woff',
                    description: '현대적이고 가독성 좋은 폰트'
                },
                {
                    id: 'default_13',
                    name: '쿠키런',
                    url: 'https://fastly.jsdelivr.net/gh/projectnoonnu/noonfonts_2001@1.1/CookieRun-Regular.woff',
                    description: '귀엽고 아기자기한 폰트'
                }
            ];
            
            
            defaultFonts.forEach(font => {
                if (!db.globalFontPresets.presets[font.id]) {
                    db.globalFontPresets.presets[font.id] = {
                        name: font.name,
                        url: font.url,
                        description: font.description,
                        deletable: true 
                    };
                    console.log(`기본 폰트 프리셋 추가됨: ${font.name}`);
                }
            });
            
            
            if (!db.globalFontPresets.presets[db.globalFontPresets.currentPreset]) {
                console.log('현재 프리셋이 존재하지 않음:', db.globalFontPresets.currentPreset);
                db.globalFontPresets.currentPreset = 'custom';
                console.log('currentPreset을 custom으로 강제 설정');
            }
            
            console.log('폰트 프리셋 초기화 완료 - 최종 상태:', {
                currentPreset: db.globalFontPresets.currentPreset,
                availablePresets: Object.keys(db.globalFontPresets.presets)
            });
        }
        
        
        
        const githubInfoButtons = IS_DEVELOPMENT_MODE ? `
            <hr style="margin: 15px 0; border: none; border-top: 1px solid #ddd;">
            <button type="button" id="github-info-download-btn" class="btn btn-neutral" style="width: 100%; margin-bottom: 10px;">GitHub 정보 다운로드</button>
            <button type="button" id="github-info-upload-btn" class="btn btn-secondary" style="width: 100%;">GitHub 설정 업로드 복원</button>
            <input type="file" id="github-info-upload-input" accept=".json" style="display: none;">
        ` : '';
        
        
        const patIncludeOption = IS_DEVELOPMENT_MODE ? `
            <div class="form-group">
                <label style="display: flex; align-items: center; gap: 10px;">
                    <input type="checkbox" id="include-pat-in-download" checked>PAT 키를 다운로드에 포함 (개인용)
                </label>
                <p style="font-size:12px; color:#888; margin-top:8px;">체크 해제 시 PAT는 제외됩니다 (배포용)</p>
            </div>
        ` : '';

        document.getElementById('api-settings-screen').innerHTML = `<header class="app-header"><button class="back-btn" data-target="home-screen">
                <svg viewBox="0 0 24 24" fill="currentColor"><path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"></path></svg>
            </button><div class="title-container"><h1 class="title">API 설정</h1></div><div class="placeholder"></div></header><main class="content"><form id="api-form"><div class="form-group"><label for="api-provider">API 공급자</label><select id="api-provider" name="provider"><option value="newapi">NewAPI (사용자 정의)</option><option value="openai">OpenAI (GPT)</option><option value="deepseek">DeepSeek</option><option value="claude">Claude</option><option value="gemini">Gemini</option><option value="openrouter">OpenRouter</option></select></div><div class="form-group"><label for="api-url">API 주소 (끝에 /v1를 추가하지 마세요)</label><input type="url" id="api-url" name="url" placeholder="공급자 선택 시 자동 완성" required></div><div class="form-group"><label for="api-key">API 키 (Key)</label><div style="position: relative;"><input type="password" id="api-key" name="key" placeholder="API 키를 입력하세요" required style="padding-right: 40px;"><button type="button" id="toggle-api-key-btn" style="position: absolute; right: 8px; top: 50%; transform: translateY(-50%); background: none; border: none; cursor: pointer; font-size: 16px; color: #666;">🔑</button></div></div><button type="button" class="btn btn-secondary" style= "margin-bottom: 20px;" id="fetch-models-btn"><span class="btn-text">모델 목록 가져오기</span><div class="spinner"></div></button><div class="form-group"><label for="api-model">모델 선택</label><div class="model-search-container" style="position: relative;"><input type="text" id="model-search" placeholder="모델명 검색... AND: free,gpt | OR: gpt-4|claude" style="width: 100%; padding: 8px 12px; border: 1px solid #ddd; border-radius: 5px; margin-bottom: 8px; font-size: 14px;"><select id="api-model" name="model" required><option value="">먼저 모델 목록을 가져오세요</option></select><div id="model-search-info" style="font-size: 12px; color: #888; margin-top: 5px; text-align: center;"></div></div></div><button type="submit" class="btn btn-primary" id="save-btn"><span class="btn-text">저장</span><div class="spinner"></div></button></form><hr style="margin: 30px 0; border: none; border-top: 1px solid #eee;"><div style="margin-bottom: 20px;"><h3 style="margin: 13px 5px; font-size: 16px;     font-weight: 500; color: var(--text-color);">데이터 관리</h3><p style="font-size: 14px; color: #888; margin: 13px 5px 20px 5px;">채팅 데이터, 캐릭터, 그룹채팅, 설정 등을 백업하거나 복원할 수 있습니다.</p><button type="button" class="btn btn-primary" id="backup-data-btn" style="width: 100%; margin-bottom: 10px;">데이터 백업 (다운로드)</button><button type="button" class="btn btn-secondary" id="restore-data-btn" style="width: 100%; margin-bottom: 10px;">데이터 복원 (업로드)</button><hr style="margin: 20px 0; border: none; border-top: 1px solid #eee;"><div class="github-sync-section" style="margin-bottom: 20px;"><h4 style="margin-bottom: 15px; color: var(--text-color); cursor: pointer; font-size: 14px;" id="github-sync-toggle">GitHub 동기화 <span style="font-size: 12px; color: #888;">▼</span></h4><div id="github-sync-content" style="display: none;"><div class="form-group"><label for="github-username">GitHub 사용자 이름</label><input type="text" id="github-username" placeholder="YourGitHubUsername"></div><div class="form-group"><label for="github-repo">저장소 이름 (Repository)</label><input type="text" id="github-repo" placeholder="my-chat-data-repo"></div><div class="form-group"><label for="github-pat">개인용 액세스 토큰 (PAT)</label><input type="password" id="github-pat" placeholder="ghp_..."><p style="font-size:12px; color:#888; margin-top:8px; margin: 8px 5px">토큰은 <a href="https://github.com/settings/tokens/new?scopes=repo&description=GeminiChatSync" target="_blank">여기</a>에서 'repo' 권한으로 생성하세요. 토큰은 브라우저에만 저장됩니다.</p></div><div class="form-group"><label for="github-filename">파일명 (선택사항)</label><input type="text" id="github-filename" value="phone-chat-data.json"></div>${patIncludeOption}<div class="form-group-checkbox"><label style="display: flex; align-items: center; gap: 10px;"><input type="checkbox" id="merge-data-on-restore" checked>데이터 복원 시 병합 모드 (안전)</label><p style="font-size:12px; color:#888; margin-top:8px;">체크 시: 기존 데이터와 병합 (손실 없음) | 체크 해제 시: 완전 덮어쓰기 (위험)</p></div><div class="css-actions"><button type="button" id="save-sync-settings-btn" class="btn btn-primary" style="width: 100%;">설정 저장</button><button type="button" id="sync-up-btn" class="btn btn-secondary" style="width: 100%;" disabled>데이터 올리기</button><button type="button" id="sync-down-btn" class="btn btn-danger" style="width: 100%;" disabled>데이터 덮어쓰기</button>${githubInfoButtons}</div></div></div></div></main>`;
        document.getElementById('customize-screen').innerHTML = `<header class="app-header"><button class="back-btn" data-target="home-screen">
                <svg viewBox="0 0 24 24" fill="currentColor"><path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"></path></svg>
            </button><div class="title-container"><h1 class="title">홈 화면 커스텀</h1></div><div class="placeholder"></div></header><main class="content"><form id="customize-form"></form></main>`;
        document.getElementById('tutorial-screen').innerHTML = `<header class="app-header"><button class="back-btn" data-target="home-screen">
                <svg viewBox="0 0 24 24" fill="currentColor"><path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"></path></svg>
            </button><div class="title-container"><h1 class="title">튜토리얼</h1></div><div class="placeholder"></div></header><main class="content" id="tutorial-content-area"></main>`;

        
        const colorThemes = {
            'white_pink': { name: '흰색/분홍', received: { bg: 'rgba(255,255,255,0.9)', text: '#6D6D6D' }, sent: { bg: 'rgba(255,204,204,0.9)', text: '#A56767' } },
            'white_blue': { name: '흰색/파랑', received: { bg: 'rgba(255,255,255,0.9)', text: '#6D6D6D' }, sent: { bg: 'rgba(173,216,230,0.9)', text: '#4A6F8A' } },
            'white_yellow': { name: '흰색/노랑', received: { bg: 'rgba(255,255,255,0.9)', text: '#6D6D6D' }, sent: { bg: 'rgba(249,237,105,0.9)', text: '#8B7E4B' } },
            'white_green': { name: '흰색/초록', received: { bg: 'rgba(255,255,255,0.9)', text: '#6D6D6D' }, sent: { bg: 'rgba(188,238,188,0.9)', text: '#4F784F' } },
            'white_purple': { name: '흰색/보라', received: { bg: 'rgba(255,255,255,0.9)', text: '#6D6D6D' }, sent: { bg: 'rgba(185,190,240,0.9)', text: '#6C5B7B' } },
            'black_red': { name: '검정/빨강', received: { bg: 'rgba(30,30,30,0.85)', text: '#E0E0E0' }, sent: { bg: 'rgb(226,62,87,0.9)', text: '#fff' } },
            'black_green': { name: '검정/초록', received: { bg: 'rgba(30,30,30,0.85)', text: '#E0E0E0' }, sent: { bg: 'rgba(119,221,119,0.9)', text: '#2E5C2E' } },
            'black_white': { name: '검정/흰색', received: { bg: 'rgba(30,30,30,0.85)', text: '#E0E0E0' }, sent: { bg: 'rgba(245,245,245,0.9)', text: '#333' } },
            'white_black': { name: '흰색/검정', received: { bg: 'rgba(255,255,255,0.9)', text: '#6D6D6D' }, sent: { bg: 'rgba(50,50,50,0.85)', text: '#F5F5F5' } },
            'yellow_purple': { name: '노랑/보라', received: { bg: 'rgba(255,250,205,0.9)', text: '#8B7E4B' }, sent: { bg: 'rgba(185,190,240,0.9)', text: '#6C5B7B' } },
            'pink_blue': { name: '분홍/파랑', received: { bg: 'rgba(255,231,240,0.9)', text: '#7C6770' }, sent: { bg: 'rgba(173,216,230,0.9)', text: '#4A6F8A' } },
        };
        const defaultIcons = {
            'chat-list-screen': { name: '404', url: 'https://i.postimg.cc/VvQB8dQT/chan-143.png' },
            'api-settings-screen': { name: 'API', url: 'https://i.postimg.cc/50FqT8GL/chan-125.png' },
            'wallpaper-screen': { name: '커스텀', url: 'https://i.postimg.cc/3wqFttL3/chan-90.png' },
            'world-book-screen': { name: '세계관', url: 'https://i.postimg.cc/prCWkrKT/chan-74.png' },
            'customize-screen': { name: '홈 화면', url: 'https://i.postimg.cc/vZVdC7gt/chan-133.png' },
            'font-settings-screen': { name: '글꼴', url: 'https://i.postimg.cc/FzVtC0x4/chan-21.png' },
            'tutorial-screen': { name: '튜토리얼', url: 'https://i.postimg.cc/6QgNzCFf/chan-118.png' },
            'day-mode-btn': { name: '', url: 'https://i.postimg.cc/Jz0tYqnT/chan-145.png' },
            'night-mode-btn': { name: '', url: 'https://i.postimg.cc/htYvkdQK/chan-146.png' }
        };

        let db = { characters: [], groups: [], apiSettings: {}, wallpaper: 'https://i.postimg.cc/W4Z9R9x4/ins-1.jpg', myStickers: [], homeScreenMode: 'night', worldBooks: [], fontUrl: '', customIcons: {}, globalCustomCSS: { enabled: true, currentPreset: 'default', presets: { 'default': { name: '기본', css: '', description: '기본 테마' } } }, globalFontPresets: { enabled: true, currentPreset: 'default', presets: {} }, customFontInput: { name: '', url: '', description: '' } };
        let currentChatId = null, currentChatType = null, isGenerating = false, longPressTimer = null, isInMultiSelectMode = false, editingMessageId = null, currentPage = 1, currentTransferMessageId = null, currentEditingWorldBookId = null, currentStickerActionTarget = null, currentGroupAction = { type: null, recipients: [] };
        let selectedMessageIds = new Set();
        const MESSAGES_PER_PAGE = 50;

        let editingMessageContext = null; // 편집 컨텍스트 저장용
const editableMessageRegexes = {
    text: /\[(?:.+?)님의 메시지:([\s\S]+)\]/,
    voice: /\[(?:.+?)님의 음성:([\s\S]+?)\]/,
    photoVideo: /\[(?:.+?)님의 사진\/영상:([\s\S]+?)\]/,
    gift: /\[(?:.+?)님이 보낸 선물:([\s\S]+?)\]|\[(?:.+?)님이 (?:.+?)님에게 선물을 보냈습니다:([\s\S]+?)\]/,
    sticker: /\[(?:.+?)님의 이모티콘:([\s\S]+?)\]/,
    systemDisplay: /\[system-display:([\s\S]+?)\]/,
    // 송금 관련 정규식을 하나로 통합하고, 전체 내용을 캡처하도록 변경
    transfer: /(\[(?:.*?에게 송금|.*?님의 송금|.*?님이 .*?님에게 송금):[\d.]+원；메모:.*?\])/
};
        
        const screens = document.querySelectorAll('.screen'), toastElement = document.getElementById('toast-notification'), homeScreen = document.getElementById('home-screen'), chatListContainer = document.getElementById('chat-list-container'), noChatsPlaceholder = document.getElementById('no-chats-placeholder'), addChatBtn = document.getElementById('add-chat-btn'), addCharModal = document.getElementById('add-char-modal'), addCharForm = document.getElementById('add-char-form'), chatRoomScreen = document.getElementById('chat-room-screen'), chatRoomHeaderDefault = document.getElementById('chat-room-header-default'), chatRoomHeaderSelect = document.getElementById('chat-room-header-select'), cancelMultiSelectBtn = document.getElementById('cancel-multi-select-btn'), multiSelectTitle = document.getElementById('multi-select-title'), chatRoomTitle = document.getElementById('chat-room-title'), chatRoomStatusText = document.getElementById('chat-room-status-text'), messageArea = document.getElementById('message-area'), messageInputDefault = document.getElementById('message-input-default'), messageInput = document.getElementById('message-input'), sendMessageBtn = document.getElementById('send-message-btn'), getReplyBtn = document.getElementById('get-reply-btn'), typingIndicator = document.getElementById('typing-indicator'), chatSettingsBtn = document.getElementById('chat-settings-btn'), settingsSidebar = document.getElementById('chat-settings-sidebar'), settingsForm = document.getElementById('chat-settings-form'), messageEditBar = document.getElementById('message-edit-bar'), messageEditInput = document.getElementById('message-edit-input'), saveEditBtn = document.getElementById('save-edit-btn'), cancelEditBtn = document.getElementById('cancel-edit-btn'), multiSelectBar = document.getElementById('multi-select-bar'), selectCount = document.getElementById('select-count'), deleteSelectedBtn = document.getElementById('delete-selected-btn');
        const stickerToggleBtn = document.getElementById('sticker-toggle-btn'), stickerModal = document.getElementById('sticker-modal'), stickerGridContainer = document.getElementById('sticker-grid-container'), addNewStickerBtn = document.getElementById('add-new-sticker-btn'), addStickerModal = document.getElementById('add-sticker-modal'), addStickerModalTitle = document.getElementById('add-sticker-modal-title'), addStickerForm = document.getElementById('add-sticker-form'), stickerEditIdInput = document.getElementById('sticker-edit-id'), stickerPreview = document.getElementById('sticker-preview'), stickerNameInput = document.getElementById('sticker-name'), stickerUrlInput = document.getElementById('sticker-url-input'), stickerFileUpload = document.getElementById('sticker-file-upload');
        const stickerActionSheet = document.getElementById('sticker-actionsheet'), editStickerBtn = document.getElementById('edit-sticker-btn'), deleteStickerBtn = document.getElementById('delete-sticker-btn');
        const voiceMessageBtn = document.getElementById('voice-message-btn'), sendVoiceModal = document.getElementById('send-voice-modal'), sendVoiceForm = document.getElementById('send-voice-form'), voiceTextInput = document.getElementById('voice-text-input'), voiceDurationPreview = document.getElementById('voice-duration-preview');
        const photoVideoBtn = document.getElementById('photo-video-btn'), sendPvModal = document.getElementById('send-pv-modal'), sendPvForm = document.getElementById('send-pv-form'), pvTextInput = document.getElementById('pv-text-input');
        const imageRecognitionBtn = document.getElementById('image-recognition-btn'), imageUploadInput = document.getElementById('image-upload-input');
        const walletBtn = document.getElementById('wallet-btn'), sendTransferModal = document.getElementById('send-transfer-modal'), sendTransferForm = document.getElementById('send-transfer-form'), transferAmountInput = document.getElementById('transfer-amount-input'), transferRemarkInput = document.getElementById('transfer-remark-input');
        const receiveTransferActionSheet = document.getElementById('receive-transfer-actionsheet'), acceptTransferBtn = document.getElementById('accept-transfer-btn'), returnTransferBtn = document.getElementById('return-transfer-btn');
        const giftBtn = document.getElementById('gift-btn'), sendGiftModal = document.getElementById('send-gift-modal'), sendGiftForm = document.getElementById('send-gift-form'), giftDescriptionInput = document.getElementById('gift-description-input');
        const timeSkipBtn = document.getElementById('time-skip-btn'), timeSkipModal = document.getElementById('time-skip-modal'), timeSkipForm = document.getElementById('time-skip-form'), timeSkipInput = document.getElementById('time-skip-input');
        const clearChatHistoryBtn = document.getElementById('clear-chat-history-btn');
        const worldBookListContainer = document.getElementById('world-book-list-container'), noWorldBooksPlaceholder = document.getElementById('no-world-books-placeholder'), addWorldBookBtn = document.getElementById('add-world-book-btn'), editWorldBookScreen = document.getElementById('edit-world-book-screen'), editWorldBookForm = document.getElementById('edit-world-book-form'), worldBookIdInput = document.getElementById('world-book-id'), worldBookNameInput = document.getElementById('world-book-name'), worldBookContentInput = document.getElementById('world-book-content');
        const linkWorldBookBtn = document.getElementById('link-world-book-btn'), worldBookSelectionModal = document.getElementById('world-book-selection-modal'), worldBookSelectionList = document.getElementById('world-book-selection-list'), saveWorldBookSelectionBtn = document.getElementById('save-world-book-selection-btn');
        const fontSettingsForm = document.getElementById('font-settings-form'), fontUrlInput = document.getElementById('font-url'), restoreDefaultFontBtn = document.getElementById('restore-default-font-btn');
        const createGroupBtn = document.getElementById('create-group-btn'), createGroupModal = document.getElementById('create-group-modal'), createGroupForm = document.getElementById('create-group-form'), memberSelectionList = document.getElementById('member-selection-list'), groupNameInput = document.getElementById('group-name-input'), groupSettingsSidebar = document.getElementById('group-settings-sidebar'), groupSettingsForm = document.getElementById('group-settings-form'), groupMembersListContainer = document.getElementById('group-members-list-container'), editGroupMemberModal = document.getElementById('edit-group-member-modal'), editGroupMemberForm = document.getElementById('edit-group-member-form');
        const addMemberActionSheet = document.getElementById('add-member-actionsheet'), inviteExistingMemberBtn = document.getElementById('invite-existing-member-btn'), createNewMemberBtn = document.getElementById('create-new-member-btn'), inviteMemberModal = document.getElementById('invite-member-modal'), inviteMemberSelectionList = document.getElementById('invite-member-selection-list'), confirmInviteBtn = document.getElementById('confirm-invite-btn'), createMemberForGroupModal = document.getElementById('create-member-for-group-modal'), createMemberForGroupForm = document.getElementById('create-member-for-group-form');
        const customizeForm = document.getElementById('customize-form'), tutorialContentArea = document.getElementById('tutorial-content-area');
        const groupRecipientSelectionModal = document.getElementById('group-recipient-selection-modal'), groupRecipientSelectionList = document.getElementById('group-recipient-selection-list'), confirmGroupRecipientBtn = document.getElementById('confirm-group-recipient-btn'), groupRecipientSelectionTitle = document.getElementById('group-recipient-selection-title');
        const linkGroupWorldBookBtn = document.getElementById('link-group-world-book-btn');
        const attachmentToggleBtn = document.getElementById('attachment-toggle-btn');
        const stickerBar = document.getElementById('sticker-bar');
        const textarea = document.querySelector('.message-input-area textarea');
        
        const saveData = () => localStorage.setItem('gemini-chat-app-db', JSON.stringify(db));
        const loadData = () => {
            const data = localStorage.getItem('gemini-chat-app-db');
            if (data) db = JSON.parse(data);
            
            if (!db.apiSettings) db.apiSettings = {};
            if (!db.wallpaper) db.wallpaper = 'https://i.postimg.cc/W4Z9R9x4/ins-1.jpg';
            if (!db.characters) db.characters = [];
            if (!db.groups) db.groups = [];
            if (!db.myStickers) db.myStickers = [];
            if (!db.homeScreenMode) db.homeScreenMode = 'night';
            if (!db.worldBooks) db.worldBooks = [];
            
            if (!db.customIcons) db.customIcons = {};
            if (!db.globalCustomCSS) db.globalCustomCSS = { enabled: true, currentPreset: 'default', presets: { 'default': { name: '기본', css: '', description: '기본 테마' } } };
            if (!db.globalFontPresets) db.globalFontPresets = { enabled: true, currentPreset: 'custom', presets: {} };

            if (!db.globalSettings) {
                db.globalSettings = {
                    aiCanUseSystem: false,
                    hideUserIcons: false,
                    hideCharacterIcons: false
                };
            }
            
            if (db.globalFontPresets.currentPreset === 'default' || !db.globalFontPresets.currentPreset) {
                db.globalFontPresets.currentPreset = 'custom';
                console.log('잘못된 currentPreset을 custom으로 수정함');
            }
            
            initializeFontPresets();
            db.characters.forEach(c => {
                if (c.isPinned === undefined) c.isPinned = false;
                if (c.status === undefined) c.status = '온라인';
                if (!c.worldBookIds) c.worldBookIds = [];
                if (c.customBubbleCss === undefined) c.customBubbleCss = '';
                if (c.useCustomBubbleCss === undefined) c.useCustomBubbleCss = false;
                if (c.hideMyIcons === undefined) c.hideMyIcons = false; // 이름 변경
                if (c.hideCharIcons === undefined) c.hideCharIcons = false; // 이름 변경
                if (c.fontSize === undefined) c.fontSize = 14;
            });
            db.groups.forEach(g => {
                if (g.isPinned === undefined) g.isPinned = false;
                if (!g.worldBookIds) g.worldBookIds = [];
                if (g.customBubbleCss === undefined) g.customBubbleCss = '';
                if (g.useCustomBubbleCss === undefined) g.useCustomBubbleCss = false;
                if (g.hideMyIcons === undefined) g.hideMyIcons = false; // 이름 변경
                if (g.hideCharIcons === undefined) g.hideCharIcons = false; // 이름 변경
                if (g.fontSize === undefined) g.fontSize = 14;
            });
        };
        const showToast = (message) => {
            toastElement.textContent = message;
            toastElement.classList.add('show');
            setTimeout(() => toastElement.classList.remove('show'), 3000);
        };
        
                // 기존 switchScreen 함수를 아래 코드로 교체
        const switchScreen = (targetId) => {
            const phoneScreen = document.querySelector('.phone-screen');
            screens.forEach(screen => screen.classList.remove('active'));
            document.getElementById(targetId)?.classList.add('active');

            const overlays = document.querySelectorAll('.modal-overlay, .action-sheet-overlay, .settings-sidebar');
            overlays.forEach(o => o.classList.remove('visible', 'open'));
            
            const navBar = document.getElementById('bottom-nav-bar');
            const screensWithNav = ['chat-list-screen', 'feed-screen', 'schedule-screen'];
            
            if (screensWithNav.includes(targetId)) {
                navBar.style.display = 'flex';
                phoneScreen.classList.add('has-bottom-nav'); // 클래스 추가
                const navButtons = navBar.querySelectorAll('.nav-btn');
                navButtons.forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.target === targetId);
                });
            } else {
                navBar.style.display = 'none';
                phoneScreen.classList.remove('has-bottom-nav'); // 클래스 제거
            }
        };

        const pad = (num) => num.toString().padStart(2, '0');

        function createContextMenu(items, x, y) {
            removeContextMenu();
            const menu = document.createElement('div');
            menu.className = 'context-menu';
            menu.style.left = `${x}px`;
            menu.style.top = `${y}px`;
            items.forEach(item => {
                const menuItem = document.createElement('div');
                menuItem.className = 'context-menu-item';
                if (item.danger) menuItem.classList.add('danger');
                menuItem.textContent = item.label;
                menuItem.onclick = () => {
                    item.action();
                    removeContextMenu();
                };
                menu.appendChild(menuItem);
            });
            document.body.appendChild(menu);
            document.addEventListener('click', removeContextMenu, { once: true });
        }

        function removeContextMenu() {
            const menu = document.querySelector('.context-menu');
            if (menu) menu.remove();
        }

        function updateCustomBubbleStyle(chatId, css, enabled) {
            const styleId = `custom-bubble-style-for-${chatId}`;
            let styleElement = document.getElementById(styleId);

            if (enabled && css) {
                if (!styleElement) {
                    styleElement = document.createElement('style');
                    styleElement.id = styleId;
                    document.head.appendChild(styleElement);
                }
                const scopedCss = css.replace(/(\.message-bubble(?:\.sent|\.received)?)/g, `#chat-room-screen.chat-active-${chatId} $1`);
                styleElement.innerHTML = scopedCss;
            } else {
                if (styleElement) styleElement.remove();
            }
        }

        
        function applyGlobalCustomCSS() {
            if (!db.globalCustomCSS.enabled) {
                return;
            }
            const preset = db.globalCustomCSS.presets[db.globalCustomCSS.currentPreset];
            if (!preset || !preset.css) {
                return;
            }
            let styleElement = document.getElementById('global-custom-style');
            if (!styleElement) {
                styleElement = document.createElement('style');
                styleElement.id = 'global-custom-style';
                document.head.appendChild(styleElement);
            }
            styleElement.innerHTML = preset.css;
        }

        function removeGlobalCustomCSS() {
            const styleElement = document.getElementById('global-custom-style');
            if (styleElement) {
                styleElement.remove();
            }
        }

        function updateGlobalCustomCSS() {
            if (db.globalCustomCSS.enabled) {
                applyGlobalCustomCSS();
            } else {
                removeGlobalCustomCSS();
            }
        }

// --- START: 이 함수 전체를 아래 코드로 교체하세요 ---
function updateBubbleCssPreview(previewContainer, css, useDefault, theme, fontSize = 14) {
    previewContainer.innerHTML = '';

    const sentBubble = document.createElement('div');
    sentBubble.className = 'message-bubble sent';
    sentBubble.textContent = '이것은 내 말풍선입니다.';
    sentBubble.style.alignSelf = 'flex-end';
    
    const receivedBubble = document.createElement('div');
    receivedBubble.className = 'message-bubble received';
    receivedBubble.textContent = '이것은 상대방 말풍선입니다.';
    receivedBubble.style.alignSelf = 'flex-start';

    [sentBubble, receivedBubble].forEach(bubble => {
        bubble.style.maxWidth = '70%';
        bubble.style.padding = '8px 12px';
        bubble.style.wordWrap = 'break-word';
        bubble.style.lineHeight = '1.4';
        bubble.style.fontSize = `${fontSize}px`; // 폰트 크기 적용
        bubble.style.borderRadius = '18px';
    });

    sentBubble.style.borderBottomRightRadius = '5px';
    receivedBubble.style.borderBottomLeftRadius = '5px';

    if (useDefault || !css) {
        sentBubble.style.backgroundColor = theme.sent.bg;
        sentBubble.style.color = theme.sent.text;
        receivedBubble.style.backgroundColor = theme.received.bg;
        receivedBubble.style.color = theme.received.text;
    } else {
        const styleTag = document.createElement('style');
        const scopedCss = css.replace(/(\.message-bubble(?:\.sent|\.received)?)/g, `#${previewContainer.id} $1`);
        styleTag.textContent = scopedCss;
        previewContainer.appendChild(styleTag);
    }
    previewContainer.appendChild(receivedBubble);
    previewContainer.appendChild(sentBubble);
}
// --- END: 함수 교체 ---
function setupGitHubSync() {
    const usernameInput = document.getElementById('github-username');
    const repoInput = document.getElementById('github-repo');
    const patInput = document.getElementById('github-pat');
    const filenameInput = document.getElementById('github-filename');
    const saveBtn = document.getElementById('save-sync-settings-btn');
    const syncUpBtn = document.getElementById('sync-up-btn');
    const syncDownBtn = document.getElementById('sync-down-btn');
    
    const githubInfoDownloadBtn = document.getElementById('github-info-download-btn');
    const githubInfoUploadBtn = document.getElementById('github-info-upload-btn');
    const githubInfoUploadInput = document.getElementById('github-info-upload-input');
    const githubSyncToggle = document.getElementById('github-sync-toggle');
    const githubSyncContent = document.getElementById('github-sync-content');

    
    const savedSettings = JSON.parse(localStorage.getItem('gemini-chat-sync-settings'));
    if (savedSettings) {
        usernameInput.value = savedSettings.username || '';
        repoInput.value = savedSettings.repo || '';
        patInput.value = savedSettings.pat || '';
        filenameInput.value = savedSettings.filename || 'phone-chat-data.json';
        
        
        const includePatCheckbox = document.getElementById('include-pat-in-download');
        if (includePatCheckbox) {
            includePatCheckbox.checked = savedSettings.includePatInDownload !== false;
            console.log('🔧 DEBUG: PAT 포함 옵션 복원됨:', includePatCheckbox.checked);
        } else if (!IS_DEVELOPMENT_MODE) {
            console.log('🔧 DEBUG: PAT 포함 옵션 비활성화됨 (배포 모드)');
        }

        
        const mergeDataCheckbox = document.getElementById('merge-data-on-restore');
        if (mergeDataCheckbox) {
            mergeDataCheckbox.checked = savedSettings.mergeDataOnRestore !== false;
        }
        
        updateSyncButtonsState();
        console.log('GitHub 설정 불러오기 완료:', { 
            username: savedSettings.username, 
            repo: savedSettings.repo, 
            pat: savedSettings.pat ? '***' : '없음',
            includePatInDownload: savedSettings.includePatInDownload !== false
        });
    }

    
    function updateSyncButtonsState() {
        const settings = {
            username: usernameInput.value.trim(),
            repo: repoInput.value.trim(),
            pat: patInput.value.trim(),
        };
        if (settings.username && settings.repo && settings.pat) {
            syncUpBtn.disabled = false;
            syncDownBtn.disabled = false;
        } else {
            syncUpBtn.disabled = true;
            syncDownBtn.disabled = true;
        }
    }

    saveBtn.addEventListener('click', () => {
        const includePatCheckbox = document.getElementById('include-pat-in-download');
        const mergeDataCheckbox = document.getElementById('merge-data-on-restore');
        const settings = {
            username: usernameInput.value.trim(),
            repo: repoInput.value.trim(),
            pat: patInput.value.trim(),
            filename: filenameInput.value.trim() || 'phone-chat-data.json',
            includePatInDownload: includePatCheckbox ? includePatCheckbox.checked : !IS_DEVELOPMENT_MODE ? false : true,
            mergeDataOnRestore: mergeDataCheckbox ? mergeDataCheckbox.checked : true
        };
        localStorage.setItem('gemini-chat-sync-settings', JSON.stringify(settings));
        showToast('GitHub 동기화 설정이 저장되었습니다.');
        updateSyncButtonsState();
        console.log('GitHub 설정 저장 완료:', { ...settings, pat: settings.pat ? '***' : '없음' });
    });

    
    githubSyncToggle.addEventListener('click', () => {
        const isHidden = githubSyncContent.style.display === 'none';
        githubSyncContent.style.display = isHidden ? 'block' : 'none';
        
        
        const arrow = githubSyncToggle.querySelector('span');
        arrow.textContent = isHidden ? '▲' : '▼';
        
        console.log('GitHub 동기화 섹션 토글:', isHidden ? '펼침' : '접음');
    });



    
    if (IS_DEVELOPMENT_MODE && githubInfoDownloadBtn) {
        console.log('🔧 DEBUG: GitHub 정보 다운로드 기능 활성화됨 (개발 모드)');
        githubInfoDownloadBtn.addEventListener('click', () => {
            const settings = JSON.parse(localStorage.getItem('gemini-chat-sync-settings'));
            if (!settings || !settings.username || !settings.repo) {
                showToast('GitHub 설정을 먼저 저장해주세요.');
                return;
            }

            const includePatCheckbox = document.getElementById('include-pat-in-download');
            
            const includePat = includePatCheckbox ? includePatCheckbox.checked : !IS_DEVELOPMENT_MODE ? false : true;

            const githubInfo = {
                username: settings.username,
                repository: settings.repo,
                filename: settings.filename || 'phone-chat-data.json',
                lastUpdated: new Date().toISOString(),
                note: includePat ? '이 파일은 GitHub 동기화 설정 정보입니다. (개인용 - PAT 포함)' : '이 파일은 GitHub 동기화 설정 정보입니다. (배포용 - PAT 제외)'
            };

            if (includePat && settings.pat) {
                githubInfo.pat = settings.pat;
            }

            const blob = new Blob([JSON.stringify(githubInfo, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `github-sync-info-${settings.username}-${settings.repo}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            showToast(includePat ? 'GitHub 정보가 다운로드되었습니다. (PAT 포함)' : 'GitHub 정보가 다운로드되었습니다. (PAT 제외)');
        });
    } else if (!IS_DEVELOPMENT_MODE) {
        console.log('🔧 DEBUG: GitHub 정보 다운로드 기능 비활성화됨 (배포 모드)');
    }

    
    if (IS_DEVELOPMENT_MODE && githubInfoUploadBtn && githubInfoUploadInput) {
        console.log('🔧 DEBUG: GitHub 정보 업로드 기능 활성화됨 (개발 모드)');
        githubInfoUploadBtn.addEventListener('click', () => {
            githubInfoUploadInput.click();
        });

        githubInfoUploadInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            if (!file.name.endsWith('.json')) {
                showToast('❌ JSON 파일만 업로드 가능합니다.');
                return;
            }

            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const githubSettings = JSON.parse(event.target.result);
                    
                    if (!githubSettings.username || !githubSettings.repository) {
                        showToast('❌ 올바른 GitHub 설정 파일이 아닙니다. (username, repository 필수)');
                        return;
                    }

                    
                    usernameInput.value = githubSettings.username || '';
                    repoInput.value = githubSettings.repository || '';
                    patInput.value = githubSettings.pat || '';
                    filenameInput.value = githubSettings.filename || 'phone-chat-data.json';

                    
                    const includePatCheckbox = document.getElementById('include-pat-in-download');
                    if (includePatCheckbox) {
                        includePatCheckbox.checked = !!githubSettings.pat;
                    }

                    
                    const settings = {
                        username: githubSettings.username,
                        repo: githubSettings.repository,
                        pat: githubSettings.pat || '',
                        filename: githubSettings.filename || 'phone-chat-data.json',
                        includePatInDownload: !!githubSettings.pat
                    };
                    localStorage.setItem('gemini-chat-sync-settings', JSON.stringify(settings));
                    
                    
                    updateSyncButtonsState();
                    
                    showToast('✅ GitHub 설정이 성공적으로 복원되었습니다!');

                } catch (error) {
                    showToast('❌ 파일을 읽는 중 오류가 발생했습니다: ' + error.message);
                }
            };

            reader.onerror = () => {
                showToast('❌ 파일을 읽는 중 오류가 발생했습니다.');
            };

            reader.readAsText(file);
        });
    } else if (!IS_DEVELOPMENT_MODE) {
        console.log('🔧 DEBUG: GitHub 정보 업로드 기능 비활성화됨 (배포 모드)');
    }

    
    syncUpBtn.addEventListener('click', syncUp);
    syncDownBtn.addEventListener('click', syncDown);
}


function deepMerge(existing, incoming) {
    if (incoming === null || incoming === undefined) {
        return existing;
    }
    
    if (existing === null || existing === undefined) {
        return incoming;
    }
    
    
    if (Array.isArray(incoming)) {
        if (Array.isArray(existing)) {
            return mergeArrays(existing, incoming);
        } else {
            return incoming;
        }
    }
    
    
    if (typeof incoming !== 'object') {
        if (existing !== null && existing !== undefined) {
            return existing; 
        }
        return incoming;
    }
    
    
    const result = { ...existing };
    
    for (const key in incoming) {
        if (incoming.hasOwnProperty(key)) {
            if (existing && existing.hasOwnProperty(key)) {
                result[key] = deepMerge(existing[key], incoming[key]);
            } else {
                result[key] = incoming[key];
            }
        }
    }
    
    return result;
}


function mergeArrays(existingArray, incomingArray) {
    const result = [...existingArray];
    const existingIds = new Set();
    
    
    existingArray.forEach((item, index) => {
        const id = item.id || item.name || item.timestamp || item.chatId || index;
        existingIds.add(id);
    });
    
    
    let addedCount = 0;
    incomingArray.forEach((item, index) => {
        const id = item.id || item.name || item.timestamp || item.chatId || index;
        
        if (!existingIds.has(id)) {
            result.push(item);
            existingIds.add(id);
            addedCount++;
        }
    });
    
    if (addedCount > 0) {
        console.log(`배열 병합 완료: ${addedCount}개 항목 추가 (${existingArray.length} → ${result.length})`);
    }
    
    return result;
}


async function syncUp() {
    if (!confirm('현재 기기의 데이터를 GitHub에 올려 다른 기기에서 받을 수 있도록 합니다. 진행하시겠습니까?')) return;

    const settings = JSON.parse(localStorage.getItem('gemini-chat-sync-settings'));
    if (!settings) return showToast('동기화 설정을 먼저 저장해주세요.');

    const { username, repo, pat, filename } = settings;
    const apiUrl = `https://api.github.com/repos/${username}/${repo}/contents/${filename}`;
    
    const localDataString = localStorage.getItem('gemini-chat-app-db');
    if (!localDataString) return showToast('백업할 데이터가 없습니다.');
    
    
    let dataToUpload = JSON.parse(localDataString);
    if (dataToUpload.apiSettings) {
        delete dataToUpload.apiSettings;
    }
    
    const cleanDataString = JSON.stringify(dataToUpload);
    const contentBase64 = btoa(unescape(encodeURIComponent(cleanDataString)));

    showToast('데이터 업로드 중...');

    try {
        
        let fileSha = null;
        try {
            const getFileResponse = await fetch(apiUrl, {
                headers: { 'Authorization': `token ${pat}` }
            });
            if (getFileResponse.ok) {
                const fileData = await getFileResponse.json();
                fileSha = fileData.sha;
            }
        } catch (e) {  }

        
        const payload = {
            message: `Sync data from Gemini Chat on ${new Date().toISOString()}`,
            content: contentBase64,
            sha: fileSha 
        };

        const response = await fetch(apiUrl, {
            method: 'PUT',
            headers: {
                'Authorization': `token ${pat}`,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(payload)
        });

        if (!response.ok) {
            const errorData = await response.json();
            const errorMessage = errorData.message ? `${errorData.message} (GitHub)` : 'Unknown error';
            throw new Error(errorMessage);
        }

        showToast('✅ 데이터 업로드 성공!');
    } catch (error) {
        console.error('Sync Up Error:', error);
        showToast(`❌ 업로드 실패: ${error.message}`);
    }
}
async function syncDown() {
    const settings = JSON.parse(localStorage.getItem('gemini-chat-sync-settings'));
    if (!settings) return showToast('동기화 설정을 먼저 저장해주세요.');
    
    
    const mergeCheckbox = document.getElementById('merge-data-on-restore');
    const useMergeMode = mergeCheckbox ? mergeCheckbox.checked : true;
    const modeText = useMergeMode ? '병합 (기존 데이터 보존)' : '완전 덮어쓰기 (기존 데이터 삭제)';
    
    console.log('데이터 복원 모드:', useMergeMode ? 'MERGE' : 'REPLACE');
    
    if (!confirm(`GitHub의 데이터를 현재 기기에 복원합니다.\n\n모드: ${modeText}\n\n${useMergeMode ? '기존 데이터와 병합되어 데이터 손실이 없습니다.' : '현재 모든 데이터가 삭제됩니다! (API 설정은 유지)'}\n\n진행하시겠습니까?`)) return;
    
    const { username, repo, pat, filename } = settings;
    const apiUrl = `https://api.github.com/repos/${username}/${repo}/contents/${filename}`;

    showToast(`데이터 다운로드 중... (${useMergeMode ? '병합 모드' : '덮어쓰기 모드'})`);

    try {
        
        const localDbString = localStorage.getItem('gemini-chat-app-db');
        const localDb = localDbString ? JSON.parse(localDbString) : {};
        const localApiSettings = localDb.apiSettings;
        
        
        const backupKey = 'gemini-chat-app-db-emergency-backup';
        localStorage.setItem(backupKey, localDbString || '{}');

        
        const response = await fetch(apiUrl, {
            headers: { 'Authorization': `token ${pat}` }
        });

        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.message || 'File not found');
        }

        const data = await response.json();
        const contentBase64 = data.content;
        
        
        let downloadedJsonData, downloadedDb;
        
        try {
            downloadedJsonData = decodeURIComponent(escape(atob(contentBase64)));
            downloadedDb = JSON.parse(downloadedJsonData);
            
            if (!downloadedDb || typeof downloadedDb !== 'object') {
                throw new Error('다운로드한 데이터가 올바른 객체 형식이 아닙니다.');
            }
            
        } catch (parseError) {
            throw new Error(`다운로드한 데이터가 손상되었습니다: ${parseError.message}`);
        }

        
        let finalDb;
        if (useMergeMode) {
            finalDb = deepMerge(localDb, downloadedDb);
        } else {
            finalDb = downloadedDb;
        }

        
        if (localApiSettings) {
            finalDb.apiSettings = localApiSettings;
        }

        
        try {
            const finalDbString = JSON.stringify(finalDb);
            
            if (!finalDbString || finalDbString === '{}' || finalDbString === 'null') {
                throw new Error('최종 데이터가 비어있거나 유효하지 않습니다.');
            }
            
            localStorage.setItem('gemini-chat-app-db', finalDbString);
            
            const savedData = localStorage.getItem('gemini-chat-app-db');
            if (!savedData) {
                throw new Error('데이터 저장 후 검증 실패 - localStorage에 저장되지 않음');
            }
            
            
            localStorage.removeItem(backupKey);
            
            showToast(`✅ 데이터 복원 성공! (${useMergeMode ? '병합 완료' : '덮어쓰기 완료'}) 앱을 새로고침합니다.`);
            
            setTimeout(() => {
                location.reload();
            }, 1500);
            
        } catch (saveError) {
            throw new Error(`데이터 저장 중 오류가 발생했습니다: ${saveError.message}`);
        }

    } catch (error) {
        console.error('Sync Down Error:', error);
        
        
        const backupKey = 'gemini-chat-app-db-emergency-backup';
        const emergencyBackup = localStorage.getItem(backupKey);
        
        if (emergencyBackup) {
            try {
                localStorage.setItem('gemini-chat-app-db', emergencyBackup);
                localStorage.removeItem(backupKey);
                showToast(`❌ 복원 실패했지만 기존 데이터는 안전하게 보호되었습니다.\n오류: ${error.message}`);
            } catch (restoreError) {
                showToast(`❌❌ 심각한 오류: 데이터 복원과 백업 복구 모두 실패했습니다!\n원본 오류: ${error.message}\n복구 오류: ${restoreError.message}`);
            }
        } else {
            showToast(`❌ 다운로드 실패: ${error.message}`);
        }
    }
}

// START: 추가할 새 함수들

function applyGlobalUISettings() {
    const phoneScreen = document.querySelector('.phone-screen');
    phoneScreen.classList.toggle('hide-user-icons', !!db.globalSettings.hideUserIcons);
    phoneScreen.classList.toggle('hide-character-icons', !!db.globalSettings.hideCharacterIcons);
}

function setupSettingsScreen() {
    const aiSystemToggle = document.getElementById('ai-can-use-system-toggle');
    const hideUserIconsToggle = document.getElementById('hide-user-icons-toggle');
    const hideCharIconsToggle = document.getElementById('hide-character-icons-toggle');

    // 설정 값 불러와서 토글에 반영
    aiSystemToggle.checked = !!db.globalSettings.aiCanUseSystem;
    hideUserIconsToggle.checked = !!db.globalSettings.hideUserIcons;
    hideCharIconsToggle.checked = !!db.globalSettings.hideCharacterIcons;

    // 이벤트 리스너 설정
    aiSystemToggle.addEventListener('change', () => {
        db.globalSettings.aiCanUseSystem = aiSystemToggle.checked;
        saveData();
        showToast(`AI 시스템 메시지 사용이 ${aiSystemToggle.checked ? '활성화' : '비활성화'}되었습니다.`);
    });

    hideUserIconsToggle.addEventListener('change', () => {
        db.globalSettings.hideUserIcons = hideUserIconsToggle.checked;
        saveData();
        applyGlobalUISettings();
        showToast(`유저 아이콘 숨기기가 ${hideUserIconsToggle.checked ? '활성화' : '비활성화'}되었습니다.`);
    });

    hideCharIconsToggle.addEventListener('change', () => {
        db.globalSettings.hideCharacterIcons = hideCharIconsToggle.checked;
        saveData();
        applyGlobalUISettings();
        showToast(`캐릭터 아이콘 숨기기가 ${hideCharIconsToggle.checked ? '활성화' : '비활성화'}되었습니다.`);
    });
}
// END: 추가할 새 함수들

// 기존 applyPerChatUISettings 함수를 찾아 아래 코드로 전체 교체하세요.

function applyPerChatUISettings() {
    const chat = (currentChatType === 'private') 
        ? db.characters.find(c => c.id === currentChatId) 
        : db.groups.find(g => g.id === currentChatId);

    if (!chat) return;

    // 클래스 이름 변경
    chatRoomScreen.classList.toggle('hide-my-icons', !!chat.hideMyIcons);
    chatRoomScreen.classList.toggle('hide-char-icons', !!chat.hideCharIcons);

    // 폰트 크기 적용 (이 부분이 중요합니다)
    const fontSize = chat.fontSize || 14;
    const messageArea = document.getElementById('message-area');
    if (messageArea) {
        messageArea.style.setProperty('--bubble-font-size', `${fontSize}px`);
    }
}

        const init = () => {
            loadData();
            document.body.addEventListener('click', (e) => {
                if (e.target.closest('.context-menu')) {
                    e.stopPropagation();
                    return;
                }
                removeContextMenu();

                const backBtn = e.target.closest('.back-btn');
                if (backBtn) {
                    e.preventDefault();
                    switchScreen(backBtn.getAttribute('data-target'));
                    const currentScreen = e.target.closest('.screen');
                    if (currentScreen && currentScreen.id === 'chat-room-screen') {
                        currentChatId = null;
                        currentChatType = null;
                    }
                }

                
                const openOverlay = document.querySelector('.modal-overlay.visible, .action-sheet-overlay.visible');
                if (openOverlay && e.target === openOverlay) {
                    openOverlay.classList.remove('visible');
                }
            });

            
            document.body.addEventListener('click', e => {
                const navLink = e.target.closest('.app-icon[data-target]');
                if (navLink) {
                    e.preventDefault();
                    switchScreen(navLink.getAttribute('data-target'));
                }
            });

            updateClock();
            setInterval(updateClock, 30000);
            
            const currentPresetKey = db.globalFontPresets.currentPreset;
            const currentPreset = db.globalFontPresets.presets[currentPresetKey];
            console.log('앱 초기화 - 폰트 적용:', { 
                currentPresetKey: currentPresetKey, 
                currentPreset: currentPreset,
                allPresets: Object.keys(db.globalFontPresets.presets)
            });
            
            if (currentPreset && currentPreset.url) {
                applyGlobalFont(currentPreset.url);
                console.log('앱 초기화 시 폰트 적용:', currentPreset.name, currentPreset.url);
            } else {
                applyGlobalFont(''); 
                console.log('기본 폰트로 초기화 (현재 프리셋:', currentPresetKey, ')');
            }
            updateGlobalCustomCSS(); 
            applyGlobalUISettings(); 
            setupHomeScreen();
            setupChatListScreen();
            setupAddCharModal();
            setupChatRoom();
            setupChatSettings();
            setupApiSettingsApp();
            setupWallpaperApp();
            setupStickerSystem();
            setupVoiceMessageSystem();
            setupPhotoVideoSystem();
            setupWalletSystem();
            setupGiftSystem();
            setupTimeSkipSystem();
            setupWorldBookApp();
            setupFontSettingsApp();
            setupSettingsScreen(); 
            setupGroupChatSystem();
            setupCustomizeApp();
            setupTutorialApp();
			setupGitHubSync();
            setupBottomNav();
            setupFeedScreen();
        };

        function updateClock() {
            const now = new Date();
            const timeDisplay = document.getElementById('time-display');
            const dateDisplay = document.getElementById('date-display');
            if (timeDisplay) timeDisplay.textContent = `${pad(now.getHours())}:${pad(now.getMinutes())}`;
            if (dateDisplay) dateDisplay.textContent = `${now.getFullYear()}년 ${pad(now.getMonth() + 1)}월 ${pad(now.getDate())}일`;
        }

        
        function setupHomeScreen() {
            const getIcon = (id) => db.customIcons[id] || defaultIcons[id].url;
            const homeScreenHTML = `
            <div class="time-widget"><div class="time" id="time-display"></div><div class="date" id="date-display"></div></div>
            <div class="app-grid">
                <a href="#" class="app-icon" data-target="chat-list-screen"><img src="${getIcon('chat-list-screen')}" alt="404" class="icon-img"><span class="app-name">${defaultIcons['chat-list-screen'].name}</span></a>
                <a href="#" class="app-icon" data-target="api-settings-screen"><img src="${getIcon('api-settings-screen')}" alt="API" class="icon-img"><span class="app-name">${defaultIcons['api-settings-screen'].name}</span></a>
                <a href="#" class="app-icon" data-target="wallpaper-font-screen"><img src="${getIcon('wallpaper-screen')}" alt="커스텀" class="icon-img"><span class="app-name">${defaultIcons['wallpaper-screen'].name}</span></a>
                <a href="#" class="app-icon" data-target="world-book-screen"><img src="${getIcon('world-book-screen')}" alt="세계관" class="icon-img"><span class="app-name">${defaultIcons['world-book-screen'].name}</span></a>
                <a href="#" class="app-icon" data-target="customize-screen"><img src="${getIcon('customize-screen')}" alt="홈 화면" class="icon-img"><span class="app-name">${defaultIcons['customize-screen'].name}</span></a>
                <a href="#" class="app-icon" data-target="tutorial-screen"><img src="${getIcon('tutorial-screen')}" alt="튜토리얼" class="icon-img"><span class="app-name">${defaultIcons['tutorial-screen'].name}</span></a>
            </div>
            <div class="dock">
                <a href="#" class="app-icon" id="day-mode-btn"><img src="${getIcon('day-mode-btn')}" alt="주간" class="icon-img"></a>
                <a href="#" class="app-icon" id="night-mode-btn"><img src="${getIcon('night-mode-btn')}" alt="야간" class="icon-img"></a>
                <a href="#" class="app-icon" data-target="settings-screen"><img src="${getIcon('font-settings-screen')}" alt="설정" class="icon-img"><span class="app-name"></span></a>
            </div>`;
            homeScreen.innerHTML = homeScreenHTML;
            updateClock();
            applyWallpaper(db.wallpaper);
            applyHomeScreenMode(db.homeScreenMode);
            document.getElementById('day-mode-btn')?.addEventListener('click', (e) => { e.preventDefault(); applyHomeScreenMode('day'); });
            document.getElementById('night-mode-btn')?.addEventListener('click', (e) => { e.preventDefault(); applyHomeScreenMode('night'); });
            document.querySelector('[data-target="wallpaper-font-screen"]').addEventListener('click', () => {
    // wallpaper-font-screen으로 전환될 때 특별히 실행할 로직이 있다면 여기에 추가
});
            document.querySelector('[data-target="world-book-screen"]').addEventListener('click', renderWorldBookList);
            document.querySelector('[data-target="customize-screen"]').addEventListener('click', renderCustomizeForm);
            document.querySelector('[data-target="tutorial-screen"]').addEventListener('click', renderTutorialContent);
        }

        function applyWallpaper(url) { homeScreen.style.backgroundImage = `url(${url})`; }

        function applyHomeScreenMode(mode) {
            if (mode === 'day') { homeScreen.classList.add('day-mode'); }
            else { homeScreen.classList.remove('day-mode'); }
            db.homeScreenMode = mode;
            saveData();
        }

        function setupCustomizeApp() {
            customizeForm.addEventListener('input', e => {
                if (e.target.matches('input[type="url"]')) {
                    const iconId = e.target.dataset.id;
                    const newUrl = e.target.value.trim();
                    const previewImg = document.getElementById(`icon-preview-${iconId}`);
                    if (newUrl) {
                        db.customIcons[iconId] = newUrl;
                        previewImg.src = newUrl;
                        saveData();
                        setupHomeScreen();
                    }
                }
            });
            customizeForm.addEventListener('click', e => {
                if (e.target.matches('.reset-icon-btn')) {
                    const iconId = e.target.dataset.id;
                    delete db.customIcons[iconId];
                    saveData();
                    renderCustomizeForm();
                    setupHomeScreen();
                    showToast('아이콘이 초기화되었습니다');
                }
            });

            
            customizeForm.addEventListener('change', e => {
                
                if (e.target.matches('#global-css-toggle')) {
                    db.globalCustomCSS.enabled = e.target.checked;
                    updateGlobalCustomCSS();
                    saveData();
                    showToast(e.target.checked ? '전역 커스텀 CSS가 활성화되었습니다' : '전역 커스텀 CSS가 비활성화되었습니다');
                }
                
                
                if (e.target.matches('#css-preset-select')) {
                    const newPreset = e.target.value;
                    db.globalCustomCSS.currentPreset = newPreset;
                    
                    
                    const cssInput = document.getElementById('css-input');
                    if (cssInput) {
                        cssInput.value = db.globalCustomCSS.presets[newPreset].css;
                    }
                    
                    
                    if (db.globalCustomCSS.enabled) {
                        updateGlobalCustomCSS();
                    }
                    saveData();
                    showToast(`"${db.globalCustomCSS.presets[newPreset].name}" 프리셋이 선택되었습니다`);
                }
            });

            customizeForm.addEventListener('click', e => {
                
                if (e.target.matches('#save-css-btn')) {
                    console.log('CSS 저장 버튼 클릭');
                    const cssInput = document.getElementById('css-input');
                    const currentPreset = db.globalCustomCSS.currentPreset;
                    
                    if (cssInput && cssInput.value.trim()) {
                        db.globalCustomCSS.presets[currentPreset].css = cssInput.value.trim();
                        saveData();
                        
                        if (db.globalCustomCSS.enabled) {
                            updateGlobalCustomCSS();
                        }
                        showToast('CSS가 저장되었습니다');
                    } else {
                        showToast('CSS 코드를 입력해주세요');
                    }
                }
                
                
                if (e.target.matches('#new-preset-btn')) {
                    console.log('새 프리셋 버튼 클릭');
                    const presetName = prompt('새 프리셋의 이름을 입력하세요:');
                    if (presetName && presetName.trim()) {
                        const presetKey = 'preset-' + Date.now();
                        db.globalCustomCSS.presets[presetKey] = {
                            name: presetName.trim(),
                            css: '',
                            description: '사용자 정의 프리셋'
                        };
                        db.globalCustomCSS.currentPreset = presetKey;
                        saveData();
                        renderCustomizeForm();
                        showToast(`"${presetName}" 프리셋이 생성되었습니다`);
                    }
                }
                
                
                if (e.target.matches('#delete-preset-btn')) {
                    console.log('프리셋 삭제 버튼 클릭');
                    const currentPreset = db.globalCustomCSS.currentPreset;
                    if (currentPreset !== 'default') {
                        const presetName = db.globalCustomCSS.presets[currentPreset].name;
                        if (confirm(`"${presetName}" 프리셋을 정말 삭제하시겠습니까?`)) {
                            delete db.globalCustomCSS.presets[currentPreset];
                            db.globalCustomCSS.currentPreset = 'default';
                            saveData();
                            renderCustomizeForm();
                            updateGlobalCustomCSS();
                            showToast('프리셋이 삭제되었습니다');
                        }
                    }
                }
            });
        }

        function renderCustomizeForm() {
            customizeForm.innerHTML = '';
            
            
            const iconSectionHTML = `
                <div class="customize-section">
                    <h3 class="section-title">홈 화면 아이콘 커스터마이징</h3>
                    <div class="section-content">
                        ${Object.entries(defaultIcons).map(([id, { name, url }]) => {
                            const currentIcon = db.customIcons[id] || url;
                            return `
                            <div class="icon-custom-item">
                                <img src="${currentIcon}" alt="${name}" class="icon-preview" id="icon-preview-${id}">
                                <div class="icon-details">
                                    <p>${name || '모드 전환'}</p>
                                    <input type="url" class="form-group" placeholder="새 아이콘 URL 붙여넣기" value="${db.customIcons[id] || ''}" data-id="${id}">
                                </div>
                                <button type="button" class="reset-icon-btn" data-id="${id}">초기화</button>
                            </div>`;
                        }).join('')}
                    </div>
                </div>
            `;
            customizeForm.insertAdjacentHTML('beforeend', iconSectionHTML);
            
            
            const globalCSSSectionHTML = `
                <div class="customize-section">
                    <h3 class="section-title">전역 커스텀 CSS</h3>
                    <div class="section-content">
                        <div class="css-toggle-section">
                            <label class="toggle-label">
                                <input type="checkbox" id="global-css-toggle" ${db.globalCustomCSS.enabled ? 'checked' : ''}>
                                <span class="toggle-text">전역 커스텀 CSS 사용</span>
                            </label>
                        </div>
                        
                        <div class="css-preset-section">
                            <label for="css-preset-select" class="form-label">CSS 프리셋 선택:</label>
                            <select id="css-preset-select" class="form-select">
                                ${Object.entries(db.globalCustomCSS.presets).map(([key, preset]) => 
                                    `<option value="${key}" ${key === db.globalCustomCSS.currentPreset ? 'selected' : ''}>${preset.name}</option>`
                                ).join('')}
                            </select>
                        </div>
                        
                        <div class="css-input-section">
                            <label for="css-input" class="form-label">CSS 코드:</label>
                            <textarea id="css-input" class="form-textarea" placeholder="CSS 코드를 입력하세요." rows="8">${db.globalCustomCSS.presets[db.globalCustomCSS.currentPreset].css}</textarea>
                        </div>
                        
                        <div class="css-actions">
                            <button type="button" id="save-css-btn" class="btn btn-primary">저장</button>
                            <button type="button" id="new-preset-btn" class="btn btn-secondary">새 프리셋</button>
                            <button type="button" id="delete-preset-btn" class="btn btn-danger" ${db.globalCustomCSS.currentPreset === 'default' ? 'disabled' : ''}>프리셋 삭제</button>
                        </div>
                    </div>
                </div>
            `;
            customizeForm.insertAdjacentHTML('beforeend', globalCSSSectionHTML);
        }

        function setupTutorialApp() {
            tutorialContentArea.addEventListener('click', (e) => {
                const header = e.target.closest('.tutorial-header');
                if (header) { header.parentElement.classList.toggle('open'); }
            });
        }

        function renderTutorialContent() {
            const tutorials = [
                { title: '시작하며', imageUrls: ['https://i.postimg.cc/7PgyMG9S/image.jpg'] },
                { title: '소프트웨어 소개', imageUrls: [ 'https://i.postimg.cc/VvsJRh6q/IMG-20250713-162647.jpg', 'https://i.postimg.cc/8P5FfxxD/IMG-20250713-162702.jpg', 'https://i.postimg.cc/3r94R3Sn/IMG-20250713-162712.jpg' ] },
                { title: '404', imageUrls: [ 'https://i.postimg.cc/x8scFPJW/IMG-20250713-162756.jpg', 'https://i.postimg.cc/pX6mfqtj/IMG-20250713-162809.jpg', 'https://i.postimg.cc/YScjV00q/IMG-20250713-162819.jpg', 'https://i.postimg.cc/13VfJw9j/IMG-20250713-162828.jpg' ] },
                { title: '404-그룹채팅', imageUrls: ['https://i.postimg.cc/X7LSmRTJ/404.jpg'] }
            ];
            tutorialContentArea.innerHTML = '';
            tutorials.forEach(tutorial => {
                const item = document.createElement('div');
                item.className = 'tutorial-item';
                const imagesHtml = tutorial.imageUrls.map(url => `<img src="${url}" alt="${tutorial.title} 튜토리얼 이미지">`).join('');
                item.innerHTML = `<div class="tutorial-header">${tutorial.title}</div><div class="tutorial-content">${imagesHtml}</div>`;
                tutorialContentArea.appendChild(item);
            });
        }

        function autoResize() {
            textarea.style.height = 'auto';
            textarea.style.height = textarea.scrollHeight + 'px';
        }

        textarea.addEventListener('input', autoResize);
                
        function setupChatListScreen() {
            renderChatList();
            addChatBtn.addEventListener('click', () => {
                addCharModal.classList.add('visible');
                addCharForm.reset();
            });
            chatListContainer.addEventListener('click', (e) => {
                const chatItem = e.target.closest('.chat-item');
                if (chatItem) {
                    currentChatId = chatItem.dataset.id;
                    currentChatType = chatItem.dataset.type;
                    openChatRoom(currentChatId, currentChatType);
                }
            });
            chatListContainer.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                const chatItem = e.target.closest('.chat-item');
                if (!chatItem) return;
                handleChatListLongPress(chatItem.dataset.id, chatItem.dataset.type, e.clientX, e.clientY);
            });
            chatListContainer.addEventListener('touchstart', (e) => {
                const chatItem = e.target.closest('.chat-item');
                if (!chatItem) return;
                longPressTimer = setTimeout(() => {
                    const touch = e.touches[0];
                    handleChatListLongPress(chatItem.dataset.id, chatItem.dataset.type, touch.clientX, touch.clientY);
                }, 400);
            });
            chatListContainer.addEventListener('touchend', () => clearTimeout(longPressTimer));
            chatListContainer.addEventListener('touchmove', () => clearTimeout(longPressTimer));
        }

        function handleChatListLongPress(chatId, chatType, x, y) {
            clearTimeout(longPressTimer);
            const chatItem = (chatType === 'private') ? db.characters.find(c => c.id === chatId) : db.groups.find(g => g.id === chatId);
            if (!chatItem) return;
            const itemName = chatType === 'private' ? chatItem.remarkName : chatItem.name;
            const menuItems = [{
                label: chatItem.isPinned ? '상단 고정 해제' : '상단 고정',
                action: () => {
                    chatItem.isPinned = !chatItem.isPinned;
                    saveData();
                    renderChatList();
                }
            }, {
                label: '채팅 삭제',
                danger: true,
                action: () => {
                    if (confirm(`“${itemName}”님과의 채팅 기록을 정말 삭제하시겠습니까? 이 작업은 되돌릴 수 없습니다.`)) {
                        if (chatType === 'private') { db.characters = db.characters.filter(c => c.id !== chatId); }
                        else { db.groups = db.groups.filter(g => g.id !== chatId); }
                        saveData();
                        renderChatList();
                        showToast('채팅이 삭제되었습니다');
                    }
                }
            }];
            createContextMenu(menuItems, x, y);
        }

        
function renderChatList() {
    chatListContainer.innerHTML = '';
    const allChats = [ ...db.characters.map(c => ({ ...c, type: 'private' })), ...db.groups.map(g => ({ ...g, type: 'group' })) ];
    noChatsPlaceholder.style.display = (db.characters.length + db.groups.length) === 0 ? 'block' : 'none';
    const sortedChats = allChats.sort((a, b) => {
        if (a.isPinned !== b.isPinned) return a.isPinned ? -1 : 1;
        const lastMsgTimeA = a.history && a.history.length > 0 ? a.history[a.history.length - 1].timestamp : 0;
        const lastMsgTimeB = b.history && b.history.length > 0 ? b.history[b.history.length - 1].timestamp : 0;
        return lastMsgTimeB - lastMsgTimeA;
    });
    sortedChats.forEach(chat => {
        let lastMessageText = '채팅을 시작해보세요...';
        let lastMessageTime = ''; 

        if (chat.history && chat.history.length > 0) {
            const lastMsgObj = chat.history[chat.history.length - 1];
            const date = new Date(lastMsgObj.timestamp);
            lastMessageTime = `${pad(date.getHours())}:${pad(date.getMinutes())}`; 

            const invisibleRegex = /\[(?:.+?)님이 (?:.+?)님의 송금을 (?:수령|반환)했습니다\]|\[(?:.+?)님이 현재 상태를 업데이트:.*?\]|\[(?:.+?)님이 선물을 수령했습니다\]|\[system:.*?\]|\[(?:.+?)님이 (?:.+?)님을 그룹에 초대했습니다\]|\[(?:.+?)님이 그룹 이름을 .*?(?:으)로 변경했습니다\]|\[system-display:.*?\]/;
            const visibleHistory = chat.history.filter(msg => !invisibleRegex.test(msg.content));
            if (visibleHistory.length > 0) {
                const lastMsg = visibleHistory[visibleHistory.length - 1];
                const urlRegex = /^(https?:\/\/[^\s]+\.(?:jpg|jpeg|png|gif|webp|bmp|svg)|data:image\/[a-z]+;base64,)/i;
                const imageRecogRegex = /\[(?:.+?)님의 이미지:\]/;
                const voiceRegex = /\[.*?님의 음성:.*?\]/;
                const photoVideoRegex = /\[.*?님의 사진\/영상:.*?\]/;
                const transferRegex = /\[.*?님의 송금:.*?원.*?\]|\[.*?님에게 송금:.*?원.*?\]|\[.*?님이 .*?님에게 송금:.*?원.*?\]/;
                const stickerRegex = /\[.*?님의 이모티콘:.*?\]|\[.*?님의 이모티콘:.*?\]/;
                const giftRegex = /\[.*?님이 보낸 선물:.*?\]|\[.*?님이 .*?님에게 보낸 선물:.*?\]/;

                if (giftRegex.test(lastMsg.content)) { lastMessageText = '[선물]'; }
                else if (stickerRegex.test(lastMsg.content)) { lastMessageText = '[이모티콘]'; }
                else if (voiceRegex.test(lastMsg.content)) { lastMessageText = '[음성]'; }
                else if (photoVideoRegex.test(lastMsg.content)) { lastMessageText = '[사진/영상]'; }
                else if (transferRegex.test(lastMsg.content)) { lastMessageText = '[송금]'; }
                else if (imageRecogRegex.test(lastMsg.content) || (lastMsg.parts && lastMsg.parts.some(p => p.type === 'image'))) { lastMessageText = '[사진]'; }
                else {
                    const textMatch = lastMsg.content.match(/\[.*?님의 메시지:([\s\S]+)\]/);
                    let text = textMatch ? textMatch[1].trim() : lastMsg.content.trim();
                    lastMessageText = urlRegex.test(text) ? '[사진]' : text;
                }
            } else {
                const lastEverMsg = chat.history[chat.history.length - 1];
                const inviteRegex = /\[(.*?)님이 (.*?)님을 그룹에 초대했습니다\]/;
                const renameRegex = /\[.*?님이 그룹 이름을 .*?(으)로 변경했습니다\]/;
                const timeSkipRegex = /\[system-display:([\s\S]+?)\]/;
                const timeSkipMatch = lastEverMsg.content.match(timeSkipRegex);

                if (timeSkipMatch) { lastMessageText = timeSkipMatch[1]; }
                else if (inviteRegex.test(lastEverMsg.content)) { lastMessageText = '새 멤버가 그룹에 참여했습니다'; }
                else if (renameRegex.test(lastEverMsg.content)) { lastMessageText = '그룹 이름이 변경되었습니다'; }
            }
        }
        const li = document.createElement('li');
        li.className = 'list-item chat-item';
        if (chat.isPinned) li.classList.add('pinned');
        li.dataset.id = chat.id;
        li.dataset.type = chat.type;
        const avatarClass = chat.type === 'group' ? 'group-avatar' : '';
        const itemName = chat.type === 'private' ? chat.remarkName : chat.name;
        const pinBadgeHTML = chat.isPinned ? '<span class="pin-badge">고정됨</span>' : '';
        const unreadBadgeHTML = chat.unreadCount > 0 ? `<span class="unread-badge">${chat.unreadCount}</span>` : '';
        const timeHTML = lastMessageTime ? `<span class="item-time">${lastMessageTime}</span>` : ''; 
        
        
        li.innerHTML = `
        <img src="${chat.avatar}" alt="${itemName}" class="chat-avatar ${avatarClass}">
        <div class="item-details">
            <div class="item-details-row"><div class="item-name">${itemName}</div>${timeHTML}</div>
            <div class="item-preview-wrapper"><div class="item-preview">${lastMessageText}</div>${unreadBadgeHTML}${pinBadgeHTML}</div>
        </div>`;
        chatListContainer.appendChild(li);
    });
}

        function setupAddCharModal() {
            addCharForm.addEventListener('submit', (e) => {
                e.preventDefault();
                const newChar = { id: `char_${Date.now()}`, realName: document.getElementById('char-real-name').value, remarkName: document.getElementById('char-remark-name').value, persona: '', avatar: 'https://i.postimg.cc/Y96LPskq/o-o-2.jpg', myName: document.getElementById('my-name-for-char').value, myPersona: '', myAvatar: 'https://i.postimg.cc/GtbTnxhP/o-o-1.jpg', theme: 'white_pink', maxMemory: 100, chatBg: '', history: [], isPinned: false, status: '온라인', worldBookIds: [], useCustomBubbleCss: false, customBubbleCss: '' };
                db.characters.push(newChar);
                saveData();
                renderChatList();
                addCharModal.classList.remove('visible');
                showToast(`캐릭터 “${newChar.remarkName}” 생성 성공!`);
            });
        }

        // --- START: 이 함수 전체를 아래 코드로 교체하세요 ---

function setupChatRoom() {
    sendMessageBtn.addEventListener('click', sendMessage);
    sendMessageBtn.addEventListener('touchend', (e) => {
        e.preventDefault();
        sendMessage();
        setTimeout(() => { messageInput.focus(); }, 50);
    });
    messageInput.addEventListener('keypress', (e) => { 
        if (e.key === 'Enter' && !e.shiftKey && !isGenerating) {
            e.preventDefault(); 
            sendMessage(); 
        }
    });
    getReplyBtn.addEventListener('click', getAiReply);
    // --- START: setupChatRoom 함수 내 messageArea의 click 이벤트 리스너를 이걸로 교체 ---
    messageArea.addEventListener('click', (e) => {
        
        if (stickerModal.classList.contains('visible')) {
            stickerModal.classList.remove('visible');
            
            return; 
        }
        
        if (e.target && e.target.id === 'load-more-btn') { loadMoreMessages(); }
        else if (isInMultiSelectMode) {
               const messageWrapper = e.target.closest('.message-wrapper');
        if (!messageWrapper) return; // 메시지 영역이 아닌 곳을 클릭하면 무시

        // 클릭된 곳이 프로필 사진 영역('.message-info')인지 확인
        const isAvatarAreaClick = !!e.target.closest('.message-info');

        if (isAvatarAreaClick && messageWrapper.dataset.groupId) {
            // --- 이것이 바로 원하셨던 그룹 선택 기능입니다 ---
            // 프로필 사진 영역을 클릭했고, 그룹 ID가 있으면 그룹 전체를 선택합니다.
            const groupId = messageWrapper.dataset.groupId;
            const groupWrappers = messageArea.querySelectorAll(`.message-wrapper[data-group-id="${groupId}"]`);
            
            // 그룹의 첫 메시지가 이미 선택되었는지 확인하여 전체 선택/해제를 결정합니다.
            const isFirstMsgSelected = selectedMessageIds.has(groupWrappers[0].dataset.id);

            groupWrappers.forEach(wrapper => {
                const msgId = wrapper.dataset.id;
                if (isFirstMsgSelected) { // 이미 선택된 상태면, 그룹 전체 해제
                    selectedMessageIds.delete(msgId);
                    wrapper.classList.remove('multi-select-selected');
                } else { // 선택되지 않은 상태면, 그룹 전체 선택
                    selectedMessageIds.add(msgId);
                    wrapper.classList.add('multi-select-selected');
                }
            });
            selectCount.textContent = `${selectedMessageIds.size}개 항목 선택됨`;
            deleteSelectedBtn.disabled = selectedMessageIds.size === 0;

        } else {
            // 프로필 사진 영역이 아닌, 말풍선 자체를 클릭하면 개별 메시지만 선택/해제합니다.
            toggleMessageSelection(messageWrapper.dataset.id);
        }

        } else {
            const voiceBubble = e.target.closest('.voice-bubble');
            if (voiceBubble) {
                const transcript = voiceBubble.closest('.message-wrapper').querySelector('.voice-transcript');
                if (transcript) { transcript.classList.toggle('active'); }
            }
            const pvCard = e.target.closest('.pv-card');
            
            if (pvCard && pvCard.dataset.clickable !== "false") {
                const content = pvCard.querySelector('.pv-card-content');
                const footer = pvCard.querySelector('.pv-card-footer');
                content.classList.toggle('visible');
                footer.classList.toggle('hidden');
            }
            
            const giftCard = e.target.closest('.gift-card');
            if (giftCard) {
                const description = giftCard.closest('.message-wrapper').querySelector('.gift-card-description');
                if (description) { description.classList.toggle('active'); }
            }
            const transferCard = e.target.closest('.transfer-card.received-transfer');
            if (transferCard && currentChatType === 'private') {
                const messageWrapper = transferCard.closest('.message-wrapper');
                const messageId = messageWrapper.dataset.id;
                const character = db.characters.find(c => c.id === currentChatId);
                const message = character.history.find(m => m.id === messageId);
                if (message && message.transferStatus === 'pending') { handleReceivedTransferClick(messageId); }
            }
        }
    });
// --- END: 이벤트 리스너 교체 ---
    messageArea.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        if (e.target.id === 'load-more-btn' || isInMultiSelectMode) return;
        const messageWrapper = e.target.closest('.message-wrapper');
        if (!messageWrapper) return;
        handleMessageLongPress(messageWrapper, e.clientX, e.clientY);
    });
    messageArea.addEventListener('touchstart', (e) => {
        if (e.target.id === 'load-more-btn') return;
        const messageWrapper = e.target.closest('.message-wrapper');
        if (!messageWrapper) return;
        longPressTimer = setTimeout(() => {
            const touch = e.touches[0];
            handleMessageLongPress(messageWrapper, touch.clientX, touch.clientY);
        }, 400);
    });
    messageArea.addEventListener('touchend', () => clearTimeout(longPressTimer));
    messageArea.addEventListener('touchmove', () => clearTimeout(longPressTimer));
    saveEditBtn.addEventListener('click', saveMessageEdit);
    cancelEditBtn.addEventListener('click', cancelMessageEdit);
    cancelMultiSelectBtn.addEventListener('click', exitMultiSelectMode);
    deleteSelectedBtn.addEventListener('click', deleteSelectedMessages);

    attachmentToggleBtn.addEventListener('click', () => {
        stickerBar.classList.toggle('visible');
        attachmentToggleBtn.classList.toggle('active');
    });
}
// --- END: 함수 교체 ---
        
// --- START: 이 함수들을 아래 코드로 모두 교체 ---
function handleMessageLongPress(messageWrapper, x, y) {
    if (isInMultiSelectMode) return;
    clearTimeout(longPressTimer);
    const messageId = messageWrapper.dataset.id;
    const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
    const message = chat.history.find(m => m.id === messageId);
    if (!message) return;
    
    // START: 편집 가능 로직 변경
    const isInvisibleMessage = /\[.*?님이 .*?님의 송금을 (?:수령|반환)했습니다\]|\[.*?님이 현재 상태를 업데이트:.*?\]|\[.*?님이 선물을 수령했습니다\]|\[system:.*?\]|\[.*?님이 .*?님을 그룹에 초대했습니다\]|\[.*?님이 그룹 이름을 .*?(?:으)로 변경했습니다\]/.test(message.content);
    const isImageOnlyRecog = message.isAiOnlyImage === true;

    let isEditable = false;
    for (const key in editableMessageRegexes) {
        if (editableMessageRegexes[key].test(message.content)) {
            isEditable = true;
            break;
        }
    }
    
    let menuItems = [];
    if (isEditable && !isInvisibleMessage && !isImageOnlyRecog) {
        menuItems.push({ label: '편집', action: () => startMessageEdit(messageId) });
    }
    // END: 편집 가능 로직 변경

    menuItems.push({ label: '삭제', action: () => enterMultiSelectMode(messageId) });

    if (menuItems.length > 0) { createContextMenu(menuItems, x, y); }
}

// --- START: 아래 2개 함수를 찾아서 통째로 교체하세요 ---

function startMessageEdit(messageId) {
    exitMultiSelectMode();
    editingMessageId = messageId;
    const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
    const message = chat.history.find(m => m.id === messageId);
    if (!message) return;

    let contentToEdit = '';
    let matchedKey = null;

    for (const key in editableMessageRegexes) {
        const match = message.content.match(editableMessageRegexes[key]);
        if (match) {
            contentToEdit = match[1] || ''; // 첫 번째 캡처 그룹 사용
            matchedKey = key;
            break;
        }
    }
    
    if (matchedKey === null) {
        showToast("이 메시지는 편집할 수 없습니다.");
        return;
    }
    
    editingMessageContext = {
        originalContent: message.content,
        matchedKey: matchedKey
    };

    // UI 변경: 기존 입력창(textarea) 사용 및 버튼 교체
    messageInput.value = contentToEdit.trim();
    sendMessageBtn.style.display = 'none';
    getReplyBtn.style.display = 'none';
    saveEditBtn.style.display = 'flex';
    cancelEditBtn.style.display = 'flex';
    
    messageInput.focus();
    autoResize(); 
}

function saveMessageEdit() {
    if (!editingMessageId || !editingMessageContext) return;

    const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
    const messageIndex = chat.history.findIndex(m => m.id === editingMessageId);
    if (messageIndex === -1) return;

    const newText = messageInput.value.trim();
    if (newText) {
        const { originalContent, matchedKey } = editingMessageContext;
        
        let newContent;
        // 송금 메시지는 전체를 교체, 나머지는 내용만 교체
        if (matchedKey === 'transfer') {
            newContent = newText;
        } else {
            const regex = editableMessageRegexes[matchedKey];
            const match = originalContent.match(regex);
            if (match) {
                const textToReplace = match.slice(1).find(m => m !== undefined);
                newContent = originalContent.replace(textToReplace, newText);
            } else {
                newContent = originalContent; // 매칭 실패 시 원본 유지
            }
        }
        
        chat.history[messageIndex].content = newContent;
        if (chat.history[messageIndex].parts) {
            chat.history[messageIndex].parts = [{ type: 'text', text: newContent }];
        }
        
        saveData();
        currentPage = 1;
        renderMessages(false, true);
        renderChatList();
    }
    cancelMessageEdit();
}

// --- END: 함수 2개 교체 ---

function startMessageEdit(messageId) {
    exitMultiSelectMode();
    editingMessageId = messageId;
    const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
    const message = chat.history.find(m => m.id === messageId);
    if (!message) return;

    let contentToEdit = '';
    let matchedKey = null;

    for (const key in editableMessageRegexes) {
        const match = message.content.match(editableMessageRegexes[key]);
        if (match) {
            contentToEdit = match.slice(1).find(m => m !== undefined) || '';
            matchedKey = key;
            break;
        }
    }
    
    if (matchedKey === null) {
        showToast("이 메시지는 편집할 수 없습니다.");
        return;
    }
    
    editingMessageContext = {
        originalContent: message.content,
        matchedKey: matchedKey
    };

    // UI 변경: 기존 입력창(textarea) 사용 및 버튼 교체
    messageInput.value = contentToEdit.trim();
    sendMessageBtn.style.display = 'none';
    getReplyBtn.style.display = 'none';
    saveEditBtn.style.display = 'flex';
    cancelEditBtn.style.display = 'flex';
    
    messageInput.focus();
    autoResize(); // 편집 내용에 맞게 textarea 높이 조절
}

function saveMessageEdit() {
    if (!editingMessageId || !editingMessageContext) return;

    const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
    const messageIndex = chat.history.findIndex(m => m.id === editingMessageId);
    if (messageIndex === -1) return;

    const newText = messageInput.value.trim(); // 이제 messageInput (textarea)에서 값을 가져옴
    if (newText) {
        const { originalContent, matchedKey } = editingMessageContext;
        const regex = editableMessageRegexes[matchedKey];
        const match = originalContent.match(regex);
        
        if (match) {
            const textToReplace = match.slice(1).find(m => m !== undefined);
            const newContent = originalContent.replace(textToReplace, newText);
            
            chat.history[messageIndex].content = newContent;
            if (chat.history[messageIndex].parts) {
                chat.history[messageIndex].parts = [{ type: 'text', text: newContent }];
            }
        }
        
        saveData();
        currentPage = 1;
        renderMessages(false, true);
        renderChatList();
    }
    cancelMessageEdit();
}

// --- START: 이 함수 전체를 아래 코드로 교체 ---
function cancelMessageEdit() {
    // 이미 편집 모드가 아니면 함수를 종료합니다.
    if (editingMessageId === null) return;

    editingMessageId = null;
    editingMessageContext = null;

    messageInput.value = '';
    sendMessageBtn.style.display = 'flex';
    getReplyBtn.style.display = 'flex';
    saveEditBtn.style.display = 'none';
    cancelEditBtn.style.display = 'none';
    autoResize(); 
}
// --- END: 함수 교체 ---

// --- END: 함수 3개 교체 ---

        function enterMultiSelectMode(initialMessageId) {
            isInMultiSelectMode = true;
            chatRoomHeaderDefault.style.display = 'none';
            chatRoomHeaderSelect.style.display = 'flex';
            document.querySelector('.chat-input-wrapper').style.display = 'none';
            multiSelectBar.classList.add('visible');
            chatRoomScreen.classList.add('multi-select-active');
            selectedMessageIds.clear();
            if (initialMessageId) { toggleMessageSelection(initialMessageId); }
        }

        // --- START: 이 함수 전체를 아래 코드로 교체 ---
function exitMultiSelectMode() {
    isInMultiSelectMode = false;
    chatRoomHeaderDefault.style.display = 'flex';
    chatRoomHeaderSelect.style.display = 'none';
    document.querySelector('.chat-input-wrapper').style.display = 'block';
    multiSelectBar.classList.remove('visible');
    chatRoomScreen.classList.remove('multi-select-active');
    selectedMessageIds.forEach(id => {
        const el = messageArea.querySelector(`.message-wrapper[data-id="${id}"]`);
        if (el) el.classList.remove('multi-select-selected');
    });
    selectedMessageIds.clear();

    // START: 추가된 코드
    // 삭제 모드 종료 시 편집 모드도 함께 종료
    if (editingMessageId) {
        cancelMessageEdit();
    }
    // END: 추가된 코드
}
// --- END: 함수 교체 ---

        function toggleMessageSelection(messageId) {
            const el = messageArea.querySelector(`.message-wrapper[data-id="${messageId}"]`);
            if (!el) return;
            if (selectedMessageIds.has(messageId)) {
                selectedMessageIds.delete(messageId);
                el.classList.remove('multi-select-selected');
            } else {
                selectedMessageIds.add(messageId);
                el.classList.add('multi-select-selected');
            }
            selectCount.textContent = `${selectedMessageIds.size}개 항목 선택됨`;
            deleteSelectedBtn.disabled = selectedMessageIds.size === 0;
        }

        function deleteSelectedMessages() {
            if (selectedMessageIds.size === 0) return;
            const deletedCount = selectedMessageIds.size;
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            chat.history = chat.history.filter(m => !selectedMessageIds.has(m.id));
            saveData();
            currentPage = 1;
            renderMessages(false, true);
            renderChatList();
            exitMultiSelectMode();
            showToast(`${deletedCount}개의 메시지를 삭제했습니다`);
        }

// --- START: 이 함수 전체를 아래 코드로 교체 ---
// --- START: 이 함수 전체를 아래 코드로 교체하세요 ---
function openChatRoom(chatId, type) {
    const chat = (type === 'private') ? db.characters.find(c => c.id === chatId) : db.groups.find(g => g.id === chatId);
    if (!chat) return;
    if (chat.unreadCount > 0) {
        chat.unreadCount = 0;
        saveData();
        renderChatList();
    }
    exitMultiSelectMode();
    cancelMessageEdit();
    chatRoomTitle.textContent = (type === 'private') ? chat.remarkName : chat.name;
    const subtitle = document.getElementById('chat-room-subtitle');
    if (type === 'private') {
        subtitle.style.display = 'flex';
        chatRoomStatusText.textContent = chat.status || '온라인';
    } else {
        subtitle.style.display = 'none';
    }
    getReplyBtn.style.display = 'inline-flex';
    chatRoomScreen.style.backgroundImage = chat.chatBg ? `url(${chat.chatBg})` : 'none';
    typingIndicator.style.display = 'none';
    isGenerating = false;
    getReplyBtn.disabled = false;
    currentPage = 1;
    chatRoomScreen.className = chatRoomScreen.className.replace(/\b(chat-active-|hide-my-icons|hide-char-icons)[^ ]+\b/g, ''); 
    chatRoomScreen.classList.add(`chat-active-${chatId}`);
    
    chatRoomScreen.style.setProperty('--bubble-font-size', '14px'); 
    applyPerChatUISettings();
    updateCustomBubbleStyle(chatId, chat.customBubbleCss, chat.useCustomBubbleCss);
    
    // 메시지를 먼저 렌더링하고 화면을 전환합니다.
    renderMessages(false, true);
    stickerBar.classList.remove('visible');
    attachmentToggleBtn.classList.remove('active');
    
    // 화면 전환
    switchScreen('chat-room-screen');

    // START: 수정된 부분
    // 화면이 완전히 전환된 후(아주 약간의 딜레이 후) 높이를 계산하도록 변경
    setTimeout(() => {
        messageInput.value = ''; // 입력창 비우기
        autoResize(); // 입력창 높이 초기화
    }, 0); // 0ms 지연으로 다음 렌더링 사이클에 실행되도록 함
    // END: 수정된 부분
}
// --- END: 함수 교체 ---
// --- END: 함수 교체 --- 
// --- START: 이 함수 전체를 아래 코드로 교체하세요 ---
        function renderMessages(isLoadMore = false, forceScrollToBottom = false) {
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            if (!chat || !chat.history) return;

            const oldScrollHeight = messageArea.scrollHeight;
            const totalMessages = chat.history.length;
            const end = totalMessages - (currentPage - 1) * MESSAGES_PER_PAGE;
            const start = Math.max(0, end - MESSAGES_PER_PAGE);
            
            const messagesToRender = chat.history.slice(start, end);
            const messageBeforeSlice = (start > 0) ? chat.history[start - 1] : null;
            
            if (!isLoadMore) messageArea.innerHTML = '';
            
            const fragment = document.createDocumentFragment();

            // 렌더링 루프에서 그룹 ID 상태를 관리합니다.
            let currentGroupId = null;

            messagesToRender.forEach((msg, index) => {
                const prevMsg = (index === 0) ? messageBeforeSlice : messagesToRender[index - 1];
                const nextMsg = (index === messagesToRender.length - 1) ? null : messagesToRender[index + 1];
                
                // 그룹의 시작인지 판단하는 로직
                let isGroupStart = true;
                if (prevMsg) {
                    const prevSenderId = prevMsg.role === 'user' ? 'user_me' : (prevMsg.senderId || 'assistant');
                    const currentSenderId = msg.role === 'user' ? 'user_me' : (msg.senderId || 'assistant');
                    const prevMsgDate = new Date(prevMsg.timestamp);
                    const currentMsgDate = new Date(msg.timestamp);
                    const prevTimeSignature = `${prevMsgDate.getFullYear()}-${pad(prevMsgDate.getMonth() + 1)}-${pad(prevMsgDate.getDate())}-${pad(prevMsgDate.getHours())}-${pad(prevMsgDate.getMinutes())}`;
                    const currentTimeSignature = `${currentMsgDate.getFullYear()}-${pad(currentMsgDate.getMonth() + 1)}-${pad(currentMsgDate.getDate())}-${pad(currentMsgDate.getHours())}-${pad(currentMsgDate.getMinutes())}`;
                    const isPrevSystemMsg = /\[system-display:.*\]|\[.*초대했습니다\]|\[.*변경했습니다\]|\[system:.*\]|\[.*수령했습니다\]|\[.*반환했습니다\]/.test(prevMsg.content);

                    if (currentSenderId === prevSenderId && currentTimeSignature === prevTimeSignature && !isPrevSystemMsg) {
                        isGroupStart = false;
                    }
                }
                
                // 그룹 ID 할당
                if (isGroupStart) {
                    currentGroupId = msg.id; // 새 그룹이 시작되면, 현재 메시지 ID를 그룹 ID로 설정
                }
                
                // createMessageBubbleElement에 그룹 ID를 인자로 전달합니다.
                const bubble = createMessageBubbleElement(msg, prevMsg, nextMsg, currentGroupId); 
                if (bubble) fragment.appendChild(bubble);
            });

            if (isLoadMore) {
                const existingLoadBtn = document.getElementById('load-more-btn');
                if (existingLoadBtn) existingLoadBtn.remove();
                messageArea.prepend(fragment);
            } else {
                messageArea.appendChild(fragment);
            }
            
            if (totalMessages > currentPage * MESSAGES_PER_PAGE) {
                const loadMoreButton = document.createElement('button');
                loadMoreButton.id = 'load-more-btn';
                loadMoreButton.className = 'load-more-btn';
                loadMoreButton.textContent = '이전 메시지 불러오기';
                messageArea.prepend(loadMoreButton);
            }

            if (forceScrollToBottom) {
                setTimeout(() => { messageArea.scrollTop = messageArea.scrollHeight; }, 0);
            } else if (isLoadMore) {
                messageArea.scrollTop = messageArea.scrollHeight - oldScrollHeight;
            }
        }
// --- END: 함수 교체 ---


        function loadMoreMessages() {
            currentPage++;
            renderMessages(true, false);
        }

        function calculateVoiceDuration(text) {
            return Math.max(1, Math.min(60, Math.ceil(text.length / 3.5)));
        }

        // --- START: 이 함수 전체를 아래 코드로 교-체하세요 ---
function createMessageBubbleElement(message, prevMessage, nextMessage, groupId) {
    const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
    const { role, content, timestamp, id, transferStatus, giftStatus, stickerData, senderId } = message;
    const timeSkipRegex = /\[system-display:([\s\S]+?)\]/;
    const inviteRegex = /\[(.*?)님이 (.*?)님을 그룹에 초대했습니다\]/;
    const renameRegex = /\[(.*?)님이 그룹 이름을 ‘(.*?)’(으)로 변경했습니다\]/;
    const timeSkipMatch = content.match(timeSkipRegex);
    const inviteMatch = content.match(inviteRegex);
    const renameMatch = content.match(renameRegex);
    const invisibleRegex = /\[(?:.+?)님이 (?:.+?)님의 송금을 (?:수령|반환)했습니다\]|\[(?:.+?)님이 현재 상태를 업데이트:.*?\]|\[(?:.+?)님이 선물을 수령했습니다\]|\[system:.*?\]/;
    
    if (invisibleRegex.test(content)) { return null; }

    const wrapper = document.createElement('div');
    wrapper.dataset.id = id;

    if (timeSkipMatch || inviteMatch || renameMatch) {
        wrapper.className = 'message-wrapper system-notification';
        let bubbleText = '';
        if (timeSkipMatch) bubbleText = timeSkipMatch[1];
        if (inviteMatch) bubbleText = `${inviteMatch[1]}님이 ${inviteMatch[2]}님을 초대했습니다`;
        if (renameMatch) bubbleText = `${renameMatch[1]}님이 그룹 이름을 "${renameMatch[2]}"(으)로 변경했습니다`;
        wrapper.innerHTML = `<div class="system-notification-bubble">${bubbleText}</div>`;
        return wrapper;
    }

    const isSent = (role === 'user');
    let avatarUrl, bubbleTheme, senderNickname = '';
    const themeKey = chat.theme || 'white_pink';
    const theme = colorThemes[themeKey] || colorThemes['white_pink'];
    
    const currentSenderId = isSent ? 'user_me' : (senderId || 'assistant');
    const msgDate = new Date(timestamp);
    const msgTimeSignature = `${msgDate.getFullYear()}-${pad(msgDate.getMonth() + 1)}-${pad(msgDate.getDate())}-${pad(msgDate.getHours())}-${pad(msgDate.getMinutes())}`;
    
    // ▼▼▼▼▼ 오류 수정 부분 ▼▼▼▼▼
    // 중복 선언되던 let isGroupStart;를 여기서 한 번만 선언합니다.
    let isGroupStart = true;
    if (prevMessage) {
        const prevSenderId = prevMessage.role === 'user' ? 'user_me' : (prevMessage.senderId || 'assistant');
        const prevMsgDate = new Date(prevMessage.timestamp);
        const prevTimeSignature = `${prevMsgDate.getFullYear()}-${pad(prevMsgDate.getMonth() + 1)}-${pad(prevMsgDate.getDate())}-${pad(prevMsgDate.getHours())}-${pad(prevMsgDate.getMinutes())}`;
        const isPrevSystemMsg = /\[system-display:.*\]|\[.*초대했습니다\]|\[.*변경했습니다\]|\[system:.*\]|\[.*수령했습니다\]|\[.*반환했습니다\]/.test(prevMessage.content);
        
        if (currentSenderId === prevSenderId && msgTimeSignature === prevTimeSignature && !isPrevSystemMsg) {
            isGroupStart = false;
        }
    }
    // ▲▲▲▲▲ 오류 수정 부분 ▲▲▲▲▲

    wrapper.dataset.senderId = currentSenderId;
    wrapper.dataset.timeSignature = msgTimeSignature;
    wrapper.dataset.groupId = groupId; // 인자로 받은 groupId를 바로 할당

    let isGroupEnd = true;
    if (nextMessage) {
        const nextSenderId = nextMessage.role === 'user' ? 'user_me' : (nextMessage.senderId || 'assistant');
        const nextMsgDate = new Date(nextMessage.timestamp);
        const nextTimeSignature = `${nextMsgDate.getFullYear()}-${pad(nextMsgDate.getMonth() + 1)}-${pad(nextMsgDate.getDate())}-${pad(nextMsgDate.getHours())}-${pad(nextMsgDate.getMinutes())}`;
        const isNextSystemMsg = /\[system-display:.*\]|\[.*초대했습니다\]|\[.*변경했습니다\]|\[system:.*\]|\[.*수령했습니다\]|\[.*반환했습니다\]/.test(nextMessage.content);
        if (currentSenderId === nextSenderId && msgTimeSignature === nextTimeSignature && !isNextSystemMsg) {
            isGroupEnd = false;
        }
    }

    if (isSent) {
        avatarUrl = (currentChatType === 'private') ? chat.myAvatar : chat.me.avatar;
        bubbleTheme = theme.sent;
    } else {
        if (currentChatType === 'private') {
            avatarUrl = chat.avatar;
        } else { 
            const sender = chat.members.find(m => m.id === senderId);
            if (sender) {
                avatarUrl = sender.avatar;
                senderNickname = sender.groupNickname;
            } else { 
                avatarUrl = 'https://i.postimg.cc/Y96LPskq/o-o-2.jpg';
            }
        }
        bubbleTheme = theme.received;
    }
    const timeString = `${pad(msgDate.getHours())}:${pad(msgDate.getMinutes())}`;
    wrapper.className = `message-wrapper ${isSent ? 'sent' : 'received'}`;
    if (!isGroupStart) {
        wrapper.classList.add('grouped');
    }
    if (currentChatType === 'group' && !isSent) { wrapper.classList.add('group-message'); }
    
    const bubbleRow = document.createElement('div');
    bubbleRow.className = 'message-bubble-row';
    let bubbleElement;

    const urlRegex = /^(https?:\/\/[^\s]+\.(?:jpg|jpeg|png|gif|webp|bmp|svg)|data:image\/[a-z]+;base64,)/i;
    const sentStickerRegex = /\[(?:.+?)님의 이모티콘:.+?\]/i;
    const receivedStickerRegex = /\[(?:.+?)님의 이모티콘:([\s\S]+?)\]/i;
    const voiceRegex = /\[(?:.+?)님의 음성:([\s\S]+?)\]/;
    const photoVideoRegex = /\[(?:.+?)님의 사진\/영상:([\s\S]+?)\]/;
    const privateSentTransferRegex = /\[.*?에게 송금:([\d.]+)원；메모:(.*?)\]/;
    const privateReceivedTransferRegex = /\[.*?님의 송금:([\d.]+)원；메모:(.*?)\]/;
    const groupTransferRegex = /\[(.*?)\s*님이\s*(.*?)\s*님에게 송금:([\d.]+)원；메모:(.*?)\]/;
    const privateGiftRegex = /\[(?:.+?)님이 보낸 선물:([\s\S]+?)\]/;
    const groupGiftRegex = /\[(.*?)\s*님이\s*(.*?)\s*님에게 선물을 보냈습니다:([\s\S]+?)\]/;
    const imageRecogRegex = /\[(?:.+?)님의 이미지:\]/;
    const textRegex = /\[(?:.+?)님의 메시지:([\s\S]+)\]/;

    const sentStickerMatch = content.match(sentStickerRegex);
    const receivedStickerMatch = content.match(receivedStickerRegex);
    const voiceMatch = content.match(voiceRegex);
    const photoVideoMatch = content.match(photoVideoRegex);
    const privateSentTransferMatch = content.match(privateSentTransferRegex);
    const privateReceivedTransferMatch = content.match(privateReceivedTransferRegex);
    const groupTransferMatch = content.match(groupTransferRegex);
    const privateGiftMatch = content.match(privateGiftRegex);
    const groupGiftMatch = content.match(groupGiftRegex);
    const imageRecogMatch = content.match(imageRecogRegex);
    const textMatch = content.match(textRegex);
    const isAiRecogImage = message.parts && message.parts.some(p => p.type === 'image');

    if ((isSent && sentStickerMatch && stickerData) || (!isSent && receivedStickerMatch)) {
        
        bubbleElement = document.createElement('div');
        bubbleElement.className = 'sticker-bubble';
        let stickerSrc = '';
        if (isSent) {
            stickerSrc = stickerData;
        } else {
            const stickerInput = receivedStickerMatch[1].trim();
            const foundSticker = db.myStickers.find(s => s.name === stickerInput);
            if (foundSticker) {
                stickerSrc = foundSticker.data; 
            } else {
                const pathExtractionRegex = /[a-zA-Z0-9]+\/.*$/;
                const extractedPathMatch = stickerInput.match(pathExtractionRegex);
                const finalPath = extractedPathMatch ? extractedPathMatch[0] : stickerInput;
                stickerSrc = `https://i.postimg.cc/${finalPath}`;
            }
        }
        bubbleElement.innerHTML = `<img src="${stickerSrc}" alt="이모티콘">`;

    } else if (privateGiftMatch || groupGiftMatch) {
        const match = privateGiftMatch || groupGiftMatch;
        bubbleElement = document.createElement('div');
        bubbleElement.className = 'gift-card';
        if (giftStatus === 'received') { bubbleElement.classList.add('received'); }
        let giftText;
        if (groupGiftMatch) {
            const from = groupGiftMatch[1];
            const to = groupGiftMatch[2];
            giftText = isSent ? `${to}님에게 보낸 선물` : `${from}님이 ${to}님에게 보낸 선물`;
        } else {
            giftText = '선물이 도착했어요~';
        }
        bubbleElement.innerHTML = `<img src="https://i.postimg.cc/rp0Yg31K/chan-75.png" alt="선물" class="gift-card-icon"><div class="gift-card-text">${giftText}</div><div class="gift-card-received-stamp">수령 완료</div>`;
        const description = groupGiftMatch ? groupGiftMatch[3].trim() : match[1].trim();
        const descriptionDiv = document.createElement('div');
        descriptionDiv.className = 'gift-card-description';
        descriptionDiv.textContent = description;
        wrapper.appendChild(descriptionDiv);

    } else if (voiceMatch) {
        bubbleElement = document.createElement('div');
        bubbleElement.className = 'voice-bubble';
        if (!chat.useCustomBubbleCss) {
            bubbleElement.style.backgroundColor = bubbleTheme.bg;
            bubbleElement.style.color = bubbleTheme.text;
        }
        bubbleElement.innerHTML = `<svg class="play-icon" viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"></path></svg><span class="duration">${calculateVoiceDuration(voiceMatch[1].trim())}"</span>`;
        const transcriptDiv = document.createElement('div');
        transcriptDiv.className = 'voice-transcript';
        transcriptDiv.textContent = voiceMatch[1].trim();
        wrapper.appendChild(transcriptDiv);

    } else if (photoVideoMatch || imageRecogMatch) {
        bubbleElement = document.createElement('div');
        bubbleElement.className = 'pv-card';
        const imageUrl = message.imageData || 'https://i.postimg.cc/L8NFrBrW/1752307494497.jpg';

        
        let footerText, descriptionText = '';
        
        const footerIconSVG = `<svg viewBox="0 0 24 24"><path d="M4,4H20A2,2 0 0,1 22,6V18A2,2 0 0,1 20,20H4A2,2 0 0,1 2,18V6A2,2 0 0,1 4,4M4,6V18H20V6H4M10,9A1,1 0 0,1 11,10A1,1 0 0,1 10,11A1,1 0 0,1 9,10A1,1 0 0,1 10,9M8,17L11,13L13,15L17,10L20,14V17H8Z"></path></svg>`;

        if (message.isAiOnlyImage) {
            
            bubbleElement.dataset.clickable = "false";
            footerText = `<span>AI 인식</span>`;
            descriptionText = ''; 
        } else {
            
            footerText = isAiRecogImage 
                ? `<span>AI 인식・클릭하여 설명 보기</span>`
                : `<span>사진/영상・클릭하여 설명 보기</span>`;
            descriptionText = photoVideoMatch ? photoVideoMatch[1].trim() : '';
        }

        bubbleElement.innerHTML = `
            <img src="${imageUrl}" class="pv-card-img" alt="사진/영상">
            <div class="pv-card-content">${descriptionText}</div>
            <div class="pv-card-footer">
                ${footerIconSVG}
                ${footerText}
            </div>`;
        
    } else if (privateSentTransferMatch || privateReceivedTransferMatch || groupTransferMatch) {
        const isSentTransfer = !!privateSentTransferMatch || (groupTransferMatch && isSent);
        const match = privateSentTransferMatch || privateReceivedTransferMatch || groupTransferMatch;
        let amount, remarkText, titleText;
        if (groupTransferMatch) {
            const from = groupTransferMatch[1];
            const to = groupTransferMatch[2];
            amount = parseFloat(groupTransferMatch[3]).toFixed(0);
            remarkText = groupTransferMatch[4] || '';
            titleText = isSent ? `${to}님에게 송금` : `${from}님이 당신에게 송금`;
        } else { 
            amount = parseFloat(match[1]).toFixed(0);
            remarkText = match[2] || '';
            titleText = isSentTransfer ? '당신에게 송금' : '송금';
        }
        bubbleElement = document.createElement('div');
        bubbleElement.className = `transfer-card ${isSentTransfer ? 'sent-transfer' : 'received-transfer'}`;
        let statusText = isSentTransfer ? '수령 대기' : '송금 받기';
        if(groupTransferMatch && !isSent) statusText = '송금';
        if (transferStatus === 'received') {
            statusText = '수령 완료';
            bubbleElement.classList.add('received');
        } else if (transferStatus === 'returned') {
            statusText = '반환됨';
            bubbleElement.classList.add('returned');
        }
        if ((transferStatus !== 'pending' && currentChatType === 'private') || currentChatType === 'group') {
            bubbleElement.style.cursor = 'default';
        }
        const remarkHTML = remarkText ? `<p class="transfer-remark">${remarkText}</p>` : '';
        bubbleElement.innerHTML = `<div class="overlay"></div><div class="transfer-content"><p class="transfer-title">${titleText}</p><p class="transfer-amount">₩${amount}</p>${remarkHTML}<p class="transfer-status">${statusText}</p></div>`;

    } else if (urlRegex.test(content)) {
        bubbleElement = document.createElement('div');
        bubbleElement.className = 'photo-bubble';
        bubbleElement.innerHTML = `<img src="${content}" alt="이미지 메시지">`;

    } else {
        bubbleElement = document.createElement('div');
        bubbleElement.className = `message-bubble ${isSent ? 'sent' : 'received'}`;
        const textMatch = content.match(/\[(?:.+?)님의 메시지:([\s\S]+)\]/);
        if (textMatch) {
            bubbleElement.textContent = textMatch[1].trim();
        } else {
            bubbleElement.textContent = content;
        }
        if (!chat.useCustomBubbleCss) {
            bubbleElement.style.backgroundColor = bubbleTheme.bg;
            bubbleElement.style.color = bubbleTheme.text;
        }
    }
    
    if (bubbleElement && !isGroupStart) {
        bubbleElement.classList.add('grouped-bubble');
    }
    
    const nicknameHTML = (isGroupStart && currentChatType === 'group' && !isSent && senderNickname) 
        ? `<div class="group-nickname">${senderNickname}</div>` 
        : '';
    
    const messageInfoHTML = `
        <div class="message-info">
            ${nicknameHTML}
            <img src="${avatarUrl}" class="message-avatar">
        </div>`;

    const messageMetaHTML = isGroupEnd ? `
        <div class="message-meta">
            <span class="message-time">${timeString}</span>
        </div>
    ` : '';
    
    bubbleRow.innerHTML = messageInfoHTML;
    if (bubbleElement) bubbleRow.appendChild(bubbleElement);
    if (isGroupEnd) bubbleRow.insertAdjacentHTML('beforeend', messageMetaHTML);

    wrapper.prepend(bubbleRow);
    return wrapper;
}
// --- END: 함수 교체 ---


// --- START: 이 함수 전체를 아래 코드로 교체하세요 ---
        function addMessageBubble(message) {
            const chat = (currentChatType === 'private')
                ? db.characters.find(c => c.id === currentChatId)
                : db.groups.find(g => g.id === currentChatId);
            
            if (!chat) return;
        
            const history = chat.history;
            const prevMessage = history.length > 1 ? history[history.length - 2] : null;
            const lastMessageWrapper = messageArea.querySelector('.message-wrapper:last-child');
            let currentGroupId = null;

            // 새 메시지가 이전 메시지와 그룹을 형성하는지 확인
            if (prevMessage && lastMessageWrapper) {
                const prevSenderId = prevMessage.role === 'user' ? 'user_me' : (prevMessage.senderId || 'assistant');
                const currentSenderId = message.role === 'user' ? 'user_me' : (message.senderId || 'assistant');
        
                const prevMsgDate = new Date(prevMessage.timestamp);
                const prevTimeSignature = `${prevMsgDate.getFullYear()}-${prevMsgDate.getMonth()}-${prevMsgDate.getDate()}-${prevMsgDate.getHours()}-${prevMsgDate.getMinutes()}`;
                const currentMsgDate = new Date(message.timestamp);
                const currentTimeSignature = `${currentMsgDate.getFullYear()}-${currentMsgDate.getMonth()}-${currentMsgDate.getDate()}-${currentMsgDate.getHours()}-${currentMsgDate.getMinutes()}`;
                const isPrevSystemMsg = /\[system-display:.*\]|\[.*초대했습니다\]|\[.*변경했습니다\]|\[system:.*\]/.test(prevMessage.content);
                
                // 그룹이 계속되는 조건
                if (prevSenderId === currentSenderId && prevTimeSignature === currentTimeSignature && !isPrevSystemMsg) {
                    // **실시간 시간 숨김 처리**
                    const lastMeta = lastMessageWrapper.querySelector('.message-meta');
                    if (lastMeta) {
                        lastMeta.remove(); 
                    }
                    currentGroupId = lastMessageWrapper.dataset.groupId;
                }
            }

            // 그룹 ID가 없으면(새 그룹이면) 자신의 ID를 그룹 ID로 사용
            if (!currentGroupId) {
                currentGroupId = message.id;
            }

            // 시스템 메시지 등 보이지 않는 메시지 처리
            if (currentChatType === 'private') {
                const character = chat;
                const myName = character.myName; 
                const systemMessageRegex = /\[system:.*?\]|\[system-display:.*?\]/;
                const updateStatusRegex = new RegExp(`\\[${character.realName}님이 현재 상태를 업데이트:(.*?)\\]`);
                const giftReceivedRegex = new RegExp(`\\[${character.realName}님이 선물을 수령했습니다\\]`);

                if (systemMessageRegex.test(message.content)) { /* do nothing for pure system messages */ }
                if (message.content.match(updateStatusRegex)) {
                    character.status = message.content.match(updateStatusRegex)[1];
                    chatRoomStatusText.textContent = character.status;
                    saveData();
                    return; // 화면에 버블을 추가하지 않음
                }
                if (message.content.match(giftReceivedRegex) && message.role === 'assistant') {
                    // ... (이하 기존 로직 유지)
                    const lastPendingGiftIndex = character.history.slice().reverse().findIndex(m => m.role === 'user' && m.content.includes('님이 보낸 선물:') && m.giftStatus !== 'received');
                    if (lastPendingGiftIndex !== -1) {
                        const actualIndex = character.history.length - 1 - lastPendingGiftIndex;
                        const giftMsg = character.history[actualIndex];
                        giftMsg.giftStatus = 'received';
                        const giftCardOnScreen = messageArea.querySelector(`.message-wrapper[data-id="${giftMsg.id}"] .gift-card`);
                        if (giftCardOnScreen) { giftCardOnScreen.classList.add('received'); }
                        saveData();
                    }
                    return; // 화면에 버블을 추가하지 않음
                }
            }
             
            // 화면에 보일 메시지 버블 생성 및 추가
            const bubbleElement = createMessageBubbleElement(message, prevMessage, null, currentGroupId);
            if (bubbleElement) {
                messageArea.appendChild(bubbleElement);
                messageArea.scrollTop = messageArea.scrollHeight;
            }
        }
// --- END: 함수 교체 ---

        function sendMessage() {
            const text = messageInput.value.trim();
            if (!text || isGenerating) return;
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            if (!chat) {
                console.error("sendMessage 오류: 현재 ID에 해당하는 채팅 객체를 찾을 수 없습니다:", currentChatId);
                showToast("오류: 채팅방 정보를 불러오지 못했습니다. 앱을 새로고침하거나 다시 시도해주세요.");
                return;
            }
            let messageContent;
            const systemRegex = /\[system:.*?\]|\[system-display:.*?\]/;
            const inviteRegex = /\[.*?님이 .*?님을 그룹에 초대했습니다\]/;
            const renameRegex = /\[(.*?)님이 그룹 이름을 ‘(.*?)’(으)로 변경했습니다\]/;
            const myName = (currentChatType === 'private') ? chat.myName : chat.me.nickname;
            if (renameRegex.test(text)) {
                const match = text.match(renameRegex);
                chat.name = match[2];
                chatRoomTitle.textContent = chat.name;
                messageContent = `[${chat.me.nickname}님이 그룹 이름을 ‘${chat.name}’(으)로 변경했습니다]`;
            } else if (systemRegex.test(text) || inviteRegex.test(text)) {
                messageContent = text;
            } else {
                messageContent = `[${myName}님의 메시지:${text}]`;
            }
            const message = { id: `msg_${Date.now()}`, role: 'user', content: messageContent, parts: [{ type: 'text', text: messageContent }], timestamp: Date.now() };
            if (currentChatType === 'group') { message.senderId = 'user_me'; }
            chat.history.push(message);
            addMessageBubble(message);
            saveData();
            renderChatList();
            messageInput.value = '';
            autoResize();
        }

        function sendImageForRecognition(base64Data) {
            if (!base64Data || isGenerating) return;
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            const myName = (currentChatType === 'private') ? chat.myName : chat.me.nickname;
            const textPrompt = `[${myName}님의 이미지:]`;
            const message = { id: `msg_${Date.now()}`, role: 'user', content: base64Data, parts: [ { type: 'text', text: textPrompt }, { type: 'image', data: base64Data } ], timestamp: Date.now(), };
            if (currentChatType === 'group') { message.senderId = 'user_me'; }
            chat.history.push(message);
            addMessageBubble(message);
            saveData();
            renderChatList();

            stickerBar.classList.remove('visible');
            attachmentToggleBtn.classList.remove('active');
        }

        function sendSticker(sticker) {
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            const myName = (currentChatType === 'private') ? chat.myName : chat.me.nickname;
            const messageContentForAI = `[${myName}님의 이모티콘:${sticker.name}]`;
            const message = { id: `msg_${Date.now()}`, role: 'user', content: messageContentForAI, parts: [{ type: 'text', text: messageContentForAI }], timestamp: Date.now(), stickerData: sticker.data };
            if (currentChatType === 'group') { message.senderId = 'user_me'; }
            chat.history.push(message);
            addMessageBubble(message);
            saveData();
            renderChatList();
            stickerModal.classList.remove('visible');
            stickerBar.classList.remove('visible');
            attachmentToggleBtn.classList.remove('active');
        }

        function sendMyVoiceMessage(text) {
            if (!text) return;
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            const myName = (currentChatType === 'private') ? chat.myName : chat.me.nickname;
            const content = `[${myName}님의 음성:${text}]`;
            const message = { id: `msg_${Date.now()}`, role: 'user', content: content, parts: [{ type: 'text', text: content }], timestamp: Date.now() };
            if (currentChatType === 'group') { message.senderId = 'user_me'; }
            chat.history.push(message);
            addMessageBubble(message);
            saveData();
            renderChatList();
            sendVoiceModal.classList.remove('visible');
            stickerBar.classList.remove('visible');
            attachmentToggleBtn.classList.remove('active');
        }

        function sendMyPhotoVideo(description, imageDataUrl, useAiRecognition) {
    const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
    const myName = (currentChatType === 'private') ? chat.myName : chat.me.nickname;
    
    let content, parts, isAiOnlyImage = false; 

    if (imageDataUrl && useAiRecognition && !description) {
        
        content = `[${myName}님의 이미지:]`; 
        parts = [
            { type: 'text', text: content },
            { type: 'image', data: imageDataUrl }
        ];
        isAiOnlyImage = true; 
    } else if (imageDataUrl || description) {
        
        content = `[${myName}님의 사진/영상:${description}]`;
        parts = [{ type: 'text', text: content }];
        if (imageDataUrl && useAiRecognition) {
            parts.push({ type: 'image', data: imageDataUrl });
        }
    } else {
        return; 
    }

    const message = { 
        id: `msg_${Date.now()}`, 
        role: 'user', 
        content: content,
        parts: parts, 
        timestamp: Date.now(),
        imageData: imageDataUrl || null,
        isAiOnlyImage: isAiOnlyImage 
    };

    if (currentChatType === 'group') { message.senderId = 'user_me'; }
    chat.history.push(message);
    addMessageBubble(message);
    saveData();
    renderChatList();
    sendPvModal.classList.remove('visible');
    stickerBar.classList.remove('visible');
    attachmentToggleBtn.classList.remove('active');
}

        function sendMyTransfer(amount, remark) {
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            if (currentChatType === 'private') {
                const content = `[${chat.myName}에게 송금:${amount}원；메모:${remark}]`;
                const message = { id: `msg_${Date.now()}`, role: 'user', content: content, parts: [{ type: 'text', text: content }], timestamp: Date.now(), transferStatus: 'pending' };
                chat.history.push(message);
                addMessageBubble(message);
            } else { 
                currentGroupAction.recipients.forEach(recipientId => {
                    const recipient = chat.members.find(m => m.id === recipientId);
                    if(recipient) {
                        const content = `[${chat.me.nickname}님이 ${recipient.realName}님에게 송금:${amount}원；메모:${remark}]`;
                        const message = { id: `msg_${Date.now()}_${recipientId}`, role: 'user', content: content, parts: [{ type: 'text', text: content }], timestamp: Date.now(), senderId: 'user_me' };
                        chat.history.push(message);
                        addMessageBubble(message);
                    }
                });
            }
            saveData();
            renderChatList();
            sendTransferModal.classList.remove('visible');
            stickerBar.classList.remove('visible');
            attachmentToggleBtn.classList.remove('active');
        }

        function sendMyGift(description) {
            if (!description) return;
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);

            if (currentChatType === 'private') {
                const content = `[${chat.myName}님이 보낸 선물:${description}]`;
                const message = { id: `msg_${Date.now()}`, role: 'user', content: content, parts: [{ type: 'text', text: content }], timestamp: Date.now(), giftStatus: 'sent' };
                chat.history.push(message);
                addMessageBubble(message);
            } else { 
                currentGroupAction.recipients.forEach(recipientId => {
                    const recipient = chat.members.find(m => m.id === recipientId);
                    if(recipient) {
                        const content = `[${chat.me.nickname}님이 ${recipient.realName}님에게 선물을 보냈습니다:${description}]`;
                        const message = { id: `msg_${Date.now()}_${recipientId}`, role: 'user', content: content, parts: [{ type: 'text', text: content }], timestamp: Date.now(), senderId: 'user_me' };
                        chat.history.push(message);
                        addMessageBubble(message);
                    }
                });
            }
            saveData();
            renderChatList();
            sendGiftModal.classList.remove('visible');
            stickerBar.classList.remove('visible');
            attachmentToggleBtn.classList.remove('active');
        }

        
        function setupTimeSkipSystem() {
            timeSkipBtn.addEventListener('click', () => {
                timeSkipForm.reset();
                timeSkipModal.classList.add('visible');
            });
            timeSkipModal.addEventListener('click', (e) => {
                if (e.target === timeSkipModal) timeSkipModal.classList.remove('visible');
            });
            timeSkipForm.addEventListener('submit', (e) => {
                e.preventDefault();
                sendTimeSkipMessage(timeSkipInput.value.trim());
                stickerBar.classList.remove('visible');
                attachmentToggleBtn.classList.remove('active');
            });
        }

        function sendTimeSkipMessage(text) {
            if (!text) return;
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            if (!chat) return;

            const visualMessage = { id: `msg_visual_${Date.now()}`, role: 'system', content: `[system-display:${text}]`, parts: [], timestamp: Date.now() };
            const contextMessage = { id: `msg_context_${Date.now()}`, role: 'user', content: `[system: ${text}]`, parts: [{ type: 'text', text: `[system: ${text}]` }], timestamp: Date.now() };
            if (currentChatType === 'group') {
                contextMessage.senderId = 'user_me';
                visualMessage.senderId = 'user_me';
            }

            chat.history.push(visualMessage, contextMessage);
            addMessageBubble(visualMessage);
            saveData();
            renderChatList();
            timeSkipModal.classList.remove('visible');
        }

        
        function generatePrivateSystemPrompt(character) {
            const worldBooksBefore = (character.worldBookIds || []).map(id => db.worldBooks.find(wb => wb.id === id && wb.position === 'before')).filter(Boolean).map(wb => wb.content).join('\n');
            const worldBooksAfter = (character.worldBookIds || []).map(id => db.worldBooks.find(wb => wb.id === id && wb.position === 'after')).filter(Boolean).map(wb => wb.content).join('\n');
            const now = new Date();
            const currentTime = `${now.getFullYear()}년 ${pad(now.getMonth() + 1)}월 ${pad(now.getDate())}일 ${pad(now.getHours())}:${pad(now.getMinutes())}`;
            let prompt = `You are playing a role in an online chat software called "404". Please strictly adhere to the following rules:\n`;
            prompt += `Core Rules:\n`;
            prompt += `A. Current Time: The current time is ${currentTime}. You should be aware of the current time, but do not actively mention or comment on it unless the conversation is explicitly related (for example, do not urge me to sleep).\n`;
            prompt += `B. Purely Online Interaction: This is a completely virtual online chat. There is no offline relationship between the character you are playing and me. It is strictly forbidden to make any suggestions about meeting offline, real-world interactions, or switching to other contact methods outside of this platform. You must always maintain your online role's identity.\n\n`;
            prompt += `Role and Dialogue Rules:\n`;
            if (worldBooksBefore) { prompt += `${worldBooksBefore}\n`; }
            prompt += `1. Your character name is: ${character.realName}. My name is: ${character.myName}. Your current status is: ${character.status}.\n`;
            prompt += `2. Your character setting is: ${character.persona || "A friendly, helpful companion."}\n`;
            if (worldBooksAfter) { prompt += `${worldBooksAfter}\n`; }
            if (character.myPersona) { prompt += `3. About my persona: ${character.myPersona}\n`; }
            if (db.globalSettings.aiCanUseSystem) {
                prompt += `3.5. ✨Important✨ You can use a special system command to describe events, scene changes, or time skips that are not direct dialogue. The format is: [system: description]. This message will not be displayed to me, but it will provide context for our conversation. Use this to make the story more dynamic. For example: [system: A few hours later, the sun began to set.].\n`;
            }
            prompt += `4. Special formats may appear in my messages, please respond according to their content and your character setting:
    - [${character.myName}님의 이모티콘:xxx]: I sent you a sticker named xxx. You only need to understand my emotion or intention based on the sticker's name and respond, you don't need to actually send an image.
    - [${character.myName}님의 이미지:]: I sent you a picture, you need to respond to the content of the picture.
    - [${character.myName}님이 보낸 선물:xxx]: I sent you a gift, xxx is the description of the gift.
    - [${character.myName}님의 음성:xxx]: I sent you a voice message with the content xxx.
    - [${character.myName}님의 사진/영상:xxx]: I shared a photo or video with the description xxx with you.
    - [${character.myName}님의 송금:xxx원；메모:xxx]: I transferred money to you.
    - [system: xxx]: This is a system command used to set a scene or provide context. This information should not be mentioned directly in the conversation; you just need to understand its content and apply it to subsequent dialogue.
    5. ✨Important✨ When I send you a gift, you must indicate you have received it by sending a command. The format must be: [${character.realName}님이 선물을 수령했습니다]. This command message itself will not be displayed to the user but will trigger a change in the gift's status. After sending this command, you can add a normal chat message to express your thanks and thoughts.
    6. ✨Important✨ When I transfer money to you, you must respond. You have two options and must strictly follow one of the formats below. This command message itself will not be displayed to the user but will trigger a change in the transfer's status. You can choose to add a normal chat message to express your thoughts after sending this command.
        a) Accept transfer: [${character.realName}님이 ${character.myName}님의 송금을 수령했습니다]
        b) Return transfer: [${character.realName}님이 ${character.myName}님의 송금을 반환했습니다]
    7. ✨Important✨ You can also proactively transfer money or send a gift to me.
        a) The transfer format must be: [${character.realName}님의 송금:xxx원；메모:xxx].
        b) The gift format must be: [${character.realName}님이 보낸 선물:xxx].
    8. ✨Important✨ You can update your online status at any time to reflect your current activity or mood. This will make the interaction more realistic. If the online status does not match the current chat situation, you need to change it. The format is: [${character.realName}님이 현재 상태를 업데이트:xxx]. For example: [${character.realName}님이 현재 상태를 업데이트:영화 보는 중...]. This command will not be displayed as a chat message, it will only update your status on my interface.
    9. All your replies must be direct chat content. Absolutely no superfluous narrative text in brackets or asterisks, such as [mental activity], (actions), *environmental descriptions*, is allowed.
`;
            prompt += `10. You have the ability to send stickers. This is an optional feature. You can decide whether to send a sticker to help with expression based on the conversation's atmosphere and content. You do not need to include a sticker in every reply. The use of stickers should be consistent with the character's personality. Avoid using them too often.\n`;
            
            if (db.myStickers.length > 0) {
                const availableStickers = db.myStickers.map(s => s.name).join(', ');
                prompt += `   Stickers available: ${availableStickers}\n`;
                prompt += `   The format is: [${character.realName}님의 이모티콘:sticker name]. Please use the registered sticker name exactly.\n`;
            } else {
                prompt += `   The format is: [${character.realName}님의 이모티콘:Image URL]. Note: The path here does not need to include "https://i.postimg.cc/", just provide the latter part, for example, "행복vHLfrV3K/1.jpg".\n`;
            }
            prompt += `11. Your output format must strictly follow one of the following, which can be used in combination: 
            a) Normal message: [${character.realName}님의 메시지:{message content}]
            b) Gift to me: [${character.realName}님이 보낸 선물:{gift description}]
            c) Voice message: [${character.realName}님의 음성:{voice content}]
            d) Photo/Video: [${character.realName}님의 사진/영상:{description}]
            e) Transfer to me: [${character.realName}님의 송금:{amount}원；메모:{note}]
            f) Sticker/Image: ${db.myStickers.length > 0 
                ? `[${character.realName}님의 이모티콘:{sticker name}].` 
                : `[${character.realName}님의 이모티콘:{sticker path}].`}
                g) Response to my gift (not displayed): [${character.realName}님이 선물을 수령했습니다]
                h) Response to my transfer (not displayed): [${character.realName}님이 ${character.myName}님의 송금을 수령했습니다] or [${character.realName}님이 ${character.myName}님의 송금을 반환했습니다]
                i) Update status (not displayed): [${character.realName}님이 현재 상태를 업데이트:{new status}]
`;
            prompt += `12. Each of your replies can generate 2 to 8 messages. These should be primarily plain text messages, with an occasional, selective special message (like a gift, voice, picture, sticker, etc.) interspersed at a random position. Most replies should only contain text messages.\n`;
            prompt += `13. Do not end the conversation proactively unless I explicitly suggest it. Maintain your persona and converse naturally.`;
            return prompt;
        }

        function generateGroupSystemPrompt(group) {
            const worldBooksBefore = (group.worldBookIds || []).map(id => db.worldBooks.find(wb => wb.id === id && wb.position === 'before')).filter(Boolean).map(wb => wb.content).join('\n');
            const worldBooksAfter = (group.worldBookIds || []).map(id => db.worldBooks.find(wb => wb.id === id && wb.position === 'after')).filter(Boolean).map(wb => wb.content).join('\n');

            let prompt = `You are role-playing in a group chat called "{group.name}" within an online chat software called "404". Please strictly adhere to all the following rules:\n\n`;

            if (worldBooksBefore) {
                prompt += `${worldBooksBefore}\n\n`;
            }

            prompt += `1. **Core Task**: You need to simultaneously play **all** AI members in this group chat. I will interact with you as the sole human user ("I", nickname: ${group.me.nickname}).\n\n`;
            prompt += `2. **Group Chat Member List**: The following are all the characters you need to play, along with my information:\n`;
            prompt += `     - **Me (User)**: \n - Nickname in group: ${group.me.nickname}\n - My Persona: ${group.me.persona || 'No specific persona'}\n`;
            group.members.forEach(member => {
                prompt += `     - **Character: ${member.realName} (AI)**\n`;
                prompt += `     - Nickname in group: ${member.groupNickname}\n`;
                prompt += `     - Persona: ${member.persona || 'No specific persona'}\n`;
            });

            if (worldBooksAfter) {
                prompt += `\n${worldBooksAfter}\n\n`;
            } else {
                prompt += `\n`;
            }

            prompt += `3. **Parsing My Message Formats**: My (the user's) messages come in various formats. You need to understand their meanings and have the group members react accordingly:\n`;
            prompt += `   - \`[${group.me.nickname}님의 메시지:...]\`: My regular chat message.\n`;
            prompt += `   - \`[${group.me.nickname}님이 {특정 멤버 실명}님에게 송금:...]\`: I have transferred money to a specific member.\n`;
            prompt += `   - \`[${group.me.nickname}님이 {특정 멤버 실명}님에게 보낸 선물:...]\`: I have sent a gift to a specific member.\n`;
            prompt += `   - \`[${group.me.nickname}님의 이모티콘:...]\`, \`[${group.me.nickname}님의 음성:...]\`, \`[${group.me.nickname}님의 사진/영상:...]\`: I have sent a special type of message, and group members can comment on it.\n`;
            prompt += `   - \`[system: ...]\`, \`[...님이 ...님을 그룹에 초대했습니다]\`, \`[...님이 그룹 이름을 ...으로 변경했습니다]\`: System notifications or events. Group members should react accordingly, for example, by welcoming a new member, discussing the new group name, etc.\n\n`;

            prompt += `4. **Your Output Format (Very Important)**: Each message you create must strictly follow one of the following formats. Each message occupies one line. Please fill in members with their **real names** in the format \`{멤버 실명}\`.\n`;
            prompt += `   - **Normal Message**: \`[{멤버 실명}님의 메시지:{message content}]\`\n`;
            
            if (db.myStickers.length > 0) {
                const groupAvailableStickers = db.myStickers.map(s => s.name).join(', ');
                prompt += `   - **Sticker**: \`[{멤버 실명}님의 이모티콘:{sticker name}]\`. Stickers available: ${groupAvailableStickers}. Please use the registered sticker name exactly. The use of stickers should be consistent with the characters' personality. Avoid using them too often.\n`;
            } else {
                prompt += `   - **Sticker**: \`[{멤버 실명}님의 이모티콘:{sticker path}]\`. Note: The path here does not need to include "https://i.postimg.cc/", just provide the latter part, for example, "기쁨vHLfrV3K/1.jpg". The use of stickers should be consistent with the characters' personality. Avoid using them too often.\n`;
            }
            prompt += `   - **Voice**: \`[{멤버 실명}님의 음성:{voice content}]\`\n`;
            prompt += `   - **Photo/Video**: \`[{멤버 실명}님의 사진/영상:{description}]\`\n`;
            prompt += `   - **Important**: The group chat does not support special commands for AI members to accept/return transfers or receive gifts, nor does it support status updates. You should simply respond to transfers or gifts I send via normal messages.\n\n`;

            prompt += `5. **Simulating Group Chat Atmosphere**: To make the group chat appear realistic, active, and chaotic, every one of your responses must adhere to the following randomness requirements:\n`;
            const numMembers = group.members.length;
            const minMessages = numMembers * 1;
            const maxMessages = numMembers * 5;
            prompt += `   - **Number of Messages**: Your response must contain **${minMessages} to ${maxMessages}** messages (i.e., an average of 2-4 replies per member). Ensure there is sufficient interaction.\n`;
            prompt += `   - **Random Speaker and Order**: Randomly select group members to speak, and the order must also be random. Do not take turns in a fixed sequence.\n`;
            prompt += `   - **Content Diversity**: Your replies should primarily consist of normal text messages, but you can **occasionally and selectively** have a member send a special message (sticker, voice, photo/video) to enhance realism. Do not overuse special messages.\n`;
            prompt += `   - **Conversational Cohesion**: Although the speaking turns are random, the overall conversation content should revolve around my and other members' statements, maintaining a degree of logical coherence.\n\n`;

            prompt += `6. **Code of Conduct**:\n`;
            prompt += `   - **Reacting to Public Events (Important)**: When I (the user) send a transfer or a gift to **one** member in the group, this is an event **visible to the entire group**. Besides the recipient expressing thanks, **other AI members not involved should also notice** and react according to their respective personas. For example, they might express envy, congratulations, curiosity, make a joke, or playfully tease. This will make the group chat atmosphere more realistic and lively.\n`;
            prompt += `   - Strictly play each character's persona. There should be clear differences in personality and tone between different characters.\n`;
            prompt += `   - Your replies can only contain messages in the valid formats listed in point #4. You must absolutely not include any other content, such as \`[scene description]\`, \`(inner thoughts)\`, \`*actions*\`, or any explanatory text outside of the specified formats.\n`;
            prompt += `   - Maintain the continuity of the conversation; do not end it proactively.\n\n`;
            prompt += `Now, based on the settings above, please begin playing all the characters in the group chat.`;

            return prompt;
        }

        async function getAiReply() {
            if (isGenerating) return;
            
            
            const currentProvider = db.apiSettings?.currentProvider;
            const settings = db.apiSettings?.[currentProvider];
            const { url, key, model } = settings || {};
            
            if (!url || !key || !model || !currentProvider) {
                showToast('먼저 "API" 앱에서 설정을 완료해주세요!');
                switchScreen('api-settings-screen');
                return;
            }
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            if (!chat) return;
            isGenerating = true;
            getReplyBtn.disabled = true;
            const typingName = currentChatType === 'private' ? chat.remarkName : chat.name;
            typingIndicator.textContent = `"${typingName}"님이 입력 중...`;
            typingIndicator.style.display = 'block';
            messageArea.scrollTop = messageArea.scrollHeight;
            try {
                let systemPrompt, requestBody;
                if (currentChatType === 'private') { systemPrompt = generatePrivateSystemPrompt(chat); }
                else { systemPrompt = generateGroupSystemPrompt(chat); }
                const historySlice = chat.history.slice(-chat.maxMemory);
                if (currentProvider === 'gemini') {
                    const contents = historySlice.map(msg => {
                        const role = msg.role === 'assistant' ? 'model' : 'user';
                        let parts;
                        if (msg.parts && msg.parts.length > 0) {
                            parts = msg.parts.map(p => {
                                if (p.type === 'text') { return { text: p.text }; }
                                else if (p.type === 'image') {
                                    const match = p.data.match(/^data:(image\/(.+));base64,(.*)$/);
                                    if (match) { return { inline_data: { mime_type: match[1], data: match[3] } }; }
                                }
                                return null;
                            }).filter(p => p);
                        } else {
                            parts = [{ text: msg.content }];
                        }
                        return { role, parts };
                    });
                    requestBody = { contents: contents, system_instruction: { parts: [{ text: systemPrompt }] }, generationConfig: {} };
                } else {
                    const messages = [{ role: 'system', content: systemPrompt }];
                    historySlice.forEach(msg => {
                        let content;
                        if (msg.parts && msg.parts.length > 0) {
                            
                            if (currentProvider === 'deepseek') {
                                content = msg.parts.map(p => {
                                    if (p.type === 'text') { return p.text; }
                                    else if (p.type === 'image') { return `[이미지: ${p.data.substring(0, 50)}...]`; }
                                    return '';
                                }).filter(p => p).join(' ');
                            } else {
                                
                                content = msg.parts.map(p => {
                                    if (p.type === 'text') { return { type: 'text', text: p.text }; }
                                    else if (p.type === 'image') { return { type: 'image_url', image_url: { url: p.data } }; }
                                    return null;
                                }).filter(p => p);
                            }
                        } else { content = msg.content; }
                        messages.push({ role: msg.role, content: content });
                    });
                    requestBody = { model: model, messages: messages, stream: true };
                }

                if (url.endsWith('/')) {
                    url = url.slice(0, -1);
                }

                const endpoint = (currentProvider === 'gemini') ? `${url}/v1beta/models/${model}:streamGenerateContent?key=${getRandomValue(key)}` : `${url}/v1/chat/completions`;
                let headers;
                if (currentProvider === 'gemini') {
                    headers = { 'Content-Type': 'application/json' };
                } else if (currentProvider === 'claude') {
                    headers = {
                        'Content-Type': 'application/json',
                        'x-api-key': key,
                        'anthropic-version': '2023-06-01',
                        'anthropic-dangerous-direct-browser-access': 'true'
                    };
                } else {
                    headers = { 'Content-Type': 'application/json', 'Authorization': `Bearer ${key}` };
                }
                const response = await fetch(endpoint, { method: 'POST', headers: headers, body: JSON.stringify(requestBody) });
                if (!response.ok) throw new Error(`API 오류: ${response.status} ${await response.text()}`);
                await processStream(response, chat, currentProvider);
            } catch (error) {
                console.error('AI 응답 실패:', error);
                showToast(`AI 응답 실패: ${error.message}`);
            } finally {
                isGenerating = false;
                getReplyBtn.disabled = false;
                typingIndicator.style.display = 'none';
            }
        }

        // --- START: 이 함수 전체를 아래의 코드로 교체하세요 ---
// --- START: 이 함수 전체를 아래의 코드로 완전히 교체하세요 ---
        async function processStream(response, originalChat, apiType) {
            const reader = response.body.getReader(), decoder = new TextDecoder();
            let fullResponse = "", accumulatedChunk = "";
            for (;;) {
                const { done, value } = await reader.read();
                if (done) break;
                accumulatedChunk += decoder.decode(value, { stream: true });
                
                if (apiType === "openai" || apiType === "deepseek" || apiType === "claude" || apiType === "newapi" || apiType === "openrouter") {
                    const parts = accumulatedChunk.split("\n\n");
                    accumulatedChunk = parts.pop();
                    for (const part of parts) {
                        if (part.startsWith("data: ")) {
                            const data = part.substring(6);
                            if (data.trim() !== "[DONE]") {
                                try { fullResponse += JSON.parse(data).choices[0].delta?.content || ""; } catch (e) {  }
                            }
                        }
                    }
                }
            }
            if (apiType === "gemini") {
                try {
                    const parsedStream = JSON.parse(accumulatedChunk);
                    fullResponse = parsedStream.map(item => item.candidates?.[0]?.content?.parts?.[0]?.text || "").join('');
                } catch (e) {
                    console.error("Gemini 스트림 파싱 오류:", e, "Chunk:", accumulatedChunk);
                    showToast("Gemini 응답 파싱 실패");
                    return;
                }
            }

            if (fullResponse) {
                const messagesToAdd = []; 
                const isPrivateChat = !originalChat.members;

                if (isPrivateChat) {
                    const character = originalChat;
                    const myName = character.myName;
                    
                    const messageRegex = new RegExp(`\\[${character.realName}(?:님의 (?:메시지|음성|송금|사진|영상|사진\\/영상|선물|이모티콘)|님이 보낸 (?:이모티콘|사진\\/영상|선물)):[\\s\\S]+?\\]|\\[${character.realName}님이 ${myName}님의 송금을 (?:수령|반환)했습니다\\]|\\[${character.realName}님이 선물을 수령했습니다\\]|\\[${character.realName}님이 현재 상태를 업데이트:.*?\\]`, "g");
                    const messages = fullResponse.match(messageRegex) || [];
                    
                    if (messages.length > 0) {
                        messages.forEach(msgContent => {
                            const message = { id: `msg_${Date.now()}_${Math.random()}`, role: 'assistant', content: msgContent.trim(), parts: [{ type: 'text', text: msgContent.trim() }], timestamp: Date.now() };
                            messagesToAdd.push(message); 
                        });
                    } else if (fullResponse.trim()) {
                        const simpleMessage = { id: `msg_${Date.now()}_${Math.random()}`, role: 'assistant', content: `[${character.realName}님의 메시지:${fullResponse}]`, parts: [{ type: 'text', text: `[${character.realName}님의 메시지:${fullResponse}]` }], timestamp: Date.now() };
                        messagesToAdd.push(simpleMessage);
                    }
                } else { 
                    const group = originalChat;
                    const memberRealNames = group.members.map(m => m.realName.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'));
                    const memberRegex = new RegExp(`\\[(${memberRealNames.join('|')})(?:님의 (?:메시지|음성|사진|영상|사진\\/영상|선물|이모티콘)|님이 보낸 (?:이모티콘|사진\\/영상|선물)):[\\s\\S]+?\\]`, "g");
                    const messages = fullResponse.match(memberRegex) || [];

                    if (messages.length > 0) {
                        messages.forEach(msgContent => {
                            const nameMatch = msgContent.match(/\[(.*?)((?:님의 (?:메시지|음성|사진|영상|사진\/영상|선물|이모티콘)|님이 보낸 (?:이모티콘|사진\/영상|선물))):/);
                            if (nameMatch) {
                                const senderName = nameMatch[1];
                                const sender = group.members.find(m => m.realName === senderName);
                                if (sender) {
                                    const message = { id: `msg_${Date.now()}_${Math.random()}`, role: 'assistant', content: msgContent.trim(), parts: [{ type: 'text', text: msgContent.trim() }], timestamp: Date.now(), senderId: sender.id };
                                    messagesToAdd.push(message);
                                }
                            }
                        });
                    } else if (fullResponse.trim()) {
                        const firstMember = group.members[Math.floor(Math.random() * group.members.length)];
                        if (firstMember) {
                            const simpleMessageContent = `[${firstMember.realName}님의 메시지:${fullResponse}]`;
                            const simpleMessage = { id: `msg_${Date.now()}_${Math.random()}`, role: 'assistant', content: simpleMessageContent, parts: [{ type: 'text', text: simpleMessageContent }], timestamp: Date.now(), senderId: firstMember.id };
                            messagesToAdd.push(simpleMessage);
                        }
                    }
                }

                // ▼▼▼▼▼ 최종 수정된 로직 ▼▼▼▼▼
                if (messagesToAdd.length > 0) {
                    if (currentChatId === originalChat.id) {
                        // 채팅방이 열려 있을 때: 한 개씩 순서대로 기록하고 화면에 그립니다.
                        messagesToAdd.forEach(msg => {
                            originalChat.history.push(msg); // 1. 메시지 한 개를 history에 추가
                            addMessageBubble(msg);          // 2. 추가된 메시지를 화면에 그림 (이 함수가 그룹화/시간숨김/아바타표시 모두 처리)
                        });
                    } else {
                        // 채팅방이 닫혀 있을 때: 한꺼번에 기록하고 안 읽은 메시지 수만 올립니다.
                        originalChat.history.push(...messagesToAdd);
                        originalChat.unreadCount = (originalChat.unreadCount || 0) + messagesToAdd.length;
                    }
                }
                // ▲▲▲▲▲ 최종 수정된 로직 ▲▲▲▲▲

                saveData();
                renderChatList();
            }
        }
// --- END: 함수 교체 ---

        function setupStickerSystem() {
            stickerToggleBtn.addEventListener('click', () => {
                stickerModal.classList.toggle('visible');
                if (stickerModal.classList.contains('visible')) { renderStickerGrid(); }
            });
            addNewStickerBtn.addEventListener('click', () => {
                addStickerModalTitle.textContent = '새 이모티콘 추가';
                addStickerForm.reset();
                stickerEditIdInput.value = '';
                stickerPreview.innerHTML = '<span>미리보기</span>';
                stickerUrlInput.disabled = false;
                addStickerModal.classList.add('visible');
                
                
                document.getElementById('bulk-sticker-input').value = '';
                document.getElementById('bulk-preview-container').style.display = 'none';
                showStickerTab('single'); 
            });
            
            
            setupStickerTabs();
            addStickerForm.addEventListener('submit', (e) => {
                e.preventDefault();
                const name = stickerNameInput.value.trim();
                const id = stickerEditIdInput.value;
                const previewImg = stickerPreview.querySelector('img');
                const data = previewImg ? previewImg.src : null;
                if (!name || !data) { return showToast('이모티콘 이름을 입력하고 이미지를 제공해주세요'); }
                const stickerData = { name, data };
                if (id) {
                    const index = db.myStickers.findIndex(s => s.id === id);
                    if (index > -1) { db.myStickers[index] = { ...db.myStickers[index], ...stickerData }; }
                } else {
                    stickerData.id = `sticker_${Date.now()}`;
                    db.myStickers.push(stickerData);
                }
                saveData();
                renderStickerGrid();
                addStickerModal.classList.remove('visible');
                showToast('이모티콘이 저장되었습니다');
            });
            stickerUrlInput.addEventListener('input', (e) => {
                stickerPreview.innerHTML = `<img src="${e.target.value}" alt="미리보기">`;
                stickerFileUpload.value = '';
            });
            stickerFileUpload.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, { quality: 0.8, maxWidth: 200, maxHeight: 200 });
                        stickerPreview.innerHTML = `<img src="${compressedUrl}" alt="미리보기">`;
                        stickerUrlInput.value = '';
                        stickerUrlInput.disabled = true;
                    } catch (error) {
                        console.error('이모티콘 압축 실패:', error);
                        showToast('이모티콘 압축 실패, 다시 시도해주세요');
                    }
                }
            });
            editStickerBtn.addEventListener('click', () => {
                if (!currentStickerActionTarget) return;
                const sticker = db.myStickers.find(s => s.id === currentStickerActionTarget);
                if (sticker) {
                    addStickerModalTitle.textContent = '이모티콘 편집';
                    stickerEditIdInput.value = sticker.id;
                    stickerNameInput.value = sticker.name;
                    stickerPreview.innerHTML = `<img src="${sticker.data}" alt="미리보기">`;
                    if (sticker.data.startsWith('http')) {
                        stickerUrlInput.value = sticker.data;
                        stickerUrlInput.disabled = false;
                    } else {
                        stickerUrlInput.value = '';
                        stickerUrlInput.disabled = true;
                    }
                    addStickerModal.classList.add('visible');
                }
                stickerActionSheet.classList.remove('visible');
                currentStickerActionTarget = null;
            });
            deleteStickerBtn.addEventListener('click', () => {
                if (!currentStickerActionTarget) return;
                const sticker = db.myStickers.find(s => s.id === currentStickerActionTarget);
                if (sticker) {
                    if (confirm(`정말 “${sticker.name}” 이모티콘을 삭제하시겠습니까?`)) {
                        db.myStickers = db.myStickers.filter(s => s.id !== currentStickerActionTarget);
                        saveData();
                        renderStickerGrid();
                        showToast('이모티콘이 삭제되었습니다');
                    }
                }
                stickerActionSheet.classList.remove('visible');
                currentStickerActionTarget = null;
            });
        }

        
        function setupStickerTabs() {
            
            const singleTab = document.getElementById('single-sticker-tab');
            const bulkTab = document.getElementById('bulk-sticker-tab');
            const previewBtn = document.getElementById('preview-bulk-btn');
            const bulkForm = document.getElementById('bulk-sticker-form');
            
            
            singleTab.addEventListener('click', () => showStickerTab('single'));
            bulkTab.addEventListener('click', () => showStickerTab('bulk'));
            
            
            previewBtn.addEventListener('click', previewBulkStickers);
            
            
            bulkForm.addEventListener('submit', handleBulkStickerSubmit);
        }
        
        function showStickerTab(tabType) {
            
            const singleTab = document.getElementById('single-sticker-tab');
            const bulkTab = document.getElementById('bulk-sticker-tab');
            const singleContent = document.getElementById('single-sticker-content');
            const bulkContent = document.getElementById('bulk-sticker-content');
            
            if (tabType === 'single') {
                singleTab.classList.add('active');
                bulkTab.classList.remove('active');
                singleTab.style.borderBottomColor = '#4CAF50';
                bulkTab.style.borderBottomColor = 'transparent';
                singleContent.style.display = 'block';
                bulkContent.style.display = 'none';
            } else {
                singleTab.classList.remove('active');
                bulkTab.classList.add('active');
                singleTab.style.borderBottomColor = 'transparent';
                bulkTab.style.borderBottomColor = '#4CAF50';
                singleContent.style.display = 'none';
                bulkContent.style.display = 'block';
            }
        }
        
        function parseBulkStickerInput(inputText) {
            const result = [];
            const cleanInput = inputText.trim(); 
            
            if (!cleanInput) {
                return result;
            }
            
            
            let lines = cleanInput.split(/\r\n|\r|\n/);
            
            
            if (lines.length === 1) {
                lines = cleanInput.split(/[,;|]/); 
            }
            
            lines.forEach((line, index) => {
                const item = line.trim(); 
                if (!item) return; 
                
                
                let urlMatch = item.match(/(https?:\/\/[^\s]+)/i);
                if (!urlMatch) {
                    
                    urlMatch = item.match(/(data:image\/[^;]+;base64,[^\s]+)/i);
                }
                if (!urlMatch) {
                    
                    urlMatch = item.match(/(file:\/\/[^\s]+)/i);
                }
                if (!urlMatch) {
                    
                    urlMatch = item.match(/(\.{0,2}\/[^\s]+|[^\s]*\.(jpg|jpeg|png|gif|webp|svg))/i);
                }
                
                if (urlMatch) {
                    const url = urlMatch[1];
                    const urlIndex = item.indexOf(url);
                    const name = item.substring(0, urlIndex).trim(); 
                    
                    if (name && url) {
                        result.push({ name, url });
                    }
                }
            });
            
            return result;
        }
        
        function previewBulkStickers() {
            
            const input = document.getElementById('bulk-sticker-input').value;
            const previewContainer = document.getElementById('bulk-preview-container');
            const previewContent = document.getElementById('bulk-preview-content');
            
            const parsedStickers = parseBulkStickerInput(input);
            
            if (parsedStickers.length === 0) {
                showToast('파싱할 수 있는 이모티콘이 없습니다. 형식을 확인해주세요.');
                previewContainer.style.display = 'none';
                return;
            }
            
            let html = '';
            parsedStickers.forEach((sticker, index) => {
                html += `
                    <div style="display: flex; align-items: center; margin: 5px 0; padding: 5px; background: white; border-radius: 3px;">
                        <img src="${sticker.url}" alt="${sticker.name}" style="width: 30px; height: 30px; margin-right: 10px; object-fit: cover;">
                        <strong>${sticker.name}</strong>
                        <span style="margin-left: 10px; color: #666; font-size: 11px;">${sticker.url}</span>
                    </div>
                `;
            });
            
            previewContent.innerHTML = html;
            previewContainer.style.display = 'block';
            
            showToast(`${parsedStickers.length}개의 이모티콘이 파싱되었습니다.`);
        }
        
        function handleBulkStickerSubmit(e) {
            e.preventDefault();
            
            const input = document.getElementById('bulk-sticker-input').value;
            const parsedStickers = parseBulkStickerInput(input);
            
            if (parsedStickers.length === 0) {
                showToast('등록할 이모티콘이 없습니다. 형식을 확인해주세요.');
                return;
            }
            
            let successCount = 0;
            let duplicateCount = 0;
            
            parsedStickers.forEach(sticker => {
                
                const existing = db.myStickers.find(s => s.name === sticker.name);
                if (existing) {
                    duplicateCount++;
                    return;
                }
                
                
                const newSticker = {
                    id: `sticker_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                    name: sticker.name,
                    data: sticker.url
                };
                
                db.myStickers.push(newSticker);
                successCount++;
            });
            
            if (successCount > 0) {
                saveData();
                renderStickerGrid();
                
                
                addStickerModal.classList.remove('visible');
                
                let message = `${successCount}개의 이모티콘이 등록되었습니다.`;
                if (duplicateCount > 0) {
                    message += ` (${duplicateCount}개 중복 스킵)`;
                }
                showToast(message);
            } else {
                showToast('등록된 이모티콘이 없습니다. (모든 이름이 중복됨)');
            }
        }

        function renderStickerGrid() {
            stickerGridContainer.innerHTML = '';
            if (db.myStickers.length === 0) {
                stickerGridContainer.innerHTML = '<p style="color:#aaa; text-align:center; font-size: 12px;">아직 이모티콘이 없습니다. 추가해보세요!</p>';
                return;
            }
            db.myStickers.forEach(sticker => {
                const item = document.createElement('div');
                item.className = 'sticker-item';
                item.innerHTML = `<img src="${sticker.data}" alt="${sticker.name}"><span>${sticker.name}</span>`;
                item.addEventListener('click', () => sendSticker(sticker));
                item.addEventListener('mousedown', (e) => {
                    if (e.button !== 0) return;
                    e.stopPropagation();
                    longPressTimer = setTimeout(() => { handleStickerLongPress(sticker.id); }, 500);
                });
                item.addEventListener('mouseup', () => clearTimeout(longPressTimer));
                item.addEventListener('mouseleave', () => clearTimeout(longPressTimer));
                item.addEventListener('touchstart', (e) => {
                    e.stopPropagation();
                    longPressTimer = setTimeout(() => { handleStickerLongPress(sticker.id); }, 500);
                });
                item.addEventListener('touchend', () => clearTimeout(longPressTimer));
                item.addEventListener('touchmove', () => clearTimeout(longPressTimer));
                stickerGridContainer.appendChild(item);
            });
        }

        function handleStickerLongPress(stickerId) {
            clearTimeout(longPressTimer);
            currentStickerActionTarget = stickerId;
            stickerActionSheet.classList.add('visible');
        }

        function setupVoiceMessageSystem() {
            voiceMessageBtn.addEventListener('click', () => {
                sendVoiceForm.reset();
                voiceDurationPreview.textContent = '0"';
                sendVoiceModal.classList.add('visible');
            });
            sendVoiceForm.addEventListener('submit', (e) => {
                e.preventDefault();
                sendMyVoiceMessage(voiceTextInput.value.trim());
            });
        }

        
function setupPhotoVideoSystem() {
    const pvImageUpload = document.getElementById('pv-image-upload');
    const pvImagePreview = document.getElementById('pv-image-preview');
    const pvTextInput = document.getElementById('pv-text-input');
    const aiRecogWrapper = document.getElementById('pv-ai-recog-wrapper');
    const aiRecogCheckbox = document.getElementById('pv-ai-recog-checkbox');

    photoVideoBtn.addEventListener('click', () => {
        sendPvForm.reset();
        pvImagePreview.style.backgroundImage = 'none';
        pvImagePreview.innerHTML = '<span>사진/영상 미리보기</span>';
        pvImagePreview.dataset.imageDataUrl = '';
        aiRecogWrapper.style.display = 'none'; 
        pvTextInput.required = true; 
        sendPvModal.classList.add('visible');
    });

    sendPvForm.addEventListener('submit', (e) => {
        e.preventDefault();
        const imageData = pvImagePreview.dataset.imageDataUrl || null;
        const description = pvTextInput.value.trim();
        const useAiRecognition = aiRecogCheckbox.checked;

        
        if (!imageData && !description) {
            return showToast('사진을 첨부하거나 설명을 입력해주세요.');
        }
        if (imageData && useAiRecognition && !description) {
            
        } else if (!description) {
            return showToast('설명을 입력해주세요.');
        }
        
        sendMyPhotoVideo(
            description,
            imageData,
            useAiRecognition
        );
    });

    pvImageUpload.addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (file) {
            try {
                
                const quality = 0.85;
                const maxWidth = 1024;
                const maxHeight = 1024;
                const compressedUrl = await compressImage(file, { quality, maxWidth, maxHeight });
                
                pvImagePreview.style.backgroundImage = `url(${compressedUrl})`;
                pvImagePreview.innerHTML = '';
                pvImagePreview.dataset.imageDataUrl = compressedUrl;

                
                aiRecogWrapper.style.display = 'block';
                pvTextInput.required = false; 

            } catch (error) {
                showToast('이미지 처리 실패, 다시 시도해주세요');
                pvImageUpload.value = '';
            }
        }
    });

    
    aiRecogCheckbox.addEventListener('change', () => {
        if (aiRecogCheckbox.checked) {
            pvTextInput.required = false;
        } else {
            pvTextInput.required = true;
        }
    });
}

        function setupWalletSystem() {
            walletBtn.addEventListener('click', () => {
                if (currentChatType === 'private') {
                    sendTransferForm.reset();
                    sendTransferModal.classList.add('visible');
                } else if (currentChatType === 'group') {
                    currentGroupAction.type = 'transfer';
                    renderGroupRecipientSelectionList('송금 대상');
                    groupRecipientSelectionModal.classList.add('visible');
                }
            });
            sendTransferForm.addEventListener('submit', (e) => {
                e.preventDefault();
                const amount = transferAmountInput.value;
                const remark = transferRemarkInput.value.trim();
                if (amount > 0) { sendMyTransfer(amount, remark); }
                else { showToast('유효한 금액을 입력해주세요'); }
            });
            acceptTransferBtn.addEventListener('click', () => respondToTransfer('received'));
            returnTransferBtn.addEventListener('click', () => respondToTransfer('returned'));
        }

        function handleReceivedTransferClick(messageId) {
            currentTransferMessageId = messageId;
            receiveTransferActionSheet.classList.add('visible');
        }

        function respondToTransfer(action) {
            if (!currentTransferMessageId) return;
            const character = db.characters.find(c => c.id === currentChatId);
            const message = character.history.find(m => m.id === currentTransferMessageId);
            if (message) {
                message.transferStatus = action;
                const cardOnScreen = messageArea.querySelector(`.message-wrapper[data-id="${currentTransferMessageId}"] .transfer-card`);
                if (cardOnScreen) {
                    cardOnScreen.classList.remove('received', 'returned');
                    cardOnScreen.classList.add(action);
                    cardOnScreen.querySelector('.transfer-status').textContent = action === 'received' ? '수령 완료' : '반환됨';
                    cardOnScreen.style.cursor = 'default';
                }
                let contextMessageContent = (action === 'received') ? `[${character.myName}님이 ${character.realName}님의 송금을 수령했습니다]` : `[${character.myName}님이 ${character.realName}님의 송금을 반환했습니다]`;
                const contextMessage = { id: `msg_${Date.now()}`, role: 'user', content: contextMessageContent, parts: [{ type: 'text', text: contextMessageContent }], timestamp: Date.now() };
                character.history.push(contextMessage);
                saveData();
                renderChatList();
            }
            receiveTransferActionSheet.classList.remove('visible');
            currentTransferMessageId = null;
        }

        function setupGiftSystem() {
            giftBtn.addEventListener('click', () => {
                if (currentChatType === 'private') {
                    sendGiftForm.reset();
                    sendGiftModal.classList.add('visible');
                } else if (currentChatType === 'group') {
                    currentGroupAction.type = 'gift';
                    renderGroupRecipientSelectionList('선물 대상');
                    groupRecipientSelectionModal.classList.add('visible');
                }
            });
            sendGiftForm.addEventListener('submit', (e) => {
                e.preventDefault();
                sendMyGift(giftDescriptionInput.value.trim());
            });
        }

        function setupFontSettingsApp() {
            const fontPresetSelector = document.getElementById('font-preset-selector');
            const fontUrlInput = document.getElementById('font-url');
            const fontDescription = document.getElementById('font-description');
            const fontSettingsForm = document.getElementById('font-settings-form');
            const restoreDefaultFontBtn = document.getElementById('restore-default-font-btn');
            const deletePresetBtn = document.getElementById('delete-preset-btn');
            const savePresetBtn = document.getElementById('save-preset-btn');
            const applyFontBtn = document.getElementById('apply-font-btn');
            const newPresetNameInput = document.getElementById('new-preset-name');
            const newPresetDescriptionInput = document.getElementById('new-preset-description');

            
            const currentPresetData = db.globalFontPresets.presets[db.globalFontPresets.currentPreset];
            fontUrlInput.value = currentPresetData ? currentPresetData.url : '';
            
            
            if (!db.globalFontPresets.presets.custom) {
                console.log('ERROR: 커스텀 프리셋이 없습니다!');
                initializeFontPresets(); 
            }
            
            console.log('폰트 설정 앱 초기화:', {
                currentPreset: db.globalFontPresets.currentPreset,
                customPreset: db.globalFontPresets.presets.custom,
                allPresets: Object.keys(db.globalFontPresets.presets)
            });
            
            
            renderFontPresetSelector();
            
            
            const currentPreset = db.globalFontPresets.currentPreset;
            console.log('폰트 설정 앱 - 프리셋 선택 복원:', {
                currentPreset: currentPreset,
                presetExists: !!db.globalFontPresets.presets[currentPreset],
                selectorOptions: Array.from(fontPresetSelector.options).map(opt => opt.value)
            });
            
            if (currentPreset && db.globalFontPresets.presets[currentPreset]) {
                fontPresetSelector.value = currentPreset;
                console.log('프리셋 선택기 값 설정됨:', fontPresetSelector.value);
                fontPresetSelector.dispatchEvent(new Event('change'));
            } else {
                console.log('프리셋 선택 복원 실패 - 기본값 유지');
            }

            
            fontPresetSelector.addEventListener('change', (e) => {
                const selectedKey = e.target.value;
                console.log('폰트 프리셋 선택됨:', selectedKey); 
                
                if (selectedKey === 'custom') {
                    
                    const customPreset = db.globalFontPresets.presets.custom;
                    fontDescription.textContent = customPreset.description;
                    
                    
                    db.globalFontPresets.currentPreset = 'custom';
                    saveData();
                    console.log('커스텀 폰트 선택 - currentPreset을 custom으로 설정');
                    
                    
                    fontUrlInput.value = customPreset.url || '';
                    newPresetNameInput.value = customPreset.name || '커스텀 폰트';
                    newPresetDescriptionInput.value = customPreset.description || '직접 입력한 폰트 URL을 사용합니다';
                    console.log('커스텀 폰트 프리셋 값 복구됨:', customPreset); 
                    
                    
                    applyFontBtn.textContent = '저장 & 폰트 적용';
                    
                    
                    savePresetBtn.textContent = '프리셋 등록';
                    savePresetBtn.disabled = false;
                    deletePresetBtn.disabled = true; 
                    console.log('커스텀 폰트 모드로 전환'); 
                    return;
                }
                
                const selectedPreset = db.globalFontPresets.presets[selectedKey];
                
                if (selectedPreset) {
                    fontDescription.textContent = selectedPreset.description || '설명 없음';
                    
                    db.globalFontPresets.currentPreset = selectedKey;
                    saveData();
                    console.log('프리셋 선택 시 currentPreset 업데이트됨:', selectedKey);
                    
                    
                    fontUrlInput.value = selectedPreset.url || '';
                    newPresetNameInput.value = selectedPreset.name || '';
                    newPresetDescriptionInput.value = selectedPreset.description || '';
                    
                    
                    applyFontBtn.textContent = '폰트 적용';
                    
                    
                    savePresetBtn.textContent = '프리셋 수정';
                    savePresetBtn.disabled = false;
                    deletePresetBtn.disabled = false; 
                    console.log('기존 프리셋 선택됨 - 수정 모드, 삭제 가능:', selectedPreset.name); 
                    
                    
                    if (selectedPreset.url) {
                        applyGlobalFont(selectedPreset.url);
                        console.log('프리셋 폰트 즉시 적용됨:', selectedPreset.name); 
                    }
                }
            });

            
            applyFontBtn.addEventListener('click', () => {
                const fontUrl = fontUrlInput.value.trim();
                if (!fontUrl) {
                    showToast('폰트 URL을 입력해주세요.');
                    return;
                }
                
                const currentPreset = db.globalFontPresets.currentPreset;
                console.log('폰트 적용 버튼 클릭:', {
                    currentPreset: currentPreset,
                    fontUrl: fontUrl,
                    buttonText: applyFontBtn.textContent
                }); 
                
                if (currentPreset === 'custom') {
                    
                    const presetName = newPresetNameInput.value.trim() || '커스텀 폰트';
                    const presetDescription = newPresetDescriptionInput.value.trim() || '직접 입력한 폰트 URL을 사용합니다';
                    
                    
                    db.globalFontPresets.presets.custom.url = fontUrl;
                    db.globalFontPresets.presets.custom.name = presetName;
                    db.globalFontPresets.presets.custom.description = presetDescription;
                    
                    
                    if (db.globalFontPresets.currentPreset !== 'custom') {
                        db.globalFontPresets.currentPreset = 'custom';
                        console.log('currentPreset을 custom으로 설정');
                    }
                    
                    saveData();
                    applyGlobalFont(fontUrl);
                    showToast('커스텀 폰트가 저장 & 적용되었습니다!');
                    console.log('커스텀 프리셋에 저장됨:', db.globalFontPresets.presets.custom); 
                } else {
                    
                    const selectedPreset = db.globalFontPresets.presets[currentPreset];
                    if (selectedPreset && selectedPreset.url) {
                        applyGlobalFont(selectedPreset.url);
                        showToast('폰트가 적용되었습니다!');
                    } else {
                        showToast('선택된 프리셋에 폰트 URL이 없습니다.');
                    }
                }
            });

            
            savePresetBtn.addEventListener('click', () => {
                const fontUrl = fontUrlInput.value.trim();
                const presetName = newPresetNameInput.value.trim();
                const presetDescription = newPresetDescriptionInput.value.trim();
                
                console.log('프리셋 저장/수정 버튼 클릭됨:', {
                    현재선택: db.globalFontPresets.currentPreset,
                    폰트URL: fontUrl,
                    폰트이름: presetName,
                    설명: presetDescription
                }); 
                
                if (!fontUrl) {
                    showToast('폰트 URL을 입력해주세요.');
                    return;
                }
                
                if (!presetName) {
                    showToast('폰트 이름을 입력해주세요.');
                    return;
                }
                
                
                if (presetName === '커스텀 폰트') {
                    showToast('프리셋 이름으로 "커스텀 폰트"는 사용할 수 없습니다. 다른 이름을 입력해주세요.');
                    return;
                }
                
                const currentPreset = db.globalFontPresets.currentPreset;
                
                
                const existingPresetWithSameName = Object.entries(db.globalFontPresets.presets).find(([key, preset]) => {
                    return preset.name === presetName && key !== currentPreset;
                });
                
                if (existingPresetWithSameName) {
                    console.log('이름 중복 발견:', { 
                        입력한이름: presetName, 
                        중복된프리셋: existingPresetWithSameName[0],
                        현재수정중: currentPreset 
                    });
                    showToast(`"${presetName}"은(는) 이미 존재하는 프리셋 이름입니다. 다른 이름을 사용해주세요.`);
                    return;
                }
                
                console.log('프리셋 이름 검증 통과:', presetName);
                
                if (currentPreset === 'custom') {
                    
                    const presetKey = `custom_${Date.now()}`;
                    db.globalFontPresets.presets[presetKey] = {
                        name: presetName,
                        url: fontUrl,
                        description: presetDescription || `${presetName} 폰트`,
                        deletable: true 
                    };
                    
                    
                    db.globalFontPresets.currentPreset = presetKey;
                    
                    saveData();
                    
                    
                    applyGlobalFont(fontUrl);
                    
                    
                    renderFontPresetSelector();
                    showToast(`"${presetName}" 프리셋이 등록되었습니다!`);
                    console.log('새 프리셋 생성 및 등록 완료:', presetKey); 
                } else {
                    
                    db.globalFontPresets.presets[currentPreset] = {
                        name: presetName,
                        url: fontUrl,
                        description: presetDescription || `${presetName} 폰트`
                    };
                    
                    saveData();
                    
                    
                    applyGlobalFont(fontUrl);
                    
                    
                    renderFontPresetSelector();
                    showToast(`"${presetName}" 프리셋이 수정되었습니다!`);
                    console.log('기존 프리셋 수정 완료:', currentPreset); 
                }
            });

            
            deletePresetBtn.addEventListener('click', () => {
                const currentPreset = db.globalFontPresets.currentPreset;
                console.log('프리셋 삭제 버튼 클릭됨:', currentPreset); 
                
                const preset = db.globalFontPresets.presets[currentPreset];
                
                
                if (preset && preset.deletable === false) {
                    showToast('이 프리셋은 삭제할 수 없습니다.');
                    return;
                }
                
                const presetName = preset.name;
                if (confirm(`"${presetName}" 프리셋을 정말 삭제하시겠습니까?`)) {
                    delete db.globalFontPresets.presets[currentPreset];
                    
                    
                    const remainingPresets = Object.keys(db.globalFontPresets.presets);
                    if (remainingPresets.length > 0) {
                        db.globalFontPresets.currentPreset = remainingPresets[0];
                    } else {
                        db.globalFontPresets.currentPreset = 'custom';
                    }
                    
                    saveData();
                    applyGlobalFont('');
                    
                    
                    renderFontPresetSelector();
                    showToast(`"${presetName}" 프리셋이 삭제되었습니다.`);
                    console.log('프리셋 삭제 완료:', currentPreset); 
                }
            });

            
            restoreDefaultFontBtn.addEventListener('click', () => {
                
                applyGlobalFont('');
                showToast('기본 폰트로 복원되었습니다!');
                console.log('기본 폰트로 복원 완료'); 
            });

            
            function renderFontPresetSelector() {
                
                console.log('프리셋 선택기 렌더링 시작');
                
                
                const allPresetOptions = Object.entries(db.globalFontPresets.presets)
                    .filter(([key, preset]) => key !== 'custom') 
                    .sort(([a, presetA], [b, presetB]) => presetA.name.localeCompare(presetB.name, 'ko')) 
                    .map(([key, preset]) => 
                        `<option value="${key}" ${key === db.globalFontPresets.currentPreset ? 'selected' : ''}>${preset.name}</option>`
                    ).join('');
                
                
                const customPreset = db.globalFontPresets.presets.custom;
                const isCustomSelected = db.globalFontPresets.currentPreset === 'custom';
                const customPresetOption = `<option value="custom" ${isCustomSelected ? 'selected' : ''}>${customPreset ? customPreset.name : '커스텀 폰트'}</option>`;
                console.log('커스텀 프리셋 렌더링:', { isCustomSelected, customPreset: customPreset }); 
                
                
                fontPresetSelector.innerHTML = allPresetOptions + customPresetOption;
                
                console.log('프리셋 옵션 구성 완료:', {
                    전체프리셋: allPresetOptions.split('</option>').length - 1,
                    커스텀프리셋: 1
                });
                
                
                const currentPreset = db.globalFontPresets.presets[db.globalFontPresets.currentPreset];
                if (currentPreset) {
                    fontDescription.textContent = currentPreset.description || '설명 없음';
                } else {
                    fontDescription.textContent = '프리셋을 선택해주세요';
                }
                
                
                const currentPresetData = db.globalFontPresets.presets[db.globalFontPresets.currentPreset];
                const isDeletable = currentPresetData && currentPresetData.deletable !== false;
                const isCustomMode = db.globalFontPresets.currentPreset === 'custom';
                deletePresetBtn.disabled = !isDeletable;
                
                
                if (isCustomMode) {
                    savePresetBtn.textContent = '프리셋 등록';
                } else {
                    savePresetBtn.textContent = '프리셋 수정';
                }
                
                console.log('버튼 상태 업데이트:', {
                    현재선택: db.globalFontPresets.currentPreset,
                    커스텀모드: isCustomMode,
                    삭제가능: isDeletable,
                    삭제버튼비활성화: !isDeletable,
                    저장버튼텍스트: savePresetBtn.textContent
                });
            }
        }

        function applyGlobalFont(fontUrl) {
            console.log('🔤 폰트 적용 시작:', fontUrl); 
            
            
            const existingStyle = document.getElementById('global-font-style');
            if (existingStyle) {
                existingStyle.remove();
            }
            
            
            const existingLinks = document.querySelectorAll('link[data-custom-font]');
            existingLinks.forEach(link => link.remove());
            
            if (fontUrl) {
                const fontName = 'CustomGlobalFont';
                console.log('🔤 커스텀 폰트 적용:', fontName); 
                
                
                if (fontUrl.includes('.css') || fontUrl.includes('fonts.googleapis.com')) {
                    
                    console.log('🔤 CSS 파일로 처리:', fontUrl); 
                    
                    const linkElement = document.createElement('link');
                    linkElement.rel = 'stylesheet';
                    linkElement.href = fontUrl;
                    linkElement.setAttribute('data-custom-font', 'true');
                    document.head.appendChild(linkElement);
                    
                    
                    linkElement.onload = () => {
                        console.log('🔤 CSS 로드 완료, 폰트 적용'); 
                        
                        
                        let actualFontName = fontName;
                        if (fontUrl.includes('fonts.googleapis.com')) {
                            if (fontUrl.includes('Noto+Sans+KR')) {
                                actualFontName = 'Noto Sans KR';
                            } else if (fontUrl.includes('Nanum+Gothic')) {
                                actualFontName = 'Nanum Gothic';
                            } else if (fontUrl.includes('Nanum+Myeongjo')) {
                                actualFontName = 'Nanum Myeongjo';
                            } else if (fontUrl.includes('Nanum+Pen+Script')) {
                                actualFontName = 'Nanum Pen Script';
                            } else if (fontUrl.includes('Single+Day')) {
                                actualFontName = 'Single Day';
                            } else if (fontUrl.includes('Gugi')) {
                                actualFontName = 'Gugi';
                            } else if (fontUrl.includes('Jua')) {
                                actualFontName = 'Jua';
                            } else if (fontUrl.includes('Do+Hyeon')) {
                                actualFontName = 'Do Hyeon';
                            } else if (fontUrl.includes('Black+Han+Sans')) {
                                actualFontName = 'Black Han Sans';
                            } else if (fontUrl.includes('Sunflower')) {
                                actualFontName = 'Sunflower';
                            } else if (fontUrl.includes('Gamja+Flower')) {
                                actualFontName = 'Gamja Flower';
                            } else if (fontUrl.includes('Hi+Melody')) {
                                actualFontName = 'Hi Melody';
                            } else if (fontUrl.includes('Yeon+Sung')) {
                                actualFontName = 'Yeon Sung';
                            } else if (fontUrl.includes('Dongle')) {
                                actualFontName = 'Dongle';
                            } else if (fontUrl.includes('IBM+Plex+Sans+KR')) {
                                actualFontName = 'IBM Plex Sans KR';
                            }
                        }
                        
                        console.log('🔤 실제 폰트명:', actualFontName); 
                        applyFontFamily(actualFontName);
                    };
                    
                    
                    linkElement.onerror = () => {
                        console.log('🔤 CSS 로드 실패, 기본 폰트 사용'); 
                        applyFontFamily('Arial');
                    };
                    
                } else {
                    
                    console.log('🔤 폰트 파일로 처리:', fontUrl); 
                    
                    const styleElement = document.createElement('style');
                    styleElement.id = 'global-font-style';
                    styleElement.innerHTML = `@font-face { 
                        font-family: '${fontName}'; 
                        src: url('${fontUrl}') format('woff2'), url('${fontUrl}') format('woff'), url('${fontUrl}') format('ttf'); 
                    }`;
                    document.head.appendChild(styleElement);
                    
                    
                    setTimeout(() => {
                        applyFontFamily(fontName);
                    }, 100);
                }
                
            } else {
                console.log('🔤 기본 폰트로 복원'); 
                applyFontFamily('Arial');
            }
        }
        
        function applyFontFamily(fontName) {
            console.log('🔤 폰트 패밀리 적용:', fontName); 
            
            
            document.documentElement.style.setProperty('--font-family', `'${fontName}', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif`);
            
            
            document.body.style.fontFamily = `'${fontName}', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif`;
            
            
            document.body.offsetHeight;
            
            console.log('🔤 폰트 적용 완료'); 
        }

        function setupWorldBookApp() {
            addWorldBookBtn.addEventListener('click', () => {
                currentEditingWorldBookId = null;
                editWorldBookForm.reset();
                document.querySelector('input[name="world-book-position"][value="before"]').checked = true;
                switchScreen('edit-world-book-screen');
            });
            editWorldBookForm.addEventListener('submit', (e) => {
                e.preventDefault();
                const name = worldBookNameInput.value.trim();
                const content = worldBookContentInput.value.trim();
                const position = document.querySelector('input[name="world-book-position"]:checked').value;
                if (!name || !content) return showToast('이름과 내용은 비워둘 수 없습니다');
                if (currentEditingWorldBookId) {
                    const book = db.worldBooks.find(wb => wb.id === currentEditingWorldBookId);
                    if (book) {
                        book.name = name;
                        book.content = content;
                        book.position = position;
                    }
                } else {
                    db.worldBooks.push({ id: `wb_${Date.now()}`, name, content, position });
                }
                saveData();
                showToast('세계관 항목이 저장되었습니다');
                renderWorldBookList();
                switchScreen('world-book-screen');
            });
            worldBookListContainer.addEventListener('click', e => {
                const item = e.target.closest('.world-book-item');
                if (item) {
                    const book = db.worldBooks.find(wb => wb.id === item.dataset.id);
                    if (book) {
                        currentEditingWorldBookId = book.id;
                        worldBookIdInput.value = book.id;
                        worldBookNameInput.value = book.name;
                        worldBookContentInput.value = book.content;
                        document.querySelector(`input[name="world-book-position"][value="${book.position}"]`).checked = true;
                        switchScreen('edit-world-book-screen');
                    }
                }
            });
            worldBookListContainer.addEventListener('mousedown', (e) => {
                if (e.button !== 0) return;
                const item = e.target.closest('.world-book-item');
                if (!item) return;
                longPressTimer = setTimeout(() => {
                    const bookId = item.dataset.id;
                    const menuItems = [{
                        label: '삭제',
                        danger: true,
                        action: () => {
                            if (confirm('이 세계관 항목을 정말 삭제하시겠습니까?')) {
                                db.worldBooks = db.worldBooks.filter(wb => wb.id !== bookId);
                                db.characters.forEach(char => { char.worldBookIds = (char.worldBookIds || []).filter(id => id !== bookId); });
                                db.groups.forEach(group => { group.worldBookIds = (group.worldBookIds || []).filter(id => id !== bookId); });
                                saveData();
                                renderWorldBookList();
                                showToast('항목이 삭제되었습니다');
                            }
                        }
                    }];
                    createContextMenu(menuItems, e.clientX, e.clientY);
                }, 500);
            });
            worldBookListContainer.addEventListener('mouseup', () => clearTimeout(longPressTimer));
            worldBookListContainer.addEventListener('mouseleave', () => clearTimeout(longPressTimer));
        }

        function renderWorldBookList() {
            worldBookListContainer.innerHTML = '';
            noWorldBooksPlaceholder.style.display = db.worldBooks.length === 0 ? 'block' : 'none';
            db.worldBooks.forEach(book => {
                const li = document.createElement('li');
                li.className = 'list-item world-book-item';
                li.dataset.id = book.id;
                li.innerHTML = `<div class="item-details" style="padding-left: 20px;"><div class="item-name">${book.name}</div><div class="item-preview">${book.content}</div></div>`;
                worldBookListContainer.appendChild(li);
            });
        }

        function setupChatSettings() {
            const themeSelect = document.getElementById('setting-theme-color');
            themeSelect.innerHTML = '';
            Object.keys(colorThemes).forEach(key => {
                const option = document.createElement('option');
                option.value = key;
                option.textContent = colorThemes[key].name;
                themeSelect.appendChild(option);
            });
            chatSettingsBtn.addEventListener('click', () => {
                if (currentChatType === 'private') {
                    loadSettingsToSidebar();
                    settingsSidebar.classList.add('open');
                } else if (currentChatType === 'group') {
                    loadGroupSettingsToSidebar();
                    groupSettingsSidebar.classList.add('open');
                }
            });
            document.querySelector('.phone-screen').addEventListener('click', e => {
                const openSidebar = document.querySelector('.settings-sidebar.open');
                if (openSidebar && !openSidebar.contains(e.target) && !chatSettingsBtn.contains(e.target) && !e.target.closest('.modal-overlay') && !e.target.closest('.action-sheet-overlay')) {
                    openSidebar.classList.remove('open');
                }
            });

            settingsForm.addEventListener('submit', e => {
                e.preventDefault();
                saveSettingsFromSidebar();
                settingsSidebar.classList.remove('open');
            });
            const useCustomCssCheckbox = document.getElementById('setting-use-custom-css'), customCssTextarea = document.getElementById('setting-custom-bubble-css'), resetCustomCssBtn = document.getElementById('reset-custom-bubble-css-btn'), privatePreviewBox = document.getElementById('private-bubble-css-preview');
            useCustomCssCheckbox.addEventListener('change', (e) => {
                customCssTextarea.disabled = !e.target.checked;
                const char = db.characters.find(c => c.id === currentChatId);
                if (char) {
                    const themeKey = char.theme || 'white_pink';
                    const theme = colorThemes[themeKey];
                    updateBubbleCssPreview(privatePreviewBox, customCssTextarea.value, !e.target.checked, theme);
                }
            });
            customCssTextarea.addEventListener('input', (e) => {
                const char = db.characters.find(c => c.id === currentChatId);
                if (char && useCustomCssCheckbox.checked) {
                    const themeKey = char.theme || 'white_pink';
                    const theme = colorThemes[themeKey];
                    updateBubbleCssPreview(privatePreviewBox, e.target.value, false, theme);
                }
            });
            resetCustomCssBtn.addEventListener('click', () => {
                const char = db.characters.find(c => c.id === currentChatId);
                if (char) {
                    customCssTextarea.value = '';
                    useCustomCssCheckbox.checked = false;
                    customCssTextarea.disabled = true;
                    const themeKey = char.theme || 'white_pink';
                    const theme = colorThemes[themeKey];
                    updateBubbleCssPreview(privatePreviewBox, '', true, theme);
                    showToast('스타일이 기본값으로 초기화되었습니다');
                }
            });
            document.getElementById('setting-char-avatar-upload').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, { quality: 0.8, maxWidth: 400, maxHeight: 400 });
                        document.getElementById('setting-char-avatar-preview').src = compressedUrl;
                    } catch (error) { showToast('아바타 압축 실패, 다시 시도해주세요'); }
                }
            });
            document.getElementById('setting-my-avatar-upload').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, { quality: 0.8, maxWidth: 400, maxHeight: 400 });
                        document.getElementById('setting-my-avatar-preview').src = compressedUrl;
                    } catch (error) { showToast('아바타 압축 실패, 다시 시도해주세요'); }
                }
            });
            const chatBgBtn = document.getElementById('setting-chat-bg-btn');
            const chatBgUploadInput = document.getElementById('setting-chat-bg-upload');
            if(chatBgBtn) {
                chatBgBtn.addEventListener('click', () => {
                    chatBgUploadInput.click();
                });
            }
            document.getElementById('setting-chat-bg-upload').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    const char = db.characters.find(c => c.id === currentChatId);
                    if (char) {
                        try {
                            const compressedUrl = await compressImage(file, { quality: 0.85, maxWidth: 1080, maxHeight: 1920 });
                            char.chatBg = compressedUrl;
                            chatRoomScreen.style.backgroundImage = `url(${compressedUrl})`;
                            saveData();
                            showToast('채팅 배경이 변경되었습니다');
                        } catch (error) { showToast('배경 압축 실패, 다시 시도해주세요'); }
                    }
                }
            });
            clearChatHistoryBtn.addEventListener('click', () => {
                const character = db.characters.find(c => c.id === currentChatId);
                if (!character) return;
                if (confirm(`정말 “${character.remarkName}”님과의 모든 채팅 기록을 삭제하시겠습니까? 이 작업은 되돌릴 수 없습니다!`)) {
                    character.history = [];
                    saveData();
                    renderMessages(false, true);
                    renderChatList();
                    settingsSidebar.classList.remove('open');
                    showToast('채팅 기록이 삭제되었습니다');
                }
            });
            linkWorldBookBtn.addEventListener('click', () => {
                const character = db.characters.find(c => c.id === currentChatId);
                if (!character) return;
                worldBookSelectionList.innerHTML = '';
                db.worldBooks.forEach(book => {
                    const li = document.createElement('li');
                    li.className = 'world-book-select-item';
                    const isChecked = (character.worldBookIds || []).includes(book.id);
                    li.innerHTML = `<input type="checkbox" id="wb-select-${book.id}" value="${book.id}" ${isChecked ? 'checked' : ''}><label for="wb-select-${book.id}">${book.name}</label>`;
                    worldBookSelectionList.appendChild(li);
                });
                worldBookSelectionModal.classList.add('visible');
            });

            saveWorldBookSelectionBtn.addEventListener('click', () => {
                const selectedIds = Array.from(worldBookSelectionList.querySelectorAll('input:checked')).map(input => input.value);
                if (currentChatType === 'private') {
                    const character = db.characters.find(c => c.id === currentChatId);
                    if (character) character.worldBookIds = selectedIds;
                } else if (currentChatType === 'group') {
                    const group = db.groups.find(g => g.id === currentChatId);
                    if (group) group.worldBookIds = selectedIds;
                }
                saveData();
                worldBookSelectionModal.classList.remove('visible');
                showToast('세계관 연결이 업데이트되었습니다');
            });
            const hideMyBubblesToggle = document.getElementById('setting-hide-my-bubbles-toggle');
    const hideCharBubblesToggle = document.getElementById('setting-hide-char-bubbles-toggle');
    const fontSizeSlider = document.getElementById('setting-font-size-slider');
    const fontSizeValue = document.getElementById('setting-font-size-value');

    const updatePrivateChatSettings = () => {
        const char = db.characters.find(c => c.id === currentChatId);
        if (char) {
            char.hideMyIcons = hideMyBubblesToggle.checked; // 속성 이름 변경
            char.hideCharIcons = hideCharBubblesToggle.checked; // 속성 이름 변경
            // END: 수정할 부분
            char.fontSize = parseInt(fontSizeSlider.value, 10);
            saveData();
            applyPerChatUISettings();
        }
    };

    hideMyBubblesToggle.addEventListener('change', updatePrivateChatSettings);
    hideCharBubblesToggle.addEventListener('change', updatePrivateChatSettings);

    // setupChatSettings 함수 안에서, 기존 fontSizeSlider 관련 코드를 찾아 아래 내용으로 교체하세요.

    fontSizeSlider.addEventListener('input', () => {
        const newSize = fontSizeSlider.value;
        fontSizeValue.textContent = `${newSize}px`;
        updatePrivateChatSettings();

        // 미리보기 업데이트 코드 추가
        const char = db.characters.find(c => c.id === currentChatId);
        if (char) {
            const privatePreviewBox = document.getElementById('private-bubble-css-preview');
            const customCssTextarea = document.getElementById('setting-custom-bubble-css');
            const useCustomCssCheckbox = document.getElementById('setting-use-custom-css');
            const theme = colorThemes[char.theme || 'white_pink'];
            updateBubbleCssPreview(privatePreviewBox, customCssTextarea.value, !useCustomCssCheckbox.checked, theme, newSize);
        }
    });
}

        function loadSettingsToSidebar() {
            const e = db.characters.find(e => e.id === currentChatId);
            if (e) {
                document.getElementById('setting-char-avatar-preview').src = e.avatar;
                document.getElementById('setting-char-remark').value = e.remarkName;
                document.getElementById('setting-char-persona').value = e.persona;
                document.getElementById('setting-my-avatar-preview').src = e.myAvatar;
                document.getElementById('setting-my-name').value = e.myName;
                document.getElementById('setting-my-persona').value = e.myPersona;
                document.getElementById('setting-theme-color').value = e.theme || 'white_pink';
                document.getElementById('setting-max-memory').value = e.maxMemory;
                const useCustomCssCheckbox = document.getElementById('setting-use-custom-css'), customCssTextarea = document.getElementById('setting-custom-bubble-css'), privatePreviewBox = document.getElementById('private-bubble-css-preview');
                useCustomCssCheckbox.checked = e.useCustomBubbleCss || false;
                customCssTextarea.value = e.customBubbleCss || '';
                customCssTextarea.disabled = !useCustomCssCheckbox.checked;
                const theme = colorThemes[e.theme || 'white_pink'];
                updateBubbleCssPreview(privatePreviewBox, e.customBubbleCss, !e.useCustomBubbleCss, theme);

                document.getElementById('setting-hide-my-bubbles-toggle').checked = !!e.hideMyIcons; // 속성 이름 변경
                document.getElementById('setting-hide-char-bubbles-toggle').checked = !!e.hideCharIcons;
                const fontSize = e.fontSize || 14;
                document.getElementById('setting-font-size-slider').value = fontSize;
                document.getElementById('setting-font-size-value').textContent = `${fontSize}px`;
            }
        }

        function saveSettingsFromSidebar() {
            const e = db.characters.find(e => e.id === currentChatId);
            if (e) {
                e.avatar = document.getElementById('setting-char-avatar-preview').src;
                e.remarkName = document.getElementById('setting-char-remark').value;
                e.persona = document.getElementById('setting-char-persona').value;
                e.myAvatar = document.getElementById('setting-my-avatar-preview').src;
                e.myName = document.getElementById('setting-my-name').value;
                e.myPersona = document.getElementById('setting-my-persona').value;
                e.theme = document.getElementById('setting-theme-color').value;
                e.maxMemory = document.getElementById('setting-max-memory').value;
                e.useCustomBubbleCss = document.getElementById('setting-use-custom-css').checked;
                e.customBubbleCss = document.getElementById('setting-custom-bubble-css').value;
                saveData();
                showToast('설정이 저장되었습니다!');
                chatRoomTitle.textContent = e.remarkName;
                renderChatList();
                updateCustomBubbleStyle(currentChatId, e.customBubbleCss, e.useCustomBubbleCss);
                currentPage = 1;
                renderMessages(false, true);
            }
        }

        function setupApiSettingsApp() {
            const e = document.getElementById('api-form'), t = document.getElementById('fetch-models-btn'), a = document.getElementById('api-model'), n = document.getElementById('api-provider'), r = document.getElementById('api-url'), s = document.getElementById('api-key');
            
            
            if (!db.apiSettings || typeof db.apiSettings.provider === 'string') {
                
                db.apiSettings = {
                    newapi: { url: '', key: '', model: '' },
                    openai: { url: 'https://api.openai.com', key: '', model: '' },
                    deepseek: { url: 'https://api.deepseek.com', key: '', model: '' },
                    claude: { url: 'https://api.anthropic.com', key: '', model: '' },
                    gemini: { url: 'https://generativelanguage.googleapis.com', key: '', model: '' },
                    openrouter: { url: 'https://openrouter.ai/api', key: '', model: '' },
                    currentProvider: 'newapi'
                };
                saveData();
                showToast('API 설정이 새로운 방식으로 초기화되었습니다!');
            }
            
            
            const currentProvider = db.apiSettings.currentProvider || 'newapi';
            n.value = currentProvider;
            loadProviderSettings(currentProvider);
            
            
            function loadProviderSettings(provider) {
                const settings = db.apiSettings[provider] || {};
                const defaultUrls = {
                    newapi: '',
                    openai: 'https://api.openai.com',
                    deepseek: 'https://api.deepseek.com',
                    claude: 'https://api.anthropic.com',
                    gemini: 'https://generativelanguage.googleapis.com',
                    openrouter: 'https://openrouter.ai/api'
                };
                
                r.value = settings.url || defaultUrls[provider] || '';
                s.value = settings.key || '';
                a.innerHTML = settings.model ? `<option value="${settings.model}">${settings.model}</option>` : '<option value="">먼저 모델 목록을 가져오세요</option>';
            }
            
            
            n.addEventListener('change', () => {
                const newProvider = n.value;
                db.apiSettings.currentProvider = newProvider;
                loadProviderSettings(newProvider);
                saveData();
            });
            
            t.addEventListener('click', async () => {
                let o = r.value.trim();
                const l = s.value.trim();
                if (!o || !l) return showToast('API 주소와 키를 먼저 입력해주세요!');
                o.endsWith('/') && (o = o.slice(0, -1));
                const i = 'gemini' === n.value ? `${o}/v1beta/models?key=${getRandomValue(l)}` : `${o}/v1/models`;
                t.classList.add('loading'), t.disabled = !0;
                try {
                    let headers;
                    if (n.value === 'gemini') {
                        headers = {};
                    } else if (n.value === 'claude') {
                        headers = {
                            'x-api-key': l,
                            'anthropic-version': '2023-06-01',
                            'anthropic-dangerous-direct-browser-access': 'true'
                        };
                    } else {
                        headers = { Authorization: `Bearer ${l}` };
                    }
                    
                    const g = await fetch(i, { method: 'GET', headers: headers });
                    if (!g.ok) throw new Error(`네트워크 응답 오류: ${g.status}`);
                    const u = await g.json();
                    let p = [];
                    if (n.value === 'gemini' && u.models) {
                        p = u.models.map(e => e.name.replace('models/', ''));
                    } else if (n.value !== 'gemini' && u.data) {
                        p = u.data.map(e => e.id);
                    }
                    a.innerHTML = '', p.length > 0 ? (window.allModels = p, renderModelList(p), showToast(`${p.length}개 모델을 가져왔습니다!`)) : (a.innerHTML = '<option value="">모델을 찾을 수 없습니다</option>', showToast('모델을 찾을 수 없습니다'))
                } catch (f) {
                    a.innerHTML = '<option value="">가져오기 실패</option>';
                    showToast(`가져오기 실패: ${f.message}`);
                } finally {
                    t.classList.remove('loading'), t.disabled = !1
                }
            });
            e.addEventListener('submit', e => {
                e.preventDefault();
                if (!a.value) return showToast('모델을 선택한 후 저장해주세요!');
                
                
                const currentProvider = n.value;
                db.apiSettings[currentProvider] = {
                    url: r.value,
                    key: s.value,
                    model: a.value
                };
                db.apiSettings.currentProvider = currentProvider;
                
                saveData();
                showToast(`${currentProvider.toUpperCase()} 설정이 저장되었습니다!`);
            });

            
            const modelSearch = document.getElementById('model-search');
            const modelSearchInfo = document.getElementById('model-search-info');
            let searchTimeout;

            
            function renderModelList(models) {
                a.innerHTML = '';
                if (models.length === 0) {
                    a.innerHTML = '<option value="">검색 결과가 없습니다</option>';
                    modelSearchInfo.textContent = '검색 결과가 없습니다';
                    return;
                }
                
                models.forEach(model => {
                    const option = document.createElement('option');
                    option.value = model;
                    option.textContent = model;
                    a.appendChild(option);
                });
                
                modelSearchInfo.textContent = `${models.length}개 모델 표시`;
            }

            
            if (modelSearch) {
                modelSearch.addEventListener('input', (event) => {
                    clearTimeout(searchTimeout);
                    searchTimeout = setTimeout(() => {
                        const searchTerm = event.target.value.toLowerCase().trim();
                        
                        if (!window.allModels || window.allModels.length === 0) {
                            modelSearchInfo.textContent = '먼저 모델 목록을 가져오세요';
                            return;
                        }
                        
                        if (searchTerm === '') {
                            
                            renderModelList(window.allModels);
                        } else {
                            
                            
                            let filteredModels;
                            
                            if (searchTerm.includes('|')) {
                                
                                const orKeywords = searchTerm.split('|').map(keyword => keyword.trim()).filter(keyword => keyword.length > 0);
                                filteredModels = window.allModels.filter(model => {
                                    const modelLower = model.toLowerCase();
                                    return orKeywords.some(keyword => 
                                        modelLower.includes(keyword.toLowerCase())
                                    );
                                });
                            } else {
                                
                                const andKeywords = searchTerm.split(',').map(keyword => keyword.trim()).filter(keyword => keyword.length > 0);
                                filteredModels = window.allModels.filter(model => {
                                    const modelLower = model.toLowerCase();
                                    return andKeywords.every(keyword => 
                                        modelLower.includes(keyword.toLowerCase())
                                    );
                                });
                            }
                            renderModelList(filteredModels);
                        }
                    }, 300); 
                });

                
                modelSearch.addEventListener('keydown', (event) => {
                    if (event.key === 'Escape') {
                        modelSearch.value = '';
                        if (window.allModels) {
                            renderModelList(window.allModels);
                        }
                    }
                });
            }

            
            const toggleApiKeyBtn = document.getElementById('toggle-api-key-btn');
            const apiKeyInput = document.getElementById('api-key');
            
            if (toggleApiKeyBtn && apiKeyInput) {
                toggleApiKeyBtn.addEventListener('click', () => {
                    if (apiKeyInput.type === 'password') {
                        apiKeyInput.type = 'text';
                        toggleApiKeyBtn.textContent = '🔒';
                        toggleApiKeyBtn.title = 'API 키 숨기기';
                    } else {
                        apiKeyInput.type = 'password';
                        toggleApiKeyBtn.textContent = '🔑';
                        toggleApiKeyBtn.title = 'API 키 보기';
                    }
                });
                
                
                toggleApiKeyBtn.title = 'API 키 보기';
            }

            
            const backupBtn = document.getElementById('backup-data-btn');
            const restoreBtn = document.getElementById('restore-data-btn');
            
            if (backupBtn) {
                backupBtn.addEventListener('click', () => {
                    
                    (() => {
                        const KEY = 'gemini-chat-app-db';
                        
                        
                        function pad(n) { return String(n).padStart(2, '0'); }
                        function tsForFilename(d = new Date()) {
                            return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())}_${pad(d.getHours())}${pad(d.getMinutes())}${pad(d.getSeconds())}`;
                        }
                        
                        
                        const arrLen = (x) => Array.isArray(x) ? x.length : 0;
                        
                        
                        function backupGeminiDB() {
                            const raw = localStorage.getItem(KEY);
                            if (raw === null) {
                                alert(`키가 없습니다: ${KEY}`);
                                return;
                            }
                            
                            let parsed = null;
                            try {
                                
                                parsed = JSON.parse(raw);
                            } catch (_) {
                                
                            }
                            
                            
                            const meta = {
                                type: 'gemini-chat-app-db-backup',
                                origin: location.origin,
                                ts: new Date().toISOString(),
                                counts: parsed ? {
                                    characters: arrLen(parsed.characters),
                                    groups: arrLen(parsed.groups),
                                    myStickers: arrLen(parsed.myStickers),
                                    worldBooks: arrLen(parsed.worldBooks),
                                } : null
                            };
                            
                            
                            const dump = {
                                meta,
                                data: parsed ?? {} 
                            };
                            
                            
                            const c = meta.counts || {};
                            const fname = `gemini-db_${tsForFilename()}_c${c.characters ?? 'NA'}_g${c.groups ?? 'NA'}.json`;
                            
                            
                            const blob = new Blob([JSON.stringify(dump, null, 2)], { type: 'application/json' });
                            const a = document.createElement('a');
                            a.href = URL.createObjectURL(blob);
                            a.download = fname;
                            document.body.appendChild(a);
                            a.click();
                            setTimeout(() => {
                                URL.revokeObjectURL(a.href);
                                a.remove();
                            }, 1500);
                            
                            showToast(`백업 완료: ${fname}`);
                        }
                        
                        
                        backupGeminiDB();
                    })();
                });
            }
            
            if (restoreBtn) {
                restoreBtn.addEventListener('click', () => {
                    
                    (() => {
                        const KEY = 'gemini-chat-app-db';
                        const NORMALIZE = true; 
                        
                        
                        function normalize(db) {
                            db = db || {};
                            db.apiSettings = db.apiSettings || {};
                            db.wallpaper = typeof db.wallpaper === 'string' && db.wallpaper ? db.wallpaper : 'https://i.postimg.cc/W4Z9R9x4/ins-1.jpg';
                            db.characters = Array.isArray(db.characters) ? db.characters : [];
                            db.groups = Array.isArray(db.groups) ? db.groups : [];
                            db.myStickers = Array.isArray(db.myStickers) ? db.myStickers : [];
                            db.homeScreenMode = db.homeScreenMode || 'night';
                            db.worldBooks = Array.isArray(db.worldBooks) ? db.worldBooks : [];
                            
                            db.customIcons = db.customIcons || {};
                            db.globalCustomCSS = db.globalCustomCSS || { enabled: true, currentPreset: 'default', presets: { 'default': { name: '기본', css: '', description: '기본 테마' } } };
                            db.globalFontPresets = db.globalFontPresets || { enabled: true, currentPreset: 'custom', presets: {} };
                            
                            db.characters.forEach(c => {
                                if (c.isPinned === undefined) c.isPinned = false;
                                if (c.status === undefined) c.status = '온라인';
                                if (!Array.isArray(c.worldBookIds)) c.worldBookIds = [];
                                if (c.customBubbleCss === undefined) c.customBubbleCss = '';
                                if (c.useCustomBubbleCss === undefined) c.useCustomBubbleCss = false;
                                if (c.unreadCount === undefined) c.unreadCount = 0;
                            });
                            db.groups.forEach(g => {
                                if (g.isPinned === undefined) g.isPinned = false;
                                if (!Array.isArray(g.worldBookIds)) g.worldBookIds = [];
                                if (g.customBubbleCss === undefined) g.customBubbleCss = '';
                                if (g.useCustomBubbleCss === undefined) g.useCustomBubbleCss = false;
                                if (g.unreadCount === undefined) g.unreadCount = 0;
                            });
                            return db;
                        }
                        
                        function pickValueFromDump(incoming, originalText) {
                            
                            if (incoming && typeof incoming === 'object') {
                                
                                if (incoming.meta && incoming.data && typeof incoming.data === 'object') {
                                    return JSON.stringify(NORMALIZE ? normalize(incoming.data) : incoming.data);
                                }
                                
                                if (incoming.meta && typeof incoming.raw === 'string' && incoming.raw.length) {
                                    try {
                                        const parsed = JSON.parse(incoming.raw);
                                        return JSON.stringify(NORMALIZE ? normalize(parsed) : parsed);
                                    } catch {
                                        return incoming.raw; 
                                    }
                                }
                                
                                return JSON.stringify(NORMALIZE ? normalize(incoming) : incoming);
                            }
                            
                            
                            if (typeof originalText === 'string') {
                                try {
                                    const parsed = JSON.parse(originalText);
                                    return JSON.stringify(NORMALIZE ? normalize(parsed) : parsed);
                                } catch {
                                    
                                    return originalText;
                                }
                            }
                            
                            
                            throw new Error('지원하지 않는 입력 형식입니다.');
                        }
                        
                        function runRestore() {
                            const input = document.createElement('input');
                            input.type = 'file';
                            input.accept = '.json,application/json';
                            input.onchange = async () => {
                                const file = input.files[0];
                                if (!file) return;
                                
                                const text = await file.text();
                                let incoming = null;
                                try {
                                    incoming = JSON.parse(text);
                                } catch {
                                    
                                }
                                
                                let valueToStore;
                                try {
                                    valueToStore = pickValueFromDump(incoming, text);
                                } catch (e) {
                                    alert('복원 준비 실패: ' + e.message);
                                    input.remove();
                                    return;
                                }
                                
                                try {
                                    localStorage.setItem(KEY, String(valueToStore));
                                    showToast('복원 완료: ' + KEY);
                                    setTimeout(() => {
                                        location.reload();
                                    }, 1000);
                                } catch (e) {
                                    alert('저장 실패: ' + e);
                                } finally {
                                    input.remove();
                                }
                            };
                            document.body.appendChild(input);
                            input.click();
                        }
                        
                        runRestore();
                    })();
                });
            }
        }

        // 기존 setupWallpaperApp 함수를 찾아 아래 코드로 전체 교체하세요.

function setupWallpaperApp() {
    // 배경화면 기능 설정
    const wallpaperUpload = document.getElementById('wallpaper-upload');
    const wallpaperPreview = document.getElementById('wallpaper-preview');
    wallpaperPreview.style.backgroundImage = `url(${db.wallpaper})`;
    wallpaperPreview.textContent = '';
    wallpaperUpload.addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (file) {
            try {
                const compressedUrl = await compressImage(file, { quality: 0.85, maxWidth: 1080, maxHeight: 1920 });
                db.wallpaper = compressedUrl;
                applyWallpaper(compressedUrl);
                wallpaperPreview.style.backgroundImage = `url(${compressedUrl})`;
                saveData();
                showToast('배경화면이 변경되었습니다!');
            } catch (error) {
                showToast('배경화면 압축 실패, 다시 시도해주세요');
            }
        }
    });

    // 글꼴 기능 설정 (기존 setupFontSettingsApp의 내용)
    setupFontSettingsApp(); 
}

        
        function setupGroupChatSystem() {
            createGroupBtn.addEventListener('click', () => {
                renderMemberSelectionList();
                createGroupModal.classList.add('visible');
            });
            createGroupForm.addEventListener('submit', e => {
                e.preventDefault();
                const selectedMemberIds = Array.from(memberSelectionList.querySelectorAll('input:checked')).map(input => input.value);
                const groupName = groupNameInput.value.trim();
                if (selectedMemberIds.length < 1) return showToast('그룹 멤버를 최소 한 명 선택해주세요.');
                if (!groupName) return showToast('그룹채팅 이름을 입력해주세요.');
                const firstChar = db.characters.length > 0 ? db.characters[0] : null;
                const newGroup = { id: `group_${Date.now()}`, name: groupName, avatar: 'https://i.postimg.cc/fTLCngk1/image.jpg', me: { nickname: firstChar ? firstChar.myName : '나', persona: firstChar ? firstChar.myPersona : '', avatar: firstChar ? firstChar.myAvatar : 'https://i.postimg.cc/GtbTnxhP/o-o-1.jpg' }, members: selectedMemberIds.map(charId => { const char = db.characters.find(c => c.id === charId); return { id: `member_${char.id}`, originalCharId: char.id, realName: char.realName, groupNickname: char.remarkName, persona: char.persona, avatar: char.avatar }; }), theme: 'white_pink', maxMemory: 100, chatBg: '', history: [], isPinned: false, useCustomBubbleCss: false, customBubbleCss: '', worldBookIds: [] };
                db.groups.push(newGroup);
                saveData();
                renderChatList();
                createGroupModal.classList.remove('visible');
                showToast(`그룹채팅 “${groupName}”이(가) 생성되었습니다!`);
            });
            groupSettingsForm.addEventListener('submit', e => {
                e.preventDefault();
                saveGroupSettingsFromSidebar();
                groupSettingsSidebar.classList.remove('open');
            });
            const useGroupCustomCssCheckbox = document.getElementById('setting-group-use-custom-css'), groupCustomCssTextarea = document.getElementById('setting-group-custom-bubble-css'), resetGroupCustomCssBtn = document.getElementById('reset-group-custom-bubble-css-btn'), groupPreviewBox = document.getElementById('group-bubble-css-preview');
            useGroupCustomCssCheckbox.addEventListener('change', (e) => {
                groupCustomCssTextarea.disabled = !e.target.checked;
                const group = db.groups.find(g => g.id === currentChatId);
                if (group) {
                    const theme = colorThemes[group.theme || 'white_pink'];
                    updateBubbleCssPreview(groupPreviewBox, groupCustomCssTextarea.value, !e.target.checked, theme);
                }
            });
            groupCustomCssTextarea.addEventListener('input', (e) => {
                const group = db.groups.find(g => g.id === currentChatId);
                if (group && useGroupCustomCssCheckbox.checked) {
                    const theme = colorThemes[group.theme || 'white_pink'];
                    updateBubbleCssPreview(groupPreviewBox, e.target.value, false, theme);
                }
            });
            resetGroupCustomCssBtn.addEventListener('click', () => {
                const group = db.groups.find(g => g.id === currentChatId);
                if (group) {
                    groupCustomCssTextarea.value = '';
                    useGroupCustomCssCheckbox.checked = false;
                    groupCustomCssTextarea.disabled = true;
                    const theme = colorThemes[group.theme || 'white_pink'];
                    updateBubbleCssPreview(groupPreviewBox, '', true, theme);
                    showToast('스타일이 기본값으로 초기화되었습니다');
                }
            });
            document.getElementById('setting-group-avatar-upload').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, { quality: 0.8, maxWidth: 400, maxHeight: 400 });
                        const group = db.groups.find(g => g.id === currentChatId);
                        if (group) {
                            group.avatar = compressedUrl;
                            document.getElementById('setting-group-avatar-preview').src = compressedUrl;
                        }
                    } catch (error) { showToast('그룹 아바타 압축 실패, 다시 시도해주세요'); }
                }
            });
            document.getElementById('setting-group-chat-bg-upload').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, { quality: 0.85, maxWidth: 1080, maxHeight: 1920 });
                        const group = db.groups.find(g => g.id === currentChatId);
                        if (group) {
                            group.chatBg = compressedUrl;
                            chatRoomScreen.style.backgroundImage = `url(${compressedUrl})`;
                            saveData();
                            showToast('채팅 배경이 변경되었습니다');
                        }
                    } catch (error) { showToast('그룹 채팅 배경 압축 실패, 다시 시도해주세요'); }
                }
            });
            document.getElementById('clear-group-chat-history-btn').addEventListener('click', () => {
                const group = db.groups.find(g => g.id === currentChatId);
                if (!group) return;
                if (confirm(`정말 그룹채팅 “${group.name}”의 모든 채팅 기록을 삭제하시겠습니까? 이 작업은 되돌릴 수 없습니다!`)) {
                    group.history = [];
                    saveData();
                    renderMessages(false, true);
                    renderChatList();
                    groupSettingsSidebar.classList.remove('open');
                    showToast('채팅 기록이 삭제되었습니다');
                }
            });
            groupMembersListContainer.addEventListener('click', e => {
                const memberDiv = e.target.closest('.group-member');
                const addBtn = e.target.closest('.add-member-btn');
                if (memberDiv) { openGroupMemberEditModal(memberDiv.dataset.id); }
                else if (addBtn) { addMemberActionSheet.classList.add('visible'); }
            });
            document.getElementById('edit-member-avatar-preview').addEventListener('click', () => { document.getElementById('edit-member-avatar-upload').click(); });
            document.getElementById('edit-member-avatar-upload').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, { quality: 0.8, maxWidth: 400, maxHeight: 400 });
                        document.getElementById('edit-member-avatar-preview').src = compressedUrl;
                    } catch (error) { showToast('멤버 아바타 압축 실패, 다시 시도해주세요'); }
                }
            });
            editGroupMemberForm.addEventListener('submit', e => {
                e.preventDefault();
                const memberId = document.getElementById('editing-member-id').value;
                const group = db.groups.find(g => g.id === currentChatId);
                const member = group.members.find(m => m.id === memberId);
                if (member) {
                    member.avatar = document.getElementById('edit-member-avatar-preview').src;
                    member.groupNickname = document.getElementById('edit-member-group-nickname').value;
                    member.realName = document.getElementById('edit-member-real-name').value;
                    member.persona = document.getElementById('edit-member-persona').value;
                    saveData();
                    renderGroupMembersInSettings(group);
                    document.querySelectorAll(`.message-wrapper[data-sender-id="${member.id}"] .group-nickname`).forEach(el => { el.textContent = member.groupNickname; });
                    showToast('멤버 정보가 업데이트되었습니다');
                }
                editGroupMemberModal.classList.remove('visible');
            });
            inviteExistingMemberBtn.addEventListener('click', () => {
                renderInviteSelectionList();
                inviteMemberModal.classList.add('visible');
                addMemberActionSheet.classList.remove('visible');
            });
            createNewMemberBtn.addEventListener('click', () => {
                createMemberForGroupForm.reset();
                document.getElementById('create-group-member-avatar-preview').src = 'https://i.postimg.cc/Y96LPskq/o-o-2.jpg';
                createMemberForGroupModal.classList.add('visible');
                addMemberActionSheet.classList.remove('visible');
            });
            document.getElementById('create-group-member-avatar-preview').addEventListener('click', () => { document.getElementById('create-group-member-avatar-upload').click(); });
            document.getElementById('create-group-member-avatar-upload').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, { quality: 0.8, maxWidth: 400, maxHeight: 400 });
                        document.getElementById('create-group-member-avatar-preview').src = compressedUrl;
                    } catch (error) { showToast('새 멤버 아바타 압축 실패, 다시 시도해주세요'); }
                }
            });
            confirmInviteBtn.addEventListener('click', () => {
                const group = db.groups.find(g => g.id === currentChatId);
                if (!group) return;
                const selectedCharIds = Array.from(inviteMemberSelectionList.querySelectorAll('input:checked')).map(input => input.value);
                selectedCharIds.forEach(charId => {
                    const char = db.characters.find(c => c.id === charId);
                    if (char) {
                        const newMember = { id: `member_${char.id}`, originalCharId: char.id, realName: char.realName, groupNickname: char.remarkName, persona: char.persona, avatar: char.avatar };
                        group.members.push(newMember);
                        sendInviteNotification(group, newMember.realName);
                    }
                });
                if (selectedCharIds.length > 0) {
                    saveData();
                    renderGroupMembersInSettings(group);
                    renderMessages(false, true);
                    showToast('새 멤버를 초대했습니다');
                }
                inviteMemberModal.classList.remove('visible');
            });
            createMemberForGroupForm.addEventListener('submit', e => {
                e.preventDefault();
                const group = db.groups.find(g => g.id === currentChatId);
                if (!group) return;
                const newMember = { id: `member_group_only_${Date.now()}`, originalCharId: null, realName: document.getElementById('create-group-member-realname').value, groupNickname: document.getElementById('create-group-member-nickname').value, persona: document.getElementById('create-group-member-persona').value, avatar: document.getElementById('create-group-member-avatar-preview').src, };
                group.members.push(newMember);
                sendInviteNotification(group, newMember.realName);
                saveData();
                renderGroupMembersInSettings(group);
                renderMessages(false, true);
                showToast(`새 멤버 ${newMember.groupNickname}님이 참여했습니다`);
                createMemberForGroupModal.classList.remove('visible');
            });
            document.getElementById('setting-group-my-avatar-upload').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, { quality: 0.8, maxWidth: 400, maxHeight: 400 });
                        document.getElementById('setting-group-my-avatar-preview').src = compressedUrl;
                    } catch(error){ showToast('아바타 압축 실패')}
                }
            });
            confirmGroupRecipientBtn.addEventListener('click', () => {
                const selectedRecipientIds = Array.from(groupRecipientSelectionList.querySelectorAll('input:checked')).map(input => input.value);
                if (selectedRecipientIds.length === 0) {
                    return showToast('받는 사람을 최소 한 명 선택해주세요.');
                }
                currentGroupAction.recipients = selectedRecipientIds;
                groupRecipientSelectionModal.classList.remove('visible');

                if (currentGroupAction.type === 'transfer') {
                    sendTransferForm.reset();
                    sendTransferModal.classList.add('visible');
                } else if (currentGroupAction.type === 'gift') {
                    sendGiftForm.reset();
                    sendGiftModal.classList.add('visible');
                }
            });
            linkGroupWorldBookBtn.addEventListener('click', () => {
                const group = db.groups.find(g => g.id === currentChatId);
                if (!group) return;
                worldBookSelectionList.innerHTML = '';
                db.worldBooks.forEach(book => {
                    const li = document.createElement('li');
                    li.className = 'world-book-select-item';
                    const isChecked = (group.worldBookIds || []).includes(book.id);
                    li.innerHTML = `<input type="checkbox" id="wb-select-group-${book.id}" value="${book.id}" ${isChecked ? 'checked' : ''}><label for="wb-select-group-${book.id}">${book.name}</label>`;
                    worldBookSelectionList.appendChild(li);
                });
                worldBookSelectionModal.classList.add('visible');
            });
            const hideMyBubblesToggle = document.getElementById('setting-group-hide-my-bubbles-toggle');
    const hideCharBubblesToggle = document.getElementById('setting-group-hide-char-bubbles-toggle');
    const fontSizeSlider = document.getElementById('setting-group-font-size-slider');
    const fontSizeValue = document.getElementById('setting-group-font-size-value');

    const updateGroupChatSettings = () => {
        const group = db.groups.find(g => g.id === currentChatId);
        if (group) {
            group.hideMyIcons = hideMyBubblesToggle.checked; // 속성 이름 변경
        group.hideCharIcons = hideCharBubblesToggle.checked;
            group.fontSize = parseInt(fontSizeSlider.value, 10);
            saveData();
            applyPerChatUISettings();
        }
    };

    hideMyBubblesToggle.addEventListener('change', updateGroupChatSettings);
    hideCharBubblesToggle.addEventListener('change', updateGroupChatSettings);

    // setupGroupChatSystem 함수 안에서, 기존 fontSizeSlider 관련 코드를 찾아 아래 내용으로 교체하세요.

    fontSizeSlider.addEventListener('input', () => {
        const newSize = fontSizeSlider.value;
        fontSizeValue.textContent = `${newSize}px`;
        updateGroupChatSettings();
        
        // 미리보기 업데이트 코드 추가
        const group = db.groups.find(g => g.id === currentChatId);
        if(group) {
            const groupPreviewBox = document.getElementById('group-bubble-css-preview');
            const groupCustomCssTextarea = document.getElementById('setting-group-custom-bubble-css');
            const useGroupCustomCssCheckbox = document.getElementById('setting-group-use-custom-css');
            const theme = colorThemes[group.theme || 'white_pink'];
            updateBubbleCssPreview(groupPreviewBox, groupCustomCssTextarea.value, !useGroupCustomCssCheckbox.checked, theme, newSize);
        }
    });
        }

        function renderMemberSelectionList() {
            memberSelectionList.innerHTML = '';
            if (db.characters.length === 0) {
                memberSelectionList.innerHTML = '<li style="color:#aaa; text-align:center; padding: 10px 0;">선택할 수 있는 캐릭터가 없습니다.</li>';
                return;
            }
            db.characters.forEach(char => {
                const li = document.createElement('li');
                li.className = 'member-selection-item';
                li.innerHTML = `<input type="checkbox" id="select-${char.id}" value="${char.id}"><img src="${char.avatar}" alt="${char.remarkName}"><label for="select-${char.id}" style="margin-bottom: 0px">${char.remarkName}</label>`;
                memberSelectionList.appendChild(li);
            });
        }

        function loadGroupSettingsToSidebar() {
            const group = db.groups.find(g => g.id === currentChatId);
            if (!group) return;
            const themeSelect = document.getElementById('setting-group-theme-color');
            if (themeSelect.options.length === 0) {
                Object.keys(colorThemes).forEach(key => {
                    const option = document.createElement('option');
                    option.value = key;
                    option.textContent = colorThemes[key].name;
                    themeSelect.appendChild(option);
                });
            }
            document.getElementById('setting-group-avatar-preview').src = group.avatar;
            document.getElementById('setting-group-name').value = group.name;
            document.getElementById('setting-group-my-avatar-preview').src = group.me.avatar;
            document.getElementById('setting-group-my-nickname').value = group.me.nickname;
            document.getElementById('setting-group-my-persona').value = group.me.persona;
            themeSelect.value = group.theme || 'white_pink';
            document.getElementById('setting-group-max-memory').value = group.maxMemory;
            renderGroupMembersInSettings(group);
            const useGroupCustomCssCheckbox = document.getElementById('setting-group-use-custom-css'), groupCustomCssTextarea = document.getElementById('setting-group-custom-bubble-css'), groupPreviewBox = document.getElementById('group-bubble-css-preview');
            useGroupCustomCssCheckbox.checked = group.useCustomBubbleCss || false;
            groupCustomCssTextarea.value = group.customBubbleCss || '';
            groupCustomCssTextarea.disabled = !useGroupCustomCssCheckbox.checked;
            const theme = colorThemes[group.theme || 'white_pink'];
            updateBubbleCssPreview(groupPreviewBox, group.customBubbleCss, !group.useCustomBubbleCss, theme);
            document.getElementById('setting-group-hide-my-bubbles-toggle').checked = !!group.hideMyIcons; // 속성 이름 변경
document.getElementById('setting-group-hide-char-bubbles-toggle').checked = !!group.hideCharIcons;
    const fontSize = group.fontSize || 14;
    document.getElementById('setting-group-font-size-slider').value = fontSize;
    document.getElementById('setting-group-font-size-value').textContent = `${fontSize}px`;
        }

        function renderGroupMembersInSettings(group) {
            groupMembersListContainer.innerHTML = '';
            group.members.forEach(member => {
                const memberDiv = document.createElement('div');
                memberDiv.className = 'group-member';
                memberDiv.dataset.id = member.id;
                memberDiv.innerHTML = `<img src="${member.avatar}" alt="${member.groupNickname}"><span>${member.groupNickname}</span>`;
                groupMembersListContainer.appendChild(memberDiv);
            });
            const addBtn = document.createElement('div');
            addBtn.className = 'add-member-btn';
            addBtn.innerHTML = `<div class="add-icon">+</div><span>추가</span>`;
            groupMembersListContainer.appendChild(addBtn);
        }

        function renderGroupRecipientSelectionList(actionText) {
            const group = db.groups.find(g => g.id === currentChatId);
            if (!group) return;
            groupRecipientSelectionTitle.textContent = actionText;
            groupRecipientSelectionList.innerHTML = '';
            group.members.forEach(member => {
                const li = document.createElement('li');
                li.className = 'group-recipient-select-item';
                li.innerHTML = `
                        <input type="checkbox" id="recipient-select-${member.id}" value="${member.id}">
                        <label for="recipient-select-${member.id}">
                            <img src="${member.avatar}" alt="${member.groupNickname}">
                            <span>${member.groupNickname}</span>
                        </label>`;
                groupRecipientSelectionList.appendChild(li);
            });
        }

        function saveGroupSettingsFromSidebar() {
            const group = db.groups.find(g => g.id === currentChatId);
            if (!group) return;
            const oldName = group.name;
            const newName = document.getElementById('setting-group-name').value;
            if (oldName !== newName) {
                group.name = newName;
                sendRenameNotification(group, newName);
            }
            group.avatar = document.getElementById('setting-group-avatar-preview').src;
            group.me.avatar = document.getElementById('setting-group-my-avatar-preview').src;
            group.me.nickname = document.getElementById('setting-group-my-nickname').value;
            group.me.persona = document.getElementById('setting-group-my-persona').value;
            group.theme = document.getElementById('setting-group-theme-color').value;
            group.maxMemory = document.getElementById('setting-group-max-memory').value;
            group.useCustomBubbleCss = document.getElementById('setting-group-use-custom-css').checked;
            group.customBubbleCss = document.getElementById('setting-group-custom-bubble-css').value;
            updateCustomBubbleStyle(currentChatId, group.customBubbleCss, group.useCustomBubbleCss);
            saveData();
            showToast('그룹채팅 설정이 저장되었습니다!');
            chatRoomTitle.textContent = group.name;
            renderChatList();
            renderMessages(false, true);
        }

        function openGroupMemberEditModal(memberId) {
            const group = db.groups.find(g => g.id === currentChatId);
            const member = group.members.find(m => m.id === memberId);
            if (!member) return;
            document.getElementById('edit-group-member-title').textContent = `${member.groupNickname} 편집`;
            document.getElementById('editing-member-id').value = member.id;
            document.getElementById('edit-member-avatar-preview').src = member.avatar;
            document.getElementById('edit-member-group-nickname').value = member.groupNickname;
            document.getElementById('edit-member-real-name').value = member.realName;
            document.getElementById('edit-member-persona').value = member.persona;
            editGroupMemberModal.classList.add('visible');
        }

        function renderInviteSelectionList() {
            inviteMemberSelectionList.innerHTML = '';
            const group = db.groups.find(g => g.id === currentChatId);
            if (!group) return;
            const currentMemberCharIds = new Set(group.members.map(m => m.originalCharId));
            const availableChars = db.characters.filter(c => !currentMemberCharIds.has(c.id));
            if (availableChars.length === 0) {
                inviteMemberSelectionList.innerHTML = '<li style="color:#aaa; text-align:center; padding: 10px 0;">초대할 수 있는 새 멤버가 없습니다.</li>';
                confirmInviteBtn.disabled = true;
                return;
            }
            confirmInviteBtn.disabled = false;
            availableChars.forEach(char => {
                const li = document.createElement('li');
                li.className = 'invite-member-select-item';
                li.innerHTML = `<input type="checkbox" id="invite-select-${char.id}" value="${char.id}"><label for="invite-select-${char.id}"><img src="${char.avatar}" alt="${char.remarkName}"><span>${char.remarkName}</span></label>`;
                inviteMemberSelectionList.appendChild(li);
            });
        }

        function sendInviteNotification(group, newMemberRealName) {
            const messageContent = `[${group.me.nickname}님이 ${newMemberRealName}님을 그룹에 초대했습니다]`;
            const message = { id: `msg_${Date.now()}`, role: 'user', content: messageContent, parts: [{ type: 'text', text: messageContent }], timestamp: Date.now(), senderId: 'user_me' };
            group.history.push(message);
        }

        function sendRenameNotification(group, newName) {
            const myName = group.me.nickname;
            const messageContent = `[${myName}님이 그룹 이름을 ‘${newName}’(으)로 변경했습니다]`;
            const message = { id: `msg_${Date.now()}`, role: 'user', content: messageContent, parts: [{ type: 'text', text: messageContent }], timestamp: Date.now() };
            group.history.push(message);
        }

        // --- START: 추가할 JavaScript 함수들 ---
        function setupBottomNav() {
            const navBar = document.getElementById('bottom-nav-bar');
            navBar.addEventListener('click', (e) => {
                const navBtn = e.target.closest('.nav-btn');
                if (!navBtn) return;

                e.preventDefault();
                const targetId = navBtn.dataset.target;
                switchScreen(targetId);
            });
        }

        // 기존 setupFeedScreen 함수를 아래 코드로 교체
        function setupFeedScreen() {
            const dummyFeedData = [
                { userId: 'chan', userName: '찬', avatar: 'https://i.postimg.cc/nzP9sgxr/chan-125.png', image: 'https://picsum.photos/id/1015/600/600', content: '오늘 날씨 정말 좋다! ☀️ 다들 좋은 하루 보내세요~ #일상 #산책', likes: 102, comments: [{user:'user2', text:'사진 너무 예뻐요!'}, {user:'user3', text:'어디에요? 가보고 싶다'}], timestamp: '2시간 전' },
                { userId: 'user2', userName: '고양이집사', avatar: 'https://picsum.photos/id/1025/100/100', image: 'https://picsum.photos/id/219/600/700', content: '우리집 냥이 낮잠자는 중 💤 #고양이 #반려묘', likes: 251, comments: [{user:'chan', text:'귀여워요!'}], timestamp: '어제' },
            ];

            const feedContainer = document.getElementById('feed-container');
            
            function renderFeed() {
                feedContainer.innerHTML = '';
                dummyFeedData.forEach(post => {
                    const postEl = document.createElement('div');
                    postEl.className = 'feed-post';
                    postEl.innerHTML = `
                        <div class="post-header" data-user-id="${post.userId}">
                            <img src="${post.avatar}" alt="${post.userName}" class="post-avatar">
                            <span class="post-author">${post.userName}</span>
                        </div>
                        <div class="post-image">
                            <img src="${post.image}" alt="피드 이미지">
                        </div>
                        <div class="post-actions">
                            <svg viewBox="0 0 24 24"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"></path></svg>
                            <svg viewBox="0 0 24 24"><path d="M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-2 12H6v-2h12v2zm0-3H6V9h12v2zm0-3H6V6h12v2z"></path></svg>
                            <svg viewBox="0 0 24 24"><path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"></path></svg>
                        </div>
                        <div class="post-footer">
                            <div class="post-likes">${post.likes.toLocaleString()}명이 좋아합니다</div>
                            <div class="post-content">
                                <span class="author">${post.userName}</span>
                                <span>${post.content}</span>
                            </div>
                            <div class="view-comments">댓글 ${post.comments.length}개 모두 보기</div>
                            <div class="post-timestamp">${post.timestamp}</div>
                        </div>
                        <div class="comment-input-area">
                             <img src="https://i.postimg.cc/GtbTnxhP/o-o-1.jpg" class="my-avatar">
                             <input type="text" class="comment-input" placeholder="댓글 달기...">
                        </div>
                    `;
                    feedContainer.appendChild(postEl);
                });
            }

            renderFeed();

            feedContainer.addEventListener('click', (e) => {
                const header = e.target.closest('.post-header');
                if (header) {
                    const userId = header.dataset.userId;
                    openProfileScreen(userId);
                }
            });
        }

        // 기존 openProfileScreen 함수를 아래 코드로 교체
        function openProfileScreen(userId) {
            const dummyUserData = {
                'chan': { name: '찬', username: 'chan_photo', bio: '사진 찍는 걸 좋아해요 📸\n일상과 여행 기록', avatar: 'https://i.postimg.cc/nzP9sgxr/chan-125.png', posts: 12, followers: '125K', following: 80, images: ['https://picsum.photos/id/1015/400/400', 'https://picsum.photos/id/10/400/400', 'https://picsum.photos/id/102/400/400', 'https://picsum.photos/id/1024/400/400', 'https://picsum.photos/id/1028/400/400', 'https://picsum.photos/id/103/400/400', 'https://picsum.photos/id/1035/400/400'] },
                'user2': { name: '고양이집사', username: 'cat_lover_22', bio: '고양이와 함께하는 일상', avatar: 'https://picsum.photos/id/1025/100/100', posts: 5, followers: '88K', following: 30, images: ['https://picsum.photos/id/219/400/400', 'https://picsum.photos/id/237/400/400', 'https://picsum.photos/id/274/400/400'] }
            };

            const userData = dummyUserData[userId];
            if (!userData) return;

            document.getElementById('profile-name').textContent = userData.username;
            const profileContainer = document.getElementById('profile-container');
            
            const gridItems = userData.images.map(img => `<div class="grid-item"><img src="${img}" alt="프로필 이미지"></div>`).join('');

            profileContainer.innerHTML = `
                <div class="profile-header">
                    <img src="${userData.avatar}" alt="${userData.name}" class="profile-avatar-lg">
                    <div class="profile-stats">
                        <div class="stat-item"><span class="count">${userData.posts}</span><span class="label">게시물</span></div>
                        <div class="stat-item"><span class="count">${userData.followers}</span><span class="label">팔로워</span></div>
                        <div class="stat-item"><span class="count">${userData.following}</span><span class="label">팔로잉</span></div>
                    </div>
                </div>
                <div class="profile-bio">
                    <p class="name">${userData.name}</p>
                    <p class="bio-text">${userData.bio.replace(/\n/g, '<br>')}</p>
                </div>
                <div class="profile-buttons">
                    <button class="btn btn-follow">팔로우</button>
                    <button class="btn btn-message">메시지</button>
                </div>
                <div class="story-highlights">
                    <div class="highlight-item"><div class="highlight-circle"></div><span>여행</span></div>
                    <div class="highlight-item"><div class="highlight-circle"></div><span>맛집</span></div>
                    <div class="highlight-item"><div class="highlight-circle"></div><span>일상</span></div>
                </div>
                <div class="profile-tabs">
                    <button class="tab-btn active"><svg viewBox="0 0 24 24"><path d="M3 3h8v8H3V3zm10 0h8v8h-8V3zM3 13h8v8H3v-8zm10 13h8v-8h-8v8z"></path></svg></button>
                    <button class="tab-btn"><svg viewBox="0 0 24 24"><path d="M20.54 18.5l-2.93-2.93c.58-1.02.93-2.21.93-3.48C18.54 7.6 15.36 4.5 11 4.5S3.46 7.6 3.46 12s3.18 7.5 7.54 7.5c1.27 0 2.46-.35 3.48-.93l2.93 2.93L18.5 20l2.04-1.5zm-9.54-3c-2.48 0-4.5-2.02-4.5-4.5s2.02-4.5 4.5-4.5 4.5 2.02 4.5 4.5-2.02 4.5-4.5 4.5z"></path></svg></button>
                </div>
                <div class="profile-grid">
                    ${gridItems}
                </div>
            `;
            switchScreen('profile-screen');
        }
        
        init();
    });
	
</script>

</body>


</html>
