<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>문어 잉크 분사기</title>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <link rel="apple-touch-icon" href="https://i.postimg.cc/nzP9sgxr/chan-125.png">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <style>
        /* --- 전역 및 테마 스타일 --- */
        :root {
            --bg-color: #fce4ec;
            --secondary-color: #f8bbd0;
            --secondary-color-hover: #fce4ec;
            --primary-color: #ff80ab;
            --primary-color-hover: #fce4ec;
            --accent-color: #90caf9;
            --accent-color-hover: #90caf9;
            --text-color: #444;
            --white-color: #fff;
            --white-rgb: 255, 255, 255; /* 투명도 줄 때 사용 */
            --border-color: #f0dbe2; /* 테두리 색상 변수 추가 */
            --border-radius: 18px;
            --phone-corner-radius: 0px;
            --font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            --top-pinned-bg: #fff0f5;
            --online-status-color: #4CAF50;
        }

        *,
        *::before,
        *::after {
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-family);
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, var(--bg-color), var(--secondary-color));
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            color: var(--text-color); /* 글자색 변수 추가 */
        }

        .phone-screen {
            width: 100%;
            max-width: 420px;
            height: 100vh;
            max-height: 850px;
            background-color: var(--white-color);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            border-radius: var(--phone-corner-radius);
            overflow: hidden;
            position: relative;
            display: flex;
            flex-direction: column;
        }

        .screen {
            display: none;
            flex-direction: column;
            width: 100%;
            height: 100%;
            animation: fadeIn 0.5s ease;
        }

        .screen.active {
            display: flex;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: scale(0.95);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .app-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 20px;
            background-color: rgba(var(--white-rgb), 0.8); /* 투명 배경에 변수 사용 */
            backdrop-filter: blur(10px);
            border-bottom: 1px solid var(--border-color); /* 테두리 색에 변수 사용 */
            flex-shrink: 0;
            position: relative;
            z-index: 10;
        }

        .app-header .back-btn,
        .app-header .action-btn {
            background: none;
            border: none;
            font-size: 24px;
            font-weight: bold;
            color: var(--primary-color);
            cursor: pointer;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #cancel-multi-select-btn {
            font-size: 14px !important;
            font-weight: 500 !important;
            color: var(--white-color) !important;
            background-color: var(--primary-color) !important;
            border-radius: 10px !important;
            padding: 5px 10px !important;
            width: auto !important;
            height: auto !important;
        }

        .app-header .action-btn-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .app-header .action-btn-group .action-btn {
            font-size: 16px;
            font-weight: 600;
            width: auto;
            padding: 6px 12px;
            border-radius: 10px;
        }

        .app-header .action-btn-group #create-group-btn {
            background-color: var(--primary-color);
            color: var(--white-color);
        }

        .app-header .action-btn-group #add-chat-btn {
            font-size: 28px;
            padding: 0;
            width: 40px;
            height: 40px;
            background-color: transparent;
            color: var(--primary-color);
            border-radius: 50%;
        }

        .app-header .action-btn img {
            width: 28px;
            height: 28px;
        }

        .app-header .title-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
        }

        .app-header .title {
            font-size: 18px;
            font-weight: 600;
            color: var(--text-color);
            margin: 0;
        }

        .app-header .subtitle {
            font-size: 12px;
            color: #888;
            display: flex;
            align-items: center;
            margin-top: 2px;
        }

        .online-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: var(--online-status-color);
            margin-right: 5px;
        }

        .app-header .placeholder {
            width: 40px;
        }

        #home-screen {
            justify-content: space-between;
            background-size: cover;
            background-position: center;
            transition: background-image 0.5s ease-in-out;
            padding: 50px 0;
        }

        .time-widget {
            text-align: center;
            padding: 0 20px;
            color: var(--text-color);
        }

        .time-widget .time {
            font-size: 72px;
            font-weight: 600;
        }

        .time-widget .date {
            font-size: 18px;
            color: #666;
        }

        #home-screen.day-mode .time-widget,
        #home-screen.day-mode .time-widget .date,
        #home-screen.day-mode .app-icon .app-name {
            color: var(--white-color);
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.4);
        }

        .app-grid {
            width: 100%;
            padding: 20px 40px;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            justify-content: center;
            align-content: center;
            margin-top: 40px;
        }

        #home-screen.day-mode .time-widget,
        #home-screen.day-mode .time-widget .date,
        #home-screen.day-mode .app-icon .app-name {
            color: var(--white-color);
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.4);
        }

        .dock {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 10px;
            background-color: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(10px);
            border-radius: var(--border-radius);
            margin: 0 20px;
            min-height: 80px;
            gap: 15px;
        }

        .app-icon {
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
            text-decoration: none;
        }

        .icon-img {
            width: 60px;
            height: 60px;
            border-radius: 15px;
            margin-bottom: 8px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s ease;
            object-fit: cover;
        }

        .app-icon:hover .icon-img {
            transform: translateY(-5px);
        }

        .app-icon .app-name {
            font-size: 12px;
            color: var(--text-color);
            font-weight: 500;
        }

        .content {
            flex-grow: 1;
            overflow-y: auto;
            padding: 20px;
            position: relative;
        }

        .placeholder-text {
            text-align: center;
            color: #aaa;
            margin-top: 50px;
        }

        .modal-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.4);
            z-index: 100;
            display: none;
            align-items: center;
            justify-content: center;
            animation: fadeIn 0.3s ease;
        }

        .modal-overlay.visible {
            display: flex;
        }

        .modal-window {
            background: var(--white-color);
            padding: 25px;
            border-radius: var(--border-radius);
            box-shadow: 0 5px 25px rgba(0, 0, 0, 0.15);
            width: 85%;
            max-width: 340px;
            animation: slideUp 0.4s ease-out;
        }

        .modal-window h3 {
            margin-top: 0;
            text-align: center;
            color: var(--primary-color);
        }

        @keyframes slideUp {
            from {
                transform: translateY(20px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        #edit-group-member-modal,
        #create-member-for-group-modal {
            z-index: 102;
        }

        #edit-group-member-modal .avatar-preview,
        #create-member-for-group-modal .avatar-preview {
            width: 80px;
            height: 80px;
        }

        .context-menu {
            position: fixed;
            z-index: 1000;
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.15);
            overflow: hidden;
            padding: 5px 0;
            animation: fadeIn 0.1s ease;
        }

        .context-menu-item {
            padding: 10px 20px;
            cursor: pointer;
        }

        .context-menu-item:hover {
            background-color: #f5f5f5;
        }

        .context-menu-item.danger {
            color: #e53935;
        }

        .action-sheet-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.4);
            z-index: 200;
            display: none;
            align-items: flex-end;
            animation: fadeIn 0.3s ease;
        }

        .action-sheet-overlay.visible {
            display: flex;
        }

        .action-sheet {
            background: #f7f7f7;
            width: 100%;
            border-top-left-radius: 20px;
            border-top-right-radius: 20px;
            padding: 10px;
            padding-bottom: calc(40px + env(safe-area-inset-bottom));
            animation: slideUp 0.3s ease-out;
        }

        .action-sheet-button {
            width: 100%;
            background: white;
            border: none;
            padding: 15px;
            font-size: 16px;
            color: var(--primary-color);
            font-weight: 500;
            cursor: pointer;
            border-radius: 10px;
            margin-bottom: 8px;
        }

        .action-sheet-button.danger {
            color: #e53935;
        }

        .action-sheet-button:last-child {
            margin-bottom: 0;
        }

        #chat-list-screen .content,
        #world-book-screen .content {
            padding: 10px 0 0 0;
        }

        .list-container {
            list-style: none;
            margin: 0;
            padding: 0;
        }

        .list-item {
            display: flex;
            align-items: center;
            padding: 10px 20px;
            cursor: pointer;
            border-bottom: 1px solid #f0f0f0;
            transition: background-color 0.2s ease;
            position: relative;
        }

        .list-item:hover {
            background-color: var(--secondary-color);
        }

        .chat-item.pinned {
            background-color: var(--top-pinned-bg);
        }

        .chat-avatar {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            margin-right: 15px;
            object-fit: cover;
            flex-shrink: 0;
            background-color: #eee;
        }

        .group-avatar {
            border-radius: 10px;
        }

        .item-details {
            flex-grow: 1;
            overflow: hidden;
        }

        .item-details-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .item-name {
            font-weight: 600;
            color: var(--text-color);
            font-size: 16px;
        }

        .item-preview-wrapper {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 4px;
        }

        .item-preview {
            font-size: 14px;
            color: #888;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            flex-grow: 1;
        }

        .pin-badge {
            background-color: var(--primary-color);
            color: white;
            font-size: 10px;
            font-weight: bold;
            padding: 2px 6px;
            border-radius: 5px;
            white-space: nowrap;
            flex-shrink: 0;
        }

        #chat-room-screen {
            background-size: cover;
            background-position: center;
        }

        #chat-room-screen .content {
            display: flex;
            flex-direction: column;
            padding: 10px;
            padding-bottom: 10px;
            transition: padding-bottom 0.3s ease;
        }

        #chat-room-screen.multi-select-active .content {
            padding-bottom: 70px;
        }

        .message-area {
            flex-grow: 1;
            overflow-y: auto;
            padding: 0 10px;
            scroll-behavior: smooth;
        }

        .message-wrapper {
            display: flex;
            margin-bottom: 12px;
            align-items: flex-start;
            transition: background-color 0.2s;
            flex-direction: column;
        }

        .message-wrapper.group-message {
            margin-bottom: 18px;
        }

        .message-wrapper.sent {
            align-items: flex-end;
        }

        .message-wrapper.received {
            align-items: flex-start;
        }

        .message-wrapper.system-notification {
            align-items: center;
        }

        .message-bubble-row {
            display: flex;
            width: 100%;
            align-items: flex-start;
        }

        .message-wrapper.sent .message-bubble-row {
            flex-direction: row-reverse;
        }

        .message-wrapper.multi-select-selected {
            background-color: rgba(144, 202, 249, 0.2);
            border-radius: var(--border-radius);
        }

        .unread-badge {
            margin-left: auto; 
            background-color: #ff3b30;
            color: white; 
            font-size: 12px;
            font-weight: bold; 
            padding: 2px 7px;
            border-radius: 12px; 
        }

        .global-theme-selector { 
            display: flex; 
            flex-wrap: wrap; 
            justify-content: center; 
            gap: 20px; 
        }

        .global-theme-selector .theme-circle { 
            border: 20px solid var(--border-color); 
            border-radius: 30px;
        }

        .global-theme-selector .theme-circle.selected { 
            border-color: var(--primary-color); 
        }

        .message-info {
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
        }

        .group-nickname {
            position: absolute;
            top: -15px;
            font-size: 11px;
            color: #888;
            white-space: nowrap;
            width: 70px;
            text-align: center;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .message-avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            object-fit: cover;
        }

        .message-time {
            font-size: 9px;
            color: #aaa;
            margin-top: 3px;
        }

        .message-bubble {
            max-width: 260px;
            padding: 8px 12px;
            border-radius: var(--border-radius);
            word-wrap: break-word;
            line-height: 1.4;
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            margin: 0 8px;
            cursor: pointer;
            font-size: 15px;
        }

        .message-bubble.sent {
            border-bottom-right-radius: 5px;
        }

        .message-bubble.received {
            border-bottom-left-radius: 5px;
        }

        .system-notification-bubble {
            background-color: rgba(200, 200, 200, 0.5);
            color: #666;
            font-size: 12px;
            padding: 4px 10px;
            border-radius: 10px;
            text-align: center;
        }

        .image-bubble {
            max-width: 120px;
            border-radius: var(--border-radius);
            margin: 0 8px;
            padding: 4px;
            background-color: rgba(255, 255, 255, 0.5);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            cursor: pointer;
        }

        .image-bubble img {
            width: 100%;
            height: auto;
            display: block;
            border-radius: calc(var(--border-radius) - 4px);
        }

        .message-wrapper.sent .image-bubble {
            border-bottom-right-radius: 5px;
        }

        .message-wrapper.received .image-bubble {
            border-bottom-left-radius: 5px;
        }

        .voice-bubble {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 12px;
            border-radius: var(--border-radius);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            margin: 0 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            min-width: 90px;
            max-width: 200px;
        }

        .message-wrapper.sent .voice-bubble {
            border-bottom-right-radius: 5px;
            flex-direction: row-reverse;
        }

        .message-wrapper.received .voice-bubble {
            border-bottom-left-radius: 5px;
        }

        .voice-bubble .play-icon {
            width: 18px;
            height: 18px;
            flex-shrink: 0;
            transform: rotate(360deg) translateY(1px) !important;
        }

        .voice-bubble .duration {
            font-size: 13px;
            margin: 0 8px;
            white-space: nowrap;
        }

        .message-wrapper.sent .play-icon {
            transform: scaleX(-1);
        }

        .voice-transcript {
            font-size: 14px;
            color: #555;
            background-color: rgba(255, 255, 255, 0.7);
            padding: 8px 12px;
            margin-top: 5px;
            margin-left: 54px;
            margin-right: 54px;
            border-radius: 10px;
            line-height: 1.6;
            max-width: calc(100% - 108px);
            display: none;
            animation: fadeIn 0.3s ease;
        }

        .voice-transcript.active {
            display: block;
        }

        .message-wrapper.sent .voice-transcript {
            align-self: flex-end;
            margin-right: 54px;
            margin-left: auto;
        }

        .message-wrapper.received .voice-transcript {
            align-self: flex-start;
            margin-left: 54px;
            margin-right: auto;
        }

        .pv-card {
            width: 230px;
            aspect-ratio: 1 / 1;
            background-color: #f0f0f0;
            border-radius: var(--border-radius);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            position: relative;
            cursor: pointer;
            margin: 0 8px;
        }

        .message-wrapper.sent .pv-card {
            border-bottom-right-radius: 5px;
        }

        .message-wrapper.received .pv-card {
            border-bottom-left-radius: 5px;
        }

        .pv-card-image-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-size: cover;
            background-position: center;
            transition: opacity 0.5s ease-in-out;
            z-index: 2;
        }

        .pv-card-image-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .pv-card-content {
            padding: 15px;
            height: 100%;
            overflow-y: auto;
            color: var(--text-color);
            line-height: 1.6;
            font-size: 15px;
            background-color: white;
            position: relative;
            z-index: 1;
        }

        .pv-card-footer {
            background: linear-gradient(to top, rgba(0, 0, 0, 0.6), transparent);
            color: white;
            padding: 20px 10px 8px;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 5px;
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            z-index: 3;
            pointer-events: none;
            transition: opacity 0.5s ease-in-out;
        }

        .pv-card-footer.hidden {
            opacity: 0;
        }

        .pv-card-footer svg {
            width: 14px;
            height: 14px;
            fill: white;
            flex-shrink: 0;
        }

        .transfer-card {
            width: 240px;
            height: auto;
            border-radius: var(--border-radius);
            margin: 0 8px;
            overflow: hidden;
            position: relative;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            color: white;
        }

        .message-wrapper.sent .transfer-card {
            border-bottom-right-radius: 5px;
        }

        .message-wrapper.received .transfer-card {
            border-bottom-left-radius: 5px;
            cursor: pointer;
        }

        .transfer-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-size: cover;
            background-position: center;
            filter: blur(4px);
            transform: scale(1.1);
            z-index: 1;
        }

        .transfer-card.sent-transfer::before {
            background-image: url('https://i.postimg.cc/sxN893WF/IMG-20250712.png');
        }

        .transfer-card.received-transfer::before {
            background-image: url('https://i.postimg.cc/FzR8LY7g/IMG-20250712-170703.png');
        }

        .transfer-card .overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.3);
            z-index: 2;
            transition: background-color 0.5s ease;
        }

        .transfer-card.received .overlay {
            background-color: rgba(255, 182, 193, 0.4);
        }

        .transfer-card.returned .overlay {
            background-color: rgba(100, 100, 100, 0.5);
        }

        .transfer-content {
            position: relative;
            z-index: 3;
            padding: 20px;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
        }

        .transfer-title {
            font-size: 14px;
            margin: 0 0 5px 0;
            opacity: 0.9;
        }

        .transfer-amount {
            font-size: 28px;
            font-weight: bold;
            margin: 0;
        }

        .transfer-remark {
            font-size: 14px;
            margin-top: 10px;
            opacity: 0.9;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .transfer-status {
            font-size: 12px;
            margin-top: 15px;
            margin-bottom: 0px;
            padding-top: 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.3);
            opacity: 0.8;
        }

        .gift-card {
            width: 230px;
            background-color: #fff;
            border: 2px solid #333;
            border-radius: var(--border-radius);
            box-shadow: 4px 4px 0px #ddd;
            padding: 10px;
            display: flex;
            align-items: center;
            cursor: pointer;
            margin: 0 8px;
            position: relative;
            overflow: hidden;
        }

        .message-wrapper.sent .gift-card {
            border-bottom-right-radius: 5px;
        }

        .message-wrapper.received .gift-card {
            border-bottom-left-radius: 5px;
        }

        .gift-card-icon {
            width: 50px;
            height: 50px;
            margin-right: 15px;
            flex-shrink: 0;
        }

        .gift-card-text {
            font-size: 16px;
            font-weight: bold;
            color: #333;
            font-family: 'Comic Sans MS', 'Chalkduster', 'Handwriting', cursive;
        }

        .gift-card-description {
            font-size: 14px;
            color: #555;
            background-color: rgba(240, 240, 240, 0.9);
            padding: 8px 12px;
            margin-top: 5px;
            margin-left: 54px;
            margin-right: 54px;
            border-radius: 10px;
            line-height: 1.6;
            max-width: calc(100% - 108px);
            display: none;
            animation: fadeIn 0.3s ease;
        }

        .gift-card-description.active {
            display: block;
        }

        .message-wrapper.sent .gift-card-description {
            align-self: flex-end;
            margin-right: 54px;
            margin-left: auto;
        }

        .message-wrapper.received .gift-card-description {
            align-self: flex-start;
            margin-left: 54px;
            margin-right: auto;
        }

        .gift-card-received-stamp {
            position: absolute;
            top: 5px;
            right: 5px;
            font-size: 14px;
            font-weight: bold;
            color: var(--primary-color);
            border: 2px solid var(--primary-color);
            border-radius: 8px;
            padding: 2px 6px;
            transform: rotate(15deg);
            opacity: 0;
            transition: opacity 0.3s ease;
            font-family: 'Comic Sans MS', 'Chalkduster', 'Handwriting', cursive;
        }

        .gift-card.received .gift-card-received-stamp {
            opacity: 1;
        }

        .load-more-btn {
            background-color: #e0e0e0;
            color: #757575;
            border: none;
            padding: 8px 16px;
            margin: 10px auto;
            border-radius: 15px;
            cursor: pointer;
            display: block;
            font-size: 13px;
            font-weight: 500;
        }

        .load-more-btn:hover {
            background-color: #d1d1d1;
        }

        .typing-indicator {
            text-align: center;
            color: #aaa;
            font-style: italic;
            font-size: 14px;
            padding: 10px 0;
            display: none;
        }

        #sticker-bar {
            flex-shrink: 0;
            padding: 0 10px 5px;
            display: flex;
            align-items: center;
            background: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(10px);
        }

        .sticker-bar-btn {
            background: none;
            border: none;
            padding: 5px;
            cursor: pointer;
        }

        .sticker-bar-btn svg {
            width: 28px;
            height: 28px;
            fill: #888;
        }

        #sticker-modal {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 45%;
            max-height: 450px;
            background: #f7f7f7;
            border-top-left-radius: 20px;
            border-top-right-radius: 20px;
            box-shadow: 0 -5px 15px rgba(0, 0, 0, 0.1);
            z-index: 25;
            display: none;
            flex-direction: column;
        }

        #sticker-modal.visible {
            display: flex;
            animation: slideUp 0.3s ease-out;
        }

        #sticker-modal .header {
            padding: 10px 15px;
            font-weight: bold;
            color: var(--text-color);
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .sticker-grid {
            flex-grow: 1;
            overflow-y: auto;
            padding: 15px;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(70px, 1fr));
            gap: 15px;
        }

        .sticker-item {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
        }

        .sticker-item img {
            width: 60px;
            height: 60px;
            object-fit: contain;
        }

        .sticker-item span {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
            text-align: center;
        }

        #add-sticker-modal .modal-window {
            max-width: 360px;
        }

        #sticker-preview {
            width: 100px;
            height: 100px;
            border: 2px dashed #ddd;
            border-radius: 10px;
            margin: 0 auto 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #aaa;
            background-color: #f9f9f9;
        }

        #sticker-preview img {
            max-width: 100%;
            max-height: 100%;
        }

        .chat-input-wrapper {
            flex-shrink: 0;
        }

        .message-input-area {
            display: flex;
            align-items: center;
            padding: 10px;
            padding-bottom: calc(50px + env(safe-area-inset-bottom));
            border-top: 1px solid #eee;
            background: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(10px);
            flex-shrink: 0;
            gap: 10px;
            border-bottom-left-radius: var(--phone-corner-radius);
            border-bottom-right-radius: var(--phone-corner-radius);
            overflow: hidden;
        }

        .message-input-area input {
            flex-grow: 1;
            border: none;
            padding: 12px;
            border-radius: 18px;
            background-color: #f0f0f0;
        }

        .message-input-area input:focus {
            outline: none;
        }

        .message-input-area .icon-btn {
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            cursor: pointer;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s;
        }

        .message-input-area .icon-btn:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        .message-input-area .icon-btn svg {
            width: 20px;
            height: 20px;
            fill: currentColor;
        }

        .message-input-area .icon-btn.send-btn {
            font-size: 18px;
        }

        #multi-select-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            display: none;
            justify-content: space-between;
            align-items: center;
            padding: 10px 20px;
            padding-bottom: calc(10px + env(safe-area-inset-bottom));
            border-top: 1px solid #eee;
            z-index: 20;
            border-bottom-left-radius: var(--phone-corner-radius);
            border-bottom-right-radius: var(--phone-corner-radius);
            animation: slideUp 0.3s ease-out;
        }

        #multi-select-bar.visible {
            display: flex;
        }

        .settings-sidebar {
            position: absolute;
            top: 0;
            right: -100%;
            width: 80%;
            height: 100%;
            background: #fff;
            box-shadow: -5px 0 15px rgba(0, 0, 0, 0.1);
            transition: right 0.4s ease-in-out;
            z-index: 101;
            display: flex;
            flex-direction: column;
        }

        .settings-sidebar.open {
            right: 0;
        }

        .settings-sidebar .header {
            padding: 15px;
            border-bottom: 1px solid #eee;
            font-weight: bold;
            text-align: center;
            color: var(--primary-color);
        }

        .settings-sidebar .content {
            padding: 20px;
            overflow-y: auto;
            flex-grow: 1;
        }

        .settings-sidebar .form-group textarea {
            height: 100px;
            resize: vertical;
        }

        .settings-sidebar .avatar-setting {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
        }

        .settings-sidebar .avatar-preview {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            object-fit: cover;
            border: 2px solid var(--primary-color);
            cursor: pointer;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            color: var(--secondary-color);
            font-weight: 600;
        }

        .form-group input,
        .form-group select,
        .form-group textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid var(--secondary-color);
            border-radius: 10px;
            background-color: #fff;
            transition: border-color 0.3s;
            font-family: var(--font-family);
            font-size: 14px;
        }

        .form-group input:focus,
        .form-group select:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: var(--primary-color);
        }

        .form-group.radio-group {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .form-group.radio-group label {
            margin-bottom: 0;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .btn {
            width: 100%;
            padding: 15px;
            border-radius: 10px;
            border: none;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            text-align: center;
        }

        .btn-primary {
            background-color: var(--primary-color);
            color: var(--white-color);
        }

        .btn-primary:hover {
            background-color: var(--primary-color-hover);
            box-shadow: 0 4px 15px var(--primary-color-hover);
        }

        label.btn-primary {
            color: var(--white-color) !important;
        }

        .btn-small {
            padding: 8px 16px;
            font-size: 14px;
            width: auto;
        }

        .btn-secondary {
            background-color: var(--accent-color);
            color: var(--white-color);
            /* margin-bottom: 15px; */
        }

        .btn-secondary:hover {
            background-color: var(--accent-color-hover);
            box-shadow: 0 4px 15px var(--accent-color-hover);
        }

        .btn-neutral {
            background-color: #bdbdbd;
            color: var(--white-color);
        }

        .btn-neutral:hover {
            background-color: #9e9e9e;
        }

        .btn-danger {
            background-color: #ef5350;
            color: white;
        }

        .btn .spinner {
            display: none;
            width: 16px;
            height: 16px;
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-top-color: var(--white-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        .btn.loading .spinner {
            display: block;
        }

        .btn.loading .btn-text {
            display: none;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .wallpaper-preview {
            width: 100%;
            aspect-ratio: 9 / 16;
            max-height: 400px;
            border-radius: var(--border-radius);
            margin-bottom: 25px;
            background-size: cover;
            background-position: center;
            border: 3px dashed var(--primary-color);
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--secondary-color);
            font-style: italic;
            background-color: #fff8fa;
        }

        .toast {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 15px;
            font-size: 14px;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s, visibility 0.5s;
            z-index: 1000;
        }

        .toast.show {
            opacity: 1;
            visibility: visible;
        }

        #world-book-selection-modal,
        #invite-member-modal,
        #group-recipient-selection-modal {
            z-index: 102;
        }

        #world-book-selection-modal .modal-window,
        #invite-member-modal .modal-window,
        #group-recipient-selection-modal .modal-window {
            width: 90%;
            max-width: 380px;
        }

        #world-book-selection-list,
        #invite-member-selection-list,
        #group-recipient-selection-list {
            list-style: none;
            padding: 0;
            margin: 0;
            max-height: 40vh;
            overflow-y: auto;
        }

        .world-book-select-item,
        .invite-member-select-item,
        .group-recipient-select-item {
            display: flex;
            align-items: center;
            padding: 12px 5px;
            border-bottom: 1px solid #f0f0f0;
        }

        .world-book-select-item:last-child,
        .invite-member-select-item:last-child,
        .group-recipient-select-item:last-child {
            border-bottom: none;
        }

        .world-book-select-item input[type="checkbox"],
        .invite-member-select-item input[type="checkbox"],
        .group-recipient-select-item input[type="checkbox"] {
            margin-right: 15px;
            width: 20px;
            height: 20px;
        }

        .world-book-select-item label,
        .invite-member-select-item label,
        .group-recipient-select-item label {
            font-weight: 500;
            color: var(--text-color);
            display: flex;
            align-items: center;
            gap: 10px;
            width: 100%;
        }

        .invite-member-select-item img,
        .group-recipient-select-item img {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            object-fit: cover;
        }

        /* --- Group Chat Specific Styles --- */
        .member-selection-list {
            list-style: none;
            padding: 0;
            margin: 15px 0;
            max-height: 40vh;
            overflow-y: auto;
        }

        .member-selection-item {
            display: flex;
            align-items: center;
            padding: 10px 5px;
            border-bottom: 1px solid #f0f0f0;
        }

        .member-selection-item:last-child {
            border-bottom: none;
        }

        .member-selection-item input[type="checkbox"] {
            margin-right: 15px;
            width: 20px;
            height: 20px;
            flex-shrink: 0;
        }

        .member-selection-item img {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            object-fit: cover;
            margin-right: 10px;
        }

        .member-selection-item label {
            font-weight: 500;
            color: var(--text-color);
        }

        #group-settings-sidebar .group-avatar-setting {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
        }

        #group-settings-sidebar .group-avatar-preview {
            width: 60px;
            height: 60px;
            border-radius: 10px;
            object-fit: cover;
            border: 2px solid var(--primary-color);
            cursor: pointer;
        }

        #group-settings-sidebar .group-members-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
            gap: 15px;
            margin-top: 10px;
        }

        #group-settings-sidebar .group-member,
        #group-settings-sidebar .add-member-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
        }

        #group-settings-sidebar .group-member img {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            object-fit: cover;
            margin-bottom: 5px;
            border: 2px solid #eee;
        }

        #group-settings-sidebar .add-member-btn .add-icon {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: 2px dashed #ccc;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: #ccc;
            margin-bottom: 5px;
            transition: all 0.2s ease;
        }

        #group-settings-sidebar .add-member-btn:hover .add-icon {
            color: var(--primary-color-hover);
            border-color: var(--primary-color);
        }

        #group-settings-sidebar .group-member span,
        #group-settings-sidebar .add-member-btn span {
            font-size: 12px;
            text-align: center;
            color: var(--text-color);
        }

        #customize-screen .icon-custom-item {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid #f0f0f0;
        }

        #customize-screen .icon-custom-item:last-child {
            border-bottom: none;
        }

        #customize-screen .icon-preview {
            width: 50px;
            height: 50px;
            border-radius: 12px;
            object-fit: cover;
            flex-shrink: 0;
        }

        #customize-screen .icon-details {
            flex-grow: 1;
        }

        #customize-screen .icon-details p {
            margin: 0 0 8px 0;
            font-weight: 600;
        }

        #customize-screen .icon-details input {
            width: calc(100% - 70px);
        }

        #customize-screen .reset-icon-btn {
            background: #e0e0e0;
            color: #555;
            border: none;
            border-radius: 8px;
            padding: 8px 10px;
            font-size: 12px;
            cursor: pointer;
            margin-left: 10px;
        }

        /* --- Tutorial Screen Styles --- */
        .tutorial-item {
            margin-bottom: 15px;
            border: 1px solid #fce4ec;
            border-radius: 12px;
            overflow: hidden;
            background-color: #fff8fa;
        }

        .tutorial-header {
            padding: 12px 18px;
            font-weight: 600;
            color: var(--secondary-color);
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .tutorial-header::after {
            content: '▼';
            font-size: 12px;
            transition: transform 0.3s ease;
        }

        .tutorial-item.open .tutorial-header::after {
            transform: rotate(180deg);
        }

        .tutorial-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s ease-in-out, padding 0.5s ease;
            padding: 0 10px;
        }

        .tutorial-item.open .tutorial-content {
            padding: 10px 10px;
            /* A large value to ensure it expands to fit the content */
            max-height: 5000px;
        }

        .tutorial-content img {
            width: 100%;
            height: auto;
            border-radius: 8px;
            display: block;
        }
    </style>
</head>

<body>
<div class="phone-screen">
    <div id="home-screen" class="screen active"></div>
    <div id="chat-list-screen" class="screen">
        <header class="app-header">
            <button class="back-btn" data-target="home-screen">‹</button>
            <div class="title-container">
                <h1 class="title">채팅</h1>
            </div>
            <div class="action-btn-group">
                <button class="action-btn" id="create-group-btn">그룹 채팅</button>
                <button class="action-btn" id="add-chat-btn">+</button>
            </div>
        </header>
        <main class="content">
            <ul class="list-container" id="chat-list-container"></ul>
            <div class="placeholder-text" id="no-chats-placeholder" style="display: none;">
                <p>아직 채팅 상대가 없어요~</p>
                <p>오른쪽 상단을 클릭하여 만들어 보세요!</p>
            </div>
        </main>
    </div>
    <div id="chat-room-screen" class="screen">
        <header class="app-header" id="chat-room-header-default">
            <button class="back-btn" data-target="chat-list-screen">‹</button>
            <div class="title-container">
                <h1 class="title" id="chat-room-title">...</h1>
                <div class="subtitle" id="chat-room-subtitle">
                    <div class="online-indicator"></div><span id="chat-room-status-text">온라인</span>
                </div>
            </div>
            <button class="action-btn" id="chat-settings-btn"><img src="https://i.postimg.cc/nhwP4pQy/chan-73.png" alt="설정"></button>
        </header>
        <header class="app-header" id="chat-room-header-select" style="display: none;">
            <button class="action-btn" id="cancel-multi-select-btn">취소</button>
            <div class="title-container">
                <h1 class="title" id="multi-select-title">메시지 선택</h1>
            </div>
            <div class="placeholder"></div>
        </header>
        <main class="content">
            <div class="message-area" id="message-area"></div>
            <div class="typing-indicator" id="typing-indicator"></div>
        </main>
        <div class="chat-input-wrapper">
            <div id="sticker-bar">
                <button class="sticker-bar-btn" id="sticker-toggle-btn">
                    <svg viewBox="0 0 24 24">
                        <path d="M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zm3.5-9c.83 0 1.5-.67 1.5-1.5S16.33 8 15.5 8 14 8.67 14 9.5s.67 1.5 1.5 1.5zm-7 0c.83 0 1.5-.67 1.5-1.5S9.33 8 8.5 8 7 8.67 7 9.5 7.67 11 8.5 11zm3.5 6.5c2.33 0 4.31-1.46 5.11-3.5H6.89c.8 2.04 2.78 3.5 5.11 3.5z" /></svg>
                </button>
                <button class="sticker-bar-btn" id="photo-video-btn">
                    <svg viewBox="0 0 24 24">
                        <path d="M4,4H7L9,2H15L17,4H20A2,2 0 0,1 22,6V18A2,2 0 0,1 20,20H4A2,2 0 0,1 2,18V6A2,2 0 0,1 4,4M12,7A5,5 0 0,0 7,12A5,5 0 0,0 12,17A5,5 0 0,0 17,12A5,5 0 0,0 12,7M12,9A3,3 0 0,1 15,12A3,3 0 0,1 12,15A3,3 0 0,1 9,12A3,3 0 0,1 12,9Z" /></svg>
                </button>
                <button class="sticker-bar-btn" id="image-recognition-btn">
                    <svg viewBox="0 0 24 24">
                        <path d="M21.58,16.09L19.66,18L18.24,16.58L21,13.83C21.39,13.44 22,13.44 22.39,13.83L23.17,14.61C23.56,15 23.56,15.64 23.17,16.03L21.58,17.62M20.13,12.25L18.71,13.66L20.41,15.36L21.83,13.94L20.13,12.25M5.93,19H5C3.9,19 3,18.1 3,17V5C3,3.9 3.9,3 5,3H19C20.1,3 21,3.9 21,5V11.08L19,13.08V5H5V17H5.93L13.5,9.43L16.29,12.21L12.08,16.42L5.93,19Z" /></svg>
                </button>
                <button class="sticker-bar-btn" id="voice-message-btn">
                    <svg viewBox="0 0 24 24">
                        <path d="M12 14c1.66 0 2.99-1.34 2.99-3L15 5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm5.3-3c0 3-2.54 5.1-5.3 5.1S6.7 14 6.7 11H5c0 3.41 2.72 6.23 6 6.72V21h2v-3.28c3.28-.48 6-3.3 6-6.72h-1.7z" /></svg>
                </button>
                <button class="sticker-bar-btn" id="wallet-btn">
                    <svg viewBox="0 0 24 24">
                        <path d="M20 4H4C2.9 4 2 4.9 2 6V18C2 19.1 2.9 20 4 20H20C21.1 20 22 19.1 22 18V6C22 4.9 21.1 4 20 4ZM20 18H4V8H20V18ZM4 6H20V6H4Z" /></svg>
                </button>
                <button class="sticker-bar-btn" id="gift-btn">
                    <svg viewBox="0 0 24 24">
                        <path d="M20,8L12,13L4,8V6H20M20,4H4A2,2 0 0,0 2,6V18A2,2 0 0,0 4,20H20A2,2 0 0,0 22,18V6A2,2 0 0,0 20,4M12.5,18C12.5,17.29 12.17,16.65 11.64,16.27C12.17,15.89 12.5,15.26 12.5,14.55C12.5,13.6 11.83,12.79 11,12.58V12H13V10H11V8H13V6H11V5C11,4.45 10.55,4 10,4H8C7.45,4 7,4.45 7,5V6H9V8H7V10H9V12H7V12.58C6.17,12.79 5.5,13.6 5.5,14.55C5.5,15.26 5.83,15.89 6.36,16.27C5.83,16.65 5.5,17.29 5.5,18H12.5Z" /></svg>
                </button>
                <!-- NEW: Time Skip Button -->
                <button class="sticker-bar-btn" id="time-skip-btn">
                    <svg viewBox="0 0 24 24">
                        <path d="M4 5v14l7-7-7-7zm9 0v14l7-7-7-7z"></path></svg>
                </button>
            </div>
            <div class="message-input-area" id="message-input-default">
                <input type="text" id="message-input" placeholder="메시지 입력..."><button id="send-message-btn" class="icon-btn send-btn">➤</button>
                <button id="get-reply-btn" class="icon-btn">
                    <svg viewBox="0 0 24 24">
                        <path d="M12,2A10,10 0 1,0 22,12A10,10 0 0,0 12,2M12,20A8,8 0 1,1 20,12A8,8 0 0,1 12,20M16.24,7.76C15.07,6.58 13.53,6 12,6V12L7.76,16.24C10.1,18.58 13.9,18.58 16.24,16.24C18.58,13.9 18.58,10.1 16.24,7.76Z" /></svg>
                </button>
            </div>
            <div class="message-input-area" id="message-edit-bar" style="display: none;">
                <input type="text" id="message-edit-input"><button id="save-edit-btn" class="icon-btn send-btn">✓</button><button id="cancel-edit-btn" class="icon-btn" style="background-color: #aaa;">✗</button>
            </div>
        </div>
        <div id="multi-select-bar"><span id="select-count">0개 항목 선택됨</span><button class="btn btn-danger" id="delete-selected-btn" style="width: auto; padding: 8px 16px;">선택 삭제</button></div>
        <div id="sticker-modal">
            <div class="header"><span>내 이모티콘</span><button class="btn btn-primary btn-small" id="add-new-sticker-btn">새 이모티콘 추가</button></div>
            <div class="sticker-grid" id="sticker-grid-container"></div>
        </div>
    </div>
    <div id="world-book-screen" class="screen">
        <header class="app-header">
            <button class="back-btn" data-target="home-screen">‹</button>
            <div class="title-container">
                <h1 class="title">월드인포</h1>
            </div>
            <button class="action-btn" id="add-world-book-btn">+</button>
        </header>
        <main class="content">
            <ul class="list-container" id="world-book-list-container"></ul>
            <div class="placeholder-text" id="no-world-books-placeholder" style="display: none;">
                <p>당신의 세계는 혼돈에 빠져있어요...</p>
                <p>오른쪽 상단을 클릭하여 첫 번째 설정을 만들어 보세요!</p>
            </div>
        </main>
    </div>
    <div id="edit-world-book-screen" class="screen">
        <header class="app-header">
            <button class="back-btn" data-target="world-book-screen">‹</button>
            <div class="title-container">
                <h1 class="title" id="edit-world-book-title">생성/항목 편집</h1>
            </div>
            <div class="placeholder"></div>
        </header>
        <main class="content">
            <form id="edit-world-book-form">
                <input type="hidden" id="world-book-id">
                <div class="form-group">
                    <label for="world-book-name">항목 이름</label>
                    <input type="text" id="world-book-name" placeholder="예:세계관 배경, 마법 체계" required>
                </div>
                <div class="form-group">
                    <label for="world-book-content">항목 내용</label>
                    <textarea id="world-book-content" rows="8" placeholder="이 설정에 대해 자세히 설명하세요..." required></textarea>
                </div>
                <div class="form-group">
                    <label>주입 위치</label>
                    <div class="form-group radio-group">
                        <label><input type="radio" name="world-book-position" value="before" checked> 앞</label>
                        <label><input type="radio" name="world-book-position" value="after"> 뒤</label>
                    </div>
                </div>
                <button type="submit" class="btn btn-primary">항목 저장</button>
            </form>
        </main>
    </div>
    <div id="api-settings-screen" class="screen"></div>
    <div id="wallpaper-screen" class="screen"></div>
    <div id="font-settings-screen" class="screen"></div>
    <div id="customize-screen" class="screen"></div>
    <div id="tutorial-screen" class="screen"></div>
    <div id="toast-notification" class="toast"></div>
    <input type="file" id="image-upload-input" accept="image/*" style="display:none;">
    <div id="add-char-modal" class="modal-overlay">
        <div class="modal-window">
            <h3>새 캐릭터 생성</h3>
            <form id="add-char-form">
                <div class="form-group">
                    <label for="char-real-name">캐릭터 이름</label><input type="text" id="char-real-name" placeholder="캐릭터의 본명" required>
                </div>
                <div class="form-group">
                    <label for="char-remark-name">캐릭터 메모 (닉네임)</label><input type="text" id="char-remark-name" placeholder="당신이 상대방을 부르는 호칭" required>
                </div>
                <div class="form-group">
                    <label for="my-name-for-char">내 이름</label><input type="text" id="my-name-for-char" placeholder="상대방이 당신을 어떻게 불러주기를 원하나요" required>
                </div><button type="submit" class="btn btn-primary">생성</button>
            </form>
        </div>
    </div>
    <div id="add-sticker-modal" class="modal-overlay">
        <div class="modal-window">
            <h3 id="add-sticker-modal-title">새 이모티콘 추가</h3>
            <form id="add-sticker-form"><input type="hidden" id="sticker-edit-id">
                <div id="sticker-preview"><span>미리보기</span></div>
                <div class="form-group"><label for="sticker-name">이모티콘 이름</label><input type="text" id="sticker-name" placeholder="예:행복함" required></div>
                <div class="form-group"><label for="sticker-url-input">이모티콘 URL</label><input type="url" id="sticker-url-input" placeholder="이미지 URL 붙여넣기"></div>
                <p style="text-align:center; color:#888; margin: -10px 0 15px;">또는</p><input type="file" id="sticker-file-upload" accept="image/*" style="display:none;"><label for="sticker-file-upload" class="btn btn-secondary" style="width:100%; margin-bottom: 20px;">로컬에서 업로드</label><button type="submit" class="btn btn-primary">저장</button>
            </form>
        </div>
    </div>
    <div id="sticker-actionsheet" class="action-sheet-overlay">
        <div class="action-sheet"><button class="action-sheet-button" id="edit-sticker-btn">편집</button><button class="action-sheet-button danger" id="delete-sticker-btn">삭제</button></div>
    </div>
    <div id="send-voice-modal" class="modal-overlay">
        <div class="modal-window">
            <h3>음성 메시지 보내기</h3>
            <form id="send-voice-form">
                <div class="form-group">
                    <label for="voice-text-input">음성 텍스트 입력</label>
                    <textarea id="voice-text-input" placeholder="여기에 하고 싶은 말을 입력하세요..." required rows="4"></textarea>
                </div>
                <div class="form-group" style="text-align:center; color:#888; font-size: 14px;">
                    예상 시간: <span id="voice-duration-preview">0"</span>
                </div>
                <button type="submit" class="btn btn-primary">보내기</button>
            </form>
        </div>
    </div>
    <div id="send-pv-modal" class="modal-overlay">
        <div class="modal-window">
            <h3>사진 공유/동영상</h3>
            <form id="send-pv-form">
                <div class="form-group">
                    <label for="pv-text-input">설명 입력</label>
                    <textarea id="pv-text-input" placeholder="여기에 사진 또는 동영상 내용을 설명하세요..." required rows="4"></textarea>
                </div>
                <button type="submit" class="btn btn-primary">보내기</button>
            </form>
        </div>
    </div>
    <div id="send-transfer-modal" class="modal-overlay">
        <div class="modal-window">
            <h3>송금</h3>
            <form id="send-transfer-form">
                <div class="form-group">
                    <label for="transfer-amount-input">금액 (원)</label>
                    <input type="number" id="transfer-amount-input" placeholder="0.00" required step="0.01" min="0.01">
                </div>
                <div class="form-group">
                    <label for="transfer-remark-input">비고</label>
                    <input type="text" id="transfer-remark-input" placeholder="(선택 사항)">
                </div>
                <button type="submit" class="btn btn-primary">보내기</button>
            </form>
        </div>
    </div>
    <div id="send-gift-modal" class="modal-overlay">
        <div class="modal-window">
            <h3>선물 보내기</h3>
            <form id="send-gift-form">
                <div class="form-group">
                    <label for="gift-description-input">선물 설명</label>
                    <textarea id="gift-description-input" placeholder="Ta에게 어떤 특별한 것을 보냈는지 알려주세요..." required rows="4"></textarea>
                </div>
                <button type="submit" class="btn btn-primary">보내기</button>
            </form>
        </div>
    </div>
    <!-- NEW: Time Skip Modal -->
    <div id="time-skip-modal" class="modal-overlay">
        <div class="modal-window">
            <h3>오늘 있었던 일을 기록하기</h3>
            <form id="time-skip-form">
                <div class="form-group">
                    <label for="time-skip-input">사건 설명 (이 메시지는 AI에 표시되며, 컨텍스트로 사용됩니다)</label>
                    <textarea id="time-skip-input" placeholder="예:우리는 함께 산 정상에 가서 일몰을 보고 바비큐를 먹었어요." required rows="4"></textarea>
                </div>
                <button type="submit" class="btn btn-primary">보내기</button>
            </form>
        </div>
    </div>
    <!-- NEW: Group Recipient Selection Modal -->
    <div id="group-recipient-selection-modal" class="modal-overlay">
        <div class="modal-window">
            <h3 id="group-recipient-selection-title">수신자 선택</h3>
            <ul id="group-recipient-selection-list"></ul>
            <button class="btn btn-primary" id="confirm-group-recipient-btn" style="margin-top: 20px;">확인</button>
        </div>
    </div>
    <div id="receive-transfer-actionsheet" class="action-sheet-overlay">
        <div class="action-sheet">
            <button class="action-sheet-button" id="accept-transfer-btn">수신</button>
            <button class="action-sheet-button danger" id="return-transfer-btn">반송</button>
        </div>
    </div>
    <!-- Private Chat Settings -->
    <div id="chat-settings-sidebar" class="settings-sidebar">
        <div class="header">채팅 설정</div>
        <div class="content">
            <form id="chat-settings-form">
                <div class="avatar-setting"><img src="" alt="캐릭터 아바타" id="setting-char-avatar-preview" class="avatar-preview"><input type="file" id="setting-char-avatar-upload" accept="image/*" style="display:none;"><label for="setting-char-avatar-upload" class="btn btn-primary" style="flex-grow:1;">캐릭터 아바타 변경</label></div>
                <div class="form-group"><label for="setting-char-remark">캐릭터 메모 (닉네임)</label><input type="text" id="setting-char-remark"></div>
                <div class="form-group"><label for="setting-char-persona">캐릭터 디스크립션</label><textarea id="setting-char-persona" placeholder="캐릭터의 성격, 배경, 말하는 방식 등을 자세히 설명하세요."></textarea></div>
                <hr style="border:none; border-top:1px solid #eee; margin: 20px 0;">
                <div class="avatar-setting"><img src="" alt="내 아바타" id="setting-my-avatar-preview" class="avatar-preview"><input type="file" id="setting-my-avatar-upload" accept="image/*" style="display:none;"><label for="setting-my-avatar-upload" class="btn btn-secondary" style="flex-grow:1;">내 아바타 변경</label></div>
                <div class="form-group"><label for="setting-my-name">내 이름</label><input type="text" id="setting-my-name"></div>
                <div class="form-group"><label for="setting-my-persona">내 페르소나 설정</label><textarea id="setting-my-persona" placeholder="대화에서 어떤 역할을 하고 싶은지 설명하세요."></textarea></div>
                <hr style="border:none; border-top:1px solid #eee; margin: 20px 0;">
                <div class="form-group"><button type="button" class="btn btn-secondary" id="link-world-book-btn">월드인포 연결</button></div>
                <div class="form-group"><label for="setting-theme-color">테마 색상 (상대방/나)</label><select id="setting-theme-color"></select></div>

                <hr style="border:none; border-top:1px solid #eee; margin: 20px 0;">
                <div class="form-group">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <label for="setting-use-custom-css" style="margin-bottom:0;">사용자 정의 말풍선 스타일</label>
                        <input type="checkbox" id="setting-use-custom-css" style="width: auto;">
                    </div>
                    <div id="private-bubble-css-preview" class="bubble-css-preview" style="background: #fff; border: 1px solid #eee; border-radius: 10px; padding: 15px; margin-bottom: 10px; display: flex; flex-direction: column; gap: 10px;">
                    </div>
                    <textarea id="setting-custom-bubble-css" rows="6" placeholder="여기에 CSS 코드를 입력하세요...&#10;예:&#10;.message-bubble.sent { background-color: #A5D6A7; }&#10;.message-bubble.received { background-color: #E1E1E1; }" disabled></textarea>
                    <button type="button" class="btn btn-neutral" id="reset-custom-bubble-css-btn" style="margin-top: 10px; width: auto; padding: 5px 15px; font-size: 14px;">기본값으로 복원</button>
                </div>

                <div class="form-group"><label for="setting-max-memory">최대 기억 턴 수</label><input type="number" id="setting-max-memory" value="10" min="1"></div>
                <div class="form-group"><label for="setting-chat-bg-upload" class="btn btn-primary">채팅 배경 변경</label><input type="file" id="setting-chat-bg-upload" accept="image/*" style="display:none;"></div><button type="submit" class="btn btn-primary">설정 저장</button>
            </form>
            <hr style="border:none; border-top:1px solid #eee; margin: 20px 0;"><button type="button" class="btn btn-danger" id="clear-chat-history-btn">채팅 기록 지우기</button>
        </div>
    </div>
    <div id="world-book-selection-modal" class="modal-overlay">
        <div class="modal-window">
            <h3>연결할 월드인포 선택</h3>
            <ul id="world-book-selection-list"></ul>
            <button class="btn btn-primary" id="save-world-book-selection-btn" style="margin-top: 20px;">확인</button>
        </div>
    </div>
    <!-- Group Chat Creation Modal -->
    <div id="create-group-modal" class="modal-overlay">
        <div class="modal-window">
            <h3>그룹 채팅 생성</h3>
            <form id="create-group-form">
                <div class="form-group">
                    <label>그룹 멤버 선택</label>
                    <ul id="member-selection-list" class="member-selection-list"></ul>
                </div>
                <div class="form-group">
                    <label for="group-name-input">그룹 채팅 이름</label>
                    <input type="text" id="group-name-input" placeholder="그룹 채팅 이름을 지어주세요" required>
                </div>
                <button type="submit" class="btn btn-primary">그룹 채팅 생성</button>
            </form>
        </div>
    </div>
    <!-- Group Chat Settings -->
    <div id="group-settings-sidebar" class="settings-sidebar">
        <div class="header">그룹 채팅 설정</div>
        <div class="content">
            <form id="group-settings-form">
                <div class="group-avatar-setting">
                    <img src="" alt="그룹 아바타" id="setting-group-avatar-preview" class="group-avatar-preview">
                    <input type="file" id="setting-group-avatar-upload" accept="image/*" style="display:none;">
                    <label for="setting-group-avatar-upload" class="btn btn-primary" style="flex-grow:1;">그룹 아바타 변경</label>
                </div>
                <div class="form-group">
                    <label for="setting-group-name">그룹 이름 (AI도 표시됨)</label>
                    <input type="text" id="setting-group-name">
                </div>
                <hr style="border:none; border-top:1px solid #eee; margin: 20px 0;">
                <div class="avatar-setting">
                    <img src="" alt="내 아바타" id="setting-group-my-avatar-preview" class="avatar-preview">
                    <input type="file" id="setting-group-my-avatar-upload" accept="image/*" style="display:none;">
                    <label for="setting-group-my-avatar-upload" class="btn btn-secondary" style="flex-grow:1;">내 아바타 변경</label>
                </div>
                <div class="form-group">
                    <label for="setting-group-my-nickname">내 그룹 닉네임</label>
                    <input type="text" id="setting-group-my-nickname">
                </div>
                <div class="form-group">
                    <label for="setting-group-my-persona">내 인격 설정</label>
                    <textarea id="setting-group-my-persona" placeholder="이 그룹 채팅에서 어떤 역할을 하고 싶은지 설명하세요."></textarea>
                </div>
                <hr style="border:none; border-top:1px solid #eee; margin: 20px 0;">
                <div class="form-group">
                    <label>그룹 멤버</label>
                    <div class="group-members-list" id="group-members-list-container"></div>
                </div>
                <hr style="border:none; border-top:1px solid #eee; margin: 20px 0;">
                <div class="form-group"><button type="button" class="btn btn-secondary" id="link-group-world-book-btn">월드인포 연결</button></div>
                <div class="form-group"><label for="setting-group-theme-color">테마 색상 (상대방/나)</label><select id="setting-group-theme-color"></select></div>

                <hr style="border:none; border-top:1px solid #eee; margin: 20px 0;">
                <div class="form-group">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <label for="setting-group-use-custom-css" style="margin-bottom:0;">사용자 정의 말풍선 스타일</label>
                        <input type="checkbox" id="setting-group-use-custom-css" style="width: auto;">
                    </div>
                    <div id="group-bubble-css-preview" class="bubble-css-preview" style="background: #fff; border: 1px solid #eee; border-radius: 10px; padding: 15px; margin-bottom: 10px; display: flex; flex-direction: column; gap: 10px;">
                    </div>
                    <textarea id="setting-group-custom-bubble-css" rows="6" placeholder="여기에 CSS 코드를 입력하세요...&#10;예:&#10;.message-bubble.sent { background-color: #A5D6A7; }&#10;.message-bubble.received { background-color: #E1E1E1; }" disabled></textarea>
                    <button type="button" class="btn btn-neutral" id="reset-group-custom-bubble-css-btn" style="margin-top: 10px; width: auto; padding: 5px 15px; font-size: 14px;">기본값으로 복원</button>
                </div>

                <div class="form-group"><label for="setting-group-max-memory">최대 기억 턴 수</label><input type="number" id="setting-group-max-memory" value="10" min="1"></div>
                <div class="form-group"><label for="setting-group-chat-bg-upload" class="btn btn-primary">채팅 배경 변경</label><input type="file" id="setting-group-chat-bg-upload" accept="image/*" style="display:none;"></div>
                <button type="submit" class="btn btn-primary">설정 저장</button>
            </form>
            <hr style="border:none; border-top:1px solid #eee; margin: 20px 0;">
            <button type="button" class="btn btn-danger" id="clear-group-chat-history-btn">채팅 기록 지우기</button>
        </div>
    </div>
    <!-- Group Member Edit Modal -->
    <div id="edit-group-member-modal" class="modal-overlay">
        <div class="modal-window">
            <h3 id="edit-group-member-title">그룹 멤버 편집</h3>
            <form id="edit-group-member-form">
                <input type="hidden" id="editing-member-id">
                <div class="avatar-setting" style="justify-content: center;">
                    <img src="" alt="멤버 아바타" id="edit-member-avatar-preview" class="avatar-preview" style="cursor: pointer;">
                    <input type="file" id="edit-member-avatar-upload" accept="image/*" style="display:none;">
                </div>
                <div class="form-group">
                    <label for="edit-member-group-nickname">그룹 닉네임</label>
                    <input type="text" id="edit-member-group-nickname" required>
                </div>
                <div class="form-group">
                    <label for="edit-member-real-name">본명</label>
                    <input type="text" id="edit-member-real-name" required>
                </div>
                <div class="form-group">
                    <label for="edit-member-persona">인격 설정</label>
                    <textarea id="edit-member-persona" placeholder="캐릭터의 성격, 배경 등을 자세히 설명하세요."></textarea>
                </div>
                <button type="submit" class="btn btn-primary">저장</button>
            </form>
        </div>
    </div>
    <!-- Add Member to Group Action Sheet -->
    <div id="add-member-actionsheet" class="action-sheet-overlay">
        <div class="action-sheet">
            <button class="action-sheet-button" id="invite-existing-member-btn">기존 캐릭터 초대</button>
            <button class="action-sheet-button" id="create-new-member-btn">새 캐릭터를 생성하여 그룹에 참가</button>
        </div>
    </div>
    <!-- Invite Existing Member Modal -->
    <div id="invite-member-modal" class="modal-overlay">
        <div class="modal-window">
            <h3>그룹 채팅에 멤버 초대</h3>
            <ul id="invite-member-selection-list"></ul>
            <button class="btn btn-primary" id="confirm-invite-btn" style="margin-top: 20px;">초대 확인</button>
        </div>
    </div>
    <!-- Create New Member for Group Modal -->
    <div id="create-member-for-group-modal" class="modal-overlay">
        <div class="modal-window">
            <h3>새 캐릭터를 생성하고 그룹 채팅에 참가</h3>
            <form id="create-member-for-group-form">
                <div class="avatar-setting" style="justify-content: center;">
                    <img src="https://i.postimg.cc/Y96LPskq/o-o-2.jpg" alt="새 멤버 아바타" id="create-group-member-avatar-preview" class="avatar-preview" style="cursor: pointer;">
                    <input type="file" id="create-group-member-avatar-upload" accept="image/*" style="display:none;">
                </div>
                <div class="form-group">
                    <label for="create-group-member-nickname">그룹 닉네임</label>
                    <input type="text" id="create-group-member-nickname" required>
                </div>
                <div class="form-group">
                    <label for="create-group-member-realname">본명</label>
                    <input type="text" id="create-group-member-realname" required>
                </div>
                <div class="form-group">
                    <label for="create-group-member-persona">인격 설정</label>
                    <textarea id="create-group-member-persona" placeholder="캐릭터의 성격, 배경 등을 자세히 설명하세요."></textarea>
                </div>
                <button type="submit" class="btn btn-primary">생성 및 참가</button>
            </form>
        </div>
    </div>
</div>

<script>
    // gemini여러 개의 키가 있다면, 무작위로 하나를 가져옵니다
    function getRandomValue(str) {
        // 문자열에 쉼표가 포함되어 있는지 확인
        if (str.includes(',')) {
            // 쉼표로 문자열을 구분하고 불필요한 공백 제거
            const arr = str.split(',').map(item => item.trim());
            // 무작위 인덱스 생성 (0 arr.length까지-1)
            const randomIndex = Math.floor(Math.random() * arr.length);
            // 무작위 요소 반환
            return arr[randomIndex];
        }
        // 쉼표가 없으면 원본 문자열을 직접 반환
        return str;
    }
    document.addEventListener('DOMContentLoaded', () => {
        async function compressImage(file, options = {}) {
            const {
                quality = 0.8, maxWidth = 800, maxHeight = 800
            } = options;

            // --- 새로 추가:GIF 애니메이션 처리 ---
            // 파일이 GIF인 경우, 캔버스 압축을 거치지 않고 원본 파일 데이터를 직접 반송하여 애니메이션을 유지합니다
            if (file.type === 'image/gif') {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.readAsDataURL(file);
                    reader.onload = () => resolve(reader.result);
                    reader.onerror = error => reject(error);
                });
            }

            // --- 다른 정적 이미지의 경우(PNG, JPG 등)압축 수행 ---
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onerror = reject;
                reader.onload = (event) => {
                    const img = new Image();
                    img.src = event.target.result;
                    img.onerror = reject;
                    img.onload = () => {
                        let width = img.width;
                        let height = img.height;

                        if (width > height) {
                            if (width > maxWidth) {
                                height = Math.round(height * (maxWidth / width));
                                width = maxWidth;
                            }
                        } else {
                            if (height > maxHeight) {
                                width = Math.round(width * (maxHeight / height));
                                height = maxHeight;
                            }
                        }

                        const canvas = document.createElement('canvas');
                        canvas.width = width;
                        canvas.height = height;
                        const ctx = canvas.getContext('2d');

                        // 투명 배경이 있는 PNG 이미지의 경우, 먼저 흰색 배경을 채웁니다
                        // 이렇게 하면 JPEG로 변환할 때 투명 영역이 검은색으로 변하는 것을 방지할 수 있습니다
                        if (file.type === 'image/png') {
                            ctx.fillStyle = '#FFFFFF'; // 흰색 배경
                            ctx.fillRect(0, 0, width, height);
                        }
                        
                        ctx.drawImage(img, 0, 0, width, height);
                        
                        // --- 주요 수정:출력 형식을 다음으로 변경 'image/jpeg' ---
                        // JPEG형식은 파일 크기를 현저히 줄이고 브라우저가 매우 큰 Base64 문자열을 처리할 때 충돌하는 것을 방지할 수 있습니다
                        const compressedDataUrl = canvas.toDataURL('image/jpeg', quality); 
                        resolve(compressedDataUrl);
                    };
                };
            });
        }
        // --- Initial HTML Injection ---
        document.getElementById('api-settings-screen').innerHTML = `<header class="app-header"><button class="back-btn" data-target="home-screen">‹</button><div class="title-container"><h1 class="title">API 설정</h1></div><div class="placeholder"></div></header><main class="content"><form id="api-form"><div class="form-group"><label for="api-provider">API 서비스 제공자</label><select id="api-provider" name="provider"><option value="newapi">NewAPI (사용자 정의)</option><option value="deepseek">DeepSeek</option><option value="claude">Claude</option><option value="gemini">Gemini</option></select></div><div class="form-group"><label for="api-url">API 주소(접미사를 추가할 필요 없음/v1)</label><input type="url" id="api-url" name="url" placeholder="서비스 제공자를 선택하면 자동으로 채워집니다" required></div><div class="form-group"><label for="api-key">키 (Key)</label><input type="password" id="api-key" name="key" placeholder="API 키를 입력하세요" required></div><button type="button" class="btn btn-secondary" id="fetch-models-btn"><span class="btn-text">모델 가져오기를 클릭하세요</span><div class="spinner"></div></button><div class="form-group"><label for="api-model">모델 선택</label><select id="api-model" name="model" required><option value="">먼저 모델 목록을 가져오세요</option></select></div><button type="submit" class="btn btn-primary" id="save-btn"><span class="btn-text">저장</span><div class="spinner"></div></button></form></main>`;
        document.getElementById('wallpaper-screen').innerHTML = `<header class="app-header"><button class="back-btn" data-target="home-screen">‹</button><div class="title-container"><h1 class="title">배경화면 & 테마</h1></div><div class="placeholder"></div></header><main class="content"><div class="wallpaper-preview" id="wallpaper-preview"><span>현재 배경화면 미리보기</span></div><input type="file" id="wallpaper-upload" accept="image/*" style="display: none;"><label for="wallpaper-upload" class="btn btn-primary">앨범에서 새 배경화면 선택</label><hr style="border:none; border-top:1px solid #eee; margin: 30px 0 20px;"><h3 style="text-align:center; font-weight:500; font-size: 16px; margin-bottom: 20px;">기본 테마 색상</h3><div class="theme-selector" id="theme-selector-container"></div></main>`;
        document.getElementById('font-settings-screen').innerHTML = `<header class="app-header"><button class="back-btn" data-target="home-screen">‹</button><div class="title-container"><h1 class="title">글꼴 설정</h1></div><div class="placeholder"></div></header><main class="content"><form id="font-settings-form"><div class="form-group"><label for="font-url">글꼴 링크 (ttf, woff, woff2)</label><input type="url" id="font-url" placeholder="https://.../font.ttf" required></div><p style="font-size:12px; color:#888; text-align:center;">예시: https://lf3-static.bytednsdoc.com/obj/eden-cn/jplptk/ljhwZthlaukjlkulzlp/portal/fonts/HarmonyOS_Sans_SC_Regular.woff2</p><button type="submit" class="btn btn-primary">글꼴 적용</button><button type="button" class="btn btn-neutral" id="restore-default-font-btn" style="margin-top: 15px;">기본 글꼴로 복원</button></form></main>`;
        document.getElementById('customize-screen').innerHTML = `<header class="app-header"><button class="back-btn" data-target="home-screen">‹</button><div class="title-container"><h1 class="title">홈 화면 사용자 정의</h1></div><div class="placeholder"></div></header><main class="content"><form id="customize-form"></form></main>`;
        document.getElementById('tutorial-screen').innerHTML = `<header class="app-header"><button class="back-btn" data-target="home-screen">‹</button><div class="title-container"><h1 class="title">튜토리얼</h1></div><div class="placeholder"></div></header><main class="content" id="tutorial-content-area"></main>`;

        // --- Global Variables and Constants ---
        const globalThemes = {
            'pink': { 
                name: '핑크 (기본)', 
                colors: { 
                    '--bg-color': '#fce4ec', '--secondary-color': '#f8bbd0', '--secondary-color-hover': 'rgb(250 218 229)', '--primary-color': '#ff80ab', '--primary-color-hover': 'rgb(250 218 229)',
                    '--accent-color': '#90caf9', '--accent-color-hover': 'rgb(217 236 252)','--text-color': '#444', '--white-color': '#fff', '--white-rgb': '255, 255, 255',
                    '--border-color': '#f0dbe2', '--top-pinned-bg': '#fff0f5', '--online-status-color': '#4CAF50'
                } 
            },
            'light': { 
                name: '블루', 
                colors: { 
                    '--bg-color': '#f0f2f5', '--secondary-color': '#c6dbf9', '--secondary-color-hover': 'rgb(250 218 229)', '--primary-color': '#66abf5', '--primary-color-hover': 'rgb(203 224 247)', 
                    '--accent-color': '#8f8dfa', '--accent-color-hover': 'rgb(212 211 255)', '--text-color': '#000', '--white-color': '#fff', '--white-rgb': '255, 255, 255',
                    '--border-color': '#d1d1d6', '--top-pinned-bg': '#f5f5f7', '--online-status-color': '#34c759'
                } 
            },
            'dark': { 
                name: '다크', 
                colors: { 
                    '--bg-color': '#000000', '--secondary-color': '#1C1C1E', '--primary-color': '#0A84FF', 
                    '--accent-color': '#5e5ce6', '--text-color': '#fff', '--white-color': '#1C1C1E', '--white-rgb': '28, 28, 30',
                    '--border-color': '#3a3a3c', '--top-pinned-bg': '#1C1C1E', '--online-status-color': '#30d158'
                } 
            },
            'mint': { 
                name: '민트', 
                colors: { 
                    '--bg-color': '#f0fafa', '--secondary-color': '#e3f5f5', '--primary-color': '#00c7be', 
                    '--accent-color': '#ff9f0a', '--text-color': '#2a3d3d', '--white-color': '#fff', '--white-rgb': '255, 255, 255',
                    '--border-color': '#d9e7e7', '--top-pinned-bg': '#e6f7f7', '--online-status-color': '#34c759'
                } 
            },
        };
        const colorThemes = {
            'white_pink': { name: '흰색/분홍색', received: { bg: 'rgba(255,255,255,0.9)', text: '#6D6D6D' }, sent: { bg: 'rgba(255,204,204,0.9)', text: '#A56767' } },
            'white_blue': { name: '흰색/파란색', received: { bg: 'rgba(255,255,255,0.9)', text: '#6D6D6D' }, sent: { bg: 'rgba(173,216,230,0.9)', text: '#4A6F8A' } },
            'white_yellow': { name: '흰색/노란색', received: { bg: 'rgba(255,255,255,0.9)', text: '#6D6D6D' }, sent: { bg: 'rgba(249,237,105,0.9)', text: '#8B7E4B' } },
            'white_green': { name: '흰색/초록색', received: { bg: 'rgba(255,255,255,0.9)', text: '#6D6D6D' }, sent: { bg: 'rgba(188,238,188,0.9)', text: '#4F784F' } },
            'white_purple': { name: '흰색/보라색', received: { bg: 'rgba(255,255,255,0.9)', text: '#6D6D6D' }, sent: { bg: 'rgba(185,190,240,0.9)', text: '#6C5B7B' } },
            'black_red': { name: '검은색/빨간색', received: { bg: 'rgba(30,30,30,0.85)', text: '#E0E0E0' }, sent: { bg: 'rgb(226,62,87,0.9)', text: '#fff' } },
            'black_green': { name: '검은색/초록색', received: { bg: 'rgba(30,30,30,0.85)', text: '#E0E0E0' }, sent: { bg: 'rgba(119,221,119,0.9)', text: '#2E5C2E' } },
            'black_white': { name: '검은색/흰색', received: { bg: 'rgba(30,30,30,0.85)', text: '#E0E0E0' }, sent: { bg: 'rgba(245,245,245,0.9)', text: '#333' } },
            'white_black': { name: '흰색/검은색', received: { bg: 'rgba(255,255,255,0.9)', text: '#6D6D6D' }, sent: { bg: 'rgba(50,50,50,0.85)', text: '#F5F5F5' } },
            'yellow_purple': { name: '노란색/보라색', received: { bg: 'rgba(255,250,205,0.9)', text: '#8B7E4B' }, sent: { bg: 'rgba(185,190,240,0.9)', text: '#6C5B7B' } },
            'pink_blue': { name: '분홍색/파란색', received: { bg: 'rgba(255,231,240,0.9)', text: '#7C6770' }, sent: { bg: 'rgba(173,216,230,0.9)', text: '#4A6F8A' } },
        };
        const defaultIcons = {
            'chat-list-screen': { name: '404', url: 'https://i.postimg.cc/VvQB8dQT/chan-143.png' },
            'api-settings-screen': { name: 'api', url: 'https://i.postimg.cc/50FqT8GL/chan-125.png' },
            'wallpaper-screen': { name: '배경화면', url: 'https://i.postimg.cc/3wqFttL3/chan-90.png' },
            'world-book-screen': { name: '월드인포', url: 'https://i.postimg.cc/prCWkrKT/chan-74.png' },
            'customize-screen': { name: '홈 화면', url: 'https://i.postimg.cc/vZVdC7gt/chan-133.png' },
            'font-settings-screen': { name: '글꼴', url: 'https://i.postimg.cc/FzVtC0x4/chan-21.png' },
            'tutorial-screen': { name: '튜토리얼', url: 'https://i.postimg.cc/6QgNzCFf/chan-118.png' },
            'day-mode-btn': { name: '', url: 'https://i.postimg.cc/Jz0tYqnT/chan-145.png' },
            'night-mode-btn': { name: '', url: 'https://i.postimg.cc/htYvkdQK/chan-146.png' }
        };

        let db = { characters: [], groups: [], apiSettings: {}, wallpaper: 'https://i.postimg.cc/W4Z9R9x4/ins-1.jpg', myStickers: [], homeScreenMode: 'night', worldBooks: [], fontUrl: '', customIcons: {} };
        let currentChatId = null, currentChatType = null, isGenerating = false, longPressTimer = null, isInMultiSelectMode = false, editingMessageId = null, currentPage = 1, currentTransferMessageId = null, currentEditingWorldBookId = null, currentStickerActionTarget = null, currentGroupAction = { type: null, recipients: [] };
        let selectedMessageIds = new Set();
        const MESSAGES_PER_PAGE = 50;

        // --- DOM Element Cache ---
        const screens = document.querySelectorAll('.screen'), toastElement = document.getElementById('toast-notification'), homeScreen = document.getElementById('home-screen'), chatListContainer = document.getElementById('chat-list-container'), noChatsPlaceholder = document.getElementById('no-chats-placeholder'), addChatBtn = document.getElementById('add-chat-btn'), addCharModal = document.getElementById('add-char-modal'), addCharForm = document.getElementById('add-char-form'), chatRoomScreen = document.getElementById('chat-room-screen'), chatRoomHeaderDefault = document.getElementById('chat-room-header-default'), chatRoomHeaderSelect = document.getElementById('chat-room-header-select'), cancelMultiSelectBtn = document.getElementById('cancel-multi-select-btn'), multiSelectTitle = document.getElementById('multi-select-title'), chatRoomTitle = document.getElementById('chat-room-title'), chatRoomStatusText = document.getElementById('chat-room-status-text'), messageArea = document.getElementById('message-area'), messageInputDefault = document.getElementById('message-input-default'), messageInput = document.getElementById('message-input'), sendMessageBtn = document.getElementById('send-message-btn'), getReplyBtn = document.getElementById('get-reply-btn'), typingIndicator = document.getElementById('typing-indicator'), chatSettingsBtn = document.getElementById('chat-settings-btn'), settingsSidebar = document.getElementById('chat-settings-sidebar'), settingsForm = document.getElementById('chat-settings-form'), messageEditBar = document.getElementById('message-edit-bar'), messageEditInput = document.getElementById('message-edit-input'), saveEditBtn = document.getElementById('save-edit-btn'), cancelEditBtn = document.getElementById('cancel-edit-btn'), multiSelectBar = document.getElementById('multi-select-bar'), selectCount = document.getElementById('select-count'), deleteSelectedBtn = document.getElementById('delete-selected-btn');
        const stickerToggleBtn = document.getElementById('sticker-toggle-btn'), stickerModal = document.getElementById('sticker-modal'), stickerGridContainer = document.getElementById('sticker-grid-container'), addNewStickerBtn = document.getElementById('add-new-sticker-btn'), addStickerModal = document.getElementById('add-sticker-modal'), addStickerModalTitle = document.getElementById('add-sticker-modal-title'), addStickerForm = document.getElementById('add-sticker-form'), stickerEditIdInput = document.getElementById('sticker-edit-id'), stickerPreview = document.getElementById('sticker-preview'), stickerNameInput = document.getElementById('sticker-name'), stickerUrlInput = document.getElementById('sticker-url-input'), stickerFileUpload = document.getElementById('sticker-file-upload');
        const stickerActionSheet = document.getElementById('sticker-actionsheet'), editStickerBtn = document.getElementById('edit-sticker-btn'), deleteStickerBtn = document.getElementById('delete-sticker-btn');
        const voiceMessageBtn = document.getElementById('voice-message-btn'), sendVoiceModal = document.getElementById('send-voice-modal'), sendVoiceForm = document.getElementById('send-voice-form'), voiceTextInput = document.getElementById('voice-text-input'), voiceDurationPreview = document.getElementById('voice-duration-preview');
        const photoVideoBtn = document.getElementById('photo-video-btn'), sendPvModal = document.getElementById('send-pv-modal'), sendPvForm = document.getElementById('send-pv-form'), pvTextInput = document.getElementById('pv-text-input');
        const imageRecognitionBtn = document.getElementById('image-recognition-btn'), imageUploadInput = document.getElementById('image-upload-input');
        const walletBtn = document.getElementById('wallet-btn'), sendTransferModal = document.getElementById('send-transfer-modal'), sendTransferForm = document.getElementById('send-transfer-form'), transferAmountInput = document.getElementById('transfer-amount-input'), transferRemarkInput = document.getElementById('transfer-remark-input');
        const receiveTransferActionSheet = document.getElementById('receive-transfer-actionsheet'), acceptTransferBtn = document.getElementById('accept-transfer-btn'), returnTransferBtn = document.getElementById('return-transfer-btn');
        const giftBtn = document.getElementById('gift-btn'), sendGiftModal = document.getElementById('send-gift-modal'), sendGiftForm = document.getElementById('send-gift-form'), giftDescriptionInput = document.getElementById('gift-description-input');
        const timeSkipBtn = document.getElementById('time-skip-btn'), timeSkipModal = document.getElementById('time-skip-modal'), timeSkipForm = document.getElementById('time-skip-form'), timeSkipInput = document.getElementById('time-skip-input');
        const clearChatHistoryBtn = document.getElementById('clear-chat-history-btn');
        const worldBookListContainer = document.getElementById('world-book-list-container'), noWorldBooksPlaceholder = document.getElementById('no-world-books-placeholder'), addWorldBookBtn = document.getElementById('add-world-book-btn'), editWorldBookScreen = document.getElementById('edit-world-book-screen'), editWorldBookForm = document.getElementById('edit-world-book-form'), worldBookIdInput = document.getElementById('world-book-id'), worldBookNameInput = document.getElementById('world-book-name'), worldBookContentInput = document.getElementById('world-book-content');
        const linkWorldBookBtn = document.getElementById('link-world-book-btn'), worldBookSelectionModal = document.getElementById('world-book-selection-modal'), worldBookSelectionList = document.getElementById('world-book-selection-list'), saveWorldBookSelectionBtn = document.getElementById('save-world-book-selection-btn');
        const fontSettingsForm = document.getElementById('font-settings-form'), fontUrlInput = document.getElementById('font-url'), restoreDefaultFontBtn = document.getElementById('restore-default-font-btn');
        const createGroupBtn = document.getElementById('create-group-btn'), createGroupModal = document.getElementById('create-group-modal'), createGroupForm = document.getElementById('create-group-form'), memberSelectionList = document.getElementById('member-selection-list'), groupNameInput = document.getElementById('group-name-input'), groupSettingsSidebar = document.getElementById('group-settings-sidebar'), groupSettingsForm = document.getElementById('group-settings-form'), groupMembersListContainer = document.getElementById('group-members-list-container'), editGroupMemberModal = document.getElementById('edit-group-member-modal'), editGroupMemberForm = document.getElementById('edit-group-member-form');
        const addMemberActionSheet = document.getElementById('add-member-actionsheet'), inviteExistingMemberBtn = document.getElementById('invite-existing-member-btn'), createNewMemberBtn = document.getElementById('create-new-member-btn'), inviteMemberModal = document.getElementById('invite-member-modal'), inviteMemberSelectionList = document.getElementById('invite-member-selection-list'), confirmInviteBtn = document.getElementById('confirm-invite-btn'), createMemberForGroupModal = document.getElementById('create-member-for-group-modal'), createMemberForGroupForm = document.getElementById('create-member-for-group-form');
        const customizeForm = document.getElementById('customize-form'), tutorialContentArea = document.getElementById('tutorial-content-area');
        const groupRecipientSelectionModal = document.getElementById('group-recipient-selection-modal'), groupRecipientSelectionList = document.getElementById('group-recipient-selection-list'), confirmGroupRecipientBtn = document.getElementById('confirm-group-recipient-btn'), groupRecipientSelectionTitle = document.getElementById('group-recipient-selection-title');
        const linkGroupWorldBookBtn = document.getElementById('link-group-world-book-btn');

        // --- Utility and Core Functions ---
        const saveData = () => localStorage.setItem('gemini-chat-app-db', JSON.stringify(db));
        const loadData = () => {
            const data = localStorage.getItem('gemini-chat-app-db');
            if (data) db = JSON.parse(data);
            if (!db.apiSettings) db.apiSettings = {};
            if (!db.wallpaper) db.wallpaper = 'https://i.postimg.cc/W4Z9R9x4/ins-1.jpg';
            if (!db.characters) db.characters = [];
            if (!db.groups) db.groups = [];
            if (!db.myStickers) db.myStickers = [];
            if (!db.homeScreenMode) db.homeScreenMode = 'night';
            if (!db.worldBooks) db.worldBooks = [];
            if (!db.fontUrl) db.fontUrl = '';
            if (!db.customIcons) db.customIcons = {};
            db.characters.forEach(c => {
                if (c.isPinned === undefined) c.isPinned = false;
                if (c.status === undefined) c.status = '온라인';
                if (!c.worldBookIds) c.worldBookIds = [];
                if (c.customBubbleCss === undefined) c.customBubbleCss = '';
                if (c.useCustomBubbleCss === undefined) c.useCustomBubbleCss = false;
                if (c.unreadCount === undefined) c.unreadCount = 0;
            });
            db.groups.forEach(g => {
                if (g.isPinned === undefined) g.isPinned = false;
                if (!g.worldBookIds) g.worldBookIds = [];
                if (g.customBubbleCss === undefined) g.customBubbleCss = '';
                if (g.useCustomBubbleCss === undefined) g.useCustomBubbleCss = false;
                if (g.unreadCount === undefined) g.unreadCount = 0;
            });
            applyGlobalTheme(db.globalTheme || 'pink');
        };
        const showToast = (message) => {
            toastElement.textContent = message;
            toastElement.classList.add('show');
            setTimeout(() => toastElement.classList.remove('show'), 3000);
        };
        const switchScreen = (targetId) => {
            screens.forEach(screen => screen.classList.remove('active'));
            document.getElementById(targetId)?.classList.add('active');
            // Close all overlays and sidebars
            const overlays = document.querySelectorAll('.modal-overlay, .action-sheet-overlay, .settings-sidebar');
            overlays.forEach(o => o.classList.remove('visible', 'open'));
        };
        const pad = (num) => num.toString().padStart(2, '0');

        function createContextMenu(items, x, y) {
            removeContextMenu();
            const menu = document.createElement('div');
            menu.className = 'context-menu';
            menu.style.left = `${x}px`;
            menu.style.top = `${y}px`;
            items.forEach(item => {
                const menuItem = document.createElement('div');
                menuItem.className = 'context-menu-item';
                if (item.danger) menuItem.classList.add('danger');
                menuItem.textContent = item.label;
                menuItem.onclick = () => {
                    item.action();
                    removeContextMenu();
                };
                menu.appendChild(menuItem);
            });
            document.body.appendChild(menu);
            document.addEventListener('click', removeContextMenu, { once: true });
        }

        function removeContextMenu() {
            const menu = document.querySelector('.context-menu');
            if (menu) menu.remove();
        }

        function updateCustomBubbleStyle(chatId, css, enabled) {
            const styleId = `custom-bubble-style-for-${chatId}`;
            let styleElement = document.getElementById(styleId);

            if (enabled && css) {
                if (!styleElement) {
                    styleElement = document.createElement('style');
                    styleElement.id = styleId;
                    document.head.appendChild(styleElement);
                }
                const scopedCss = css.replace(/(\.message-bubble(?:\.sent|\.received)?)/g, `#chat-room-screen.chat-active-${chatId} $1`);
                styleElement.innerHTML = scopedCss;
            } else {
                if (styleElement) styleElement.remove();
            }
        }

        function updateBubbleCssPreview(previewContainer, css, useDefault, theme) {
            previewContainer.innerHTML = '';

            const sentBubble = document.createElement('div');
            sentBubble.className = 'message-bubble sent';
            sentBubble.textContent = '이것은 내 말풍선입니다.';
            sentBubble.style.alignSelf = 'flex-end';
            sentBubble.style.borderBottomRightRadius = '5px';

            const receivedBubble = document.createElement('div');
            receivedBubble.className = 'message-bubble received';
            receivedBubble.textContent = '이것은 상대방 말풍선입니다.';
            receivedBubble.style.alignSelf = 'flex-start';
            receivedBubble.style.borderBottomLeftRadius = '5px';

            [sentBubble, receivedBubble].forEach(bubble => {
                bubble.style.maxWidth = '70%';
                bubble.style.padding = '8px 12px';
                bubble.style.wordWrap = 'break-word';
                bubble.style.lineHeight = '1.4';
            });

            if (useDefault || !css) {
                sentBubble.style.backgroundColor = theme.sent.bg;
                sentBubble.style.color = theme.sent.text;
                sentBubble.style.borderRadius = '18px';
                sentBubble.style.borderBottomRightRadius = '5px';
                receivedBubble.style.backgroundColor = theme.received.bg;
                receivedBubble.style.color = theme.received.text;
                receivedBubble.style.borderRadius = '18px';
                receivedBubble.style.borderBottomLeftRadius = '5px';
            } else {
                const styleTag = document.createElement('style');
                const scopedCss = css.replace(/(\.message-bubble(?:\.sent|\.received)?)/g, `#${previewContainer.id} $1`);
                styleTag.textContent = scopedCss;
                previewContainer.appendChild(styleTag);
            }
            previewContainer.appendChild(receivedBubble);
            previewContainer.appendChild(sentBubble);
        }

        const init = () => {
            loadData();
            document.body.addEventListener('click', (e) => {
                if (e.target.closest('.context-menu')) {
                    e.stopPropagation();
                    return;
                }
                removeContextMenu();

                const backBtn = e.target.closest('.back-btn');
                if (backBtn) {
                    e.preventDefault();
                    switchScreen(backBtn.getAttribute('data-target'));
                    const currentScreen = e.target.closest('.screen');
                if (currentScreen && currentScreen.id === 'chat-room-screen') {
                    currentChatId = null;
                    currentChatType = null;
                }
                }

                // Consolidated overlay closing logic
                const openOverlay = document.querySelector('.modal-overlay.visible, .action-sheet-overlay.visible');
                if (openOverlay && e.target === openOverlay) {
                    openOverlay.classList.remove('visible');
                }
            });

            // Specific nav links that switch screens
            document.body.addEventListener('click', e => {
                const navLink = e.target.closest('.app-icon[data-target]');
                if (navLink) {
                    e.preventDefault();
                    switchScreen(navLink.getAttribute('data-target'));
                }
            });

            updateClock();
            setInterval(updateClock, 30000);
            applyGlobalFont(db.fontUrl);
            setupHomeScreen();
            setupChatListScreen();
            setupAddCharModal();
            setupChatRoom();
            setupChatSettings();
            setupApiSettingsApp();
            setupWallpaperApp();
            setupStickerSystem();
            setupVoiceMessageSystem();
            setupPhotoVideoSystem();
            setupImageRecognition();
            setupWalletSystem();
            setupGiftSystem();
            setupTimeSkipSystem();
            setupWorldBookApp();
            setupFontSettingsApp();
            setupGroupChatSystem();
            setupCustomizeApp();
            setupTutorialApp();
        };

        function updateClock() {
            const now = new Date();
            const timeDisplay = document.getElementById('time-display');
            const dateDisplay = document.getElementById('date-display');
            if (timeDisplay) timeDisplay.textContent = `${pad(now.getHours())}:${pad(now.getMinutes())}`;
            if (dateDisplay) dateDisplay.textContent = `${now.getFullYear()}년${pad(now.getMonth() + 1)}월${pad(now.getDate())}일`;
        }

        // --- App Setup Functions ---
        function setupHomeScreen() {
            const getIcon = (id) => db.customIcons[id] || defaultIcons[id].url;
            const homeScreenHTML = `
            <div class="time-widget"><div class="time" id="time-display"></div><div class="date" id="date-display"></div></div>
            <div class="app-grid">
                <a href="#" class="app-icon" data-target="chat-list-screen"><img src="${getIcon('chat-list-screen')}" alt="404" class="icon-img"><span class="app-name">${defaultIcons['chat-list-screen'].name}</span></a>
                <a href="#" class="app-icon" data-target="api-settings-screen"><img src="${getIcon('api-settings-screen')}" alt="API" class="icon-img"><span class="app-name">${defaultIcons['api-settings-screen'].name}</span></a>
                <a href="#" class="app-icon" data-target="wallpaper-screen"><img src="${getIcon('wallpaper-screen')}" alt="Wallpaper" class="icon-img"><span class="app-name">${defaultIcons['wallpaper-screen'].name}</span></a>
                <a href="#" class="app-icon" data-target="world-book-screen"><img src="${getIcon('world-book-screen')}" alt="World Book" class="icon-img"><span class="app-name">${defaultIcons['world-book-screen'].name}</span></a>
                <a href="#" class="app-icon" data-target="customize-screen"><img src="${getIcon('customize-screen')}" alt="Customize" class="icon-img"><span class="app-name">${defaultIcons['customize-screen'].name}</span></a>
                <a href="#" class="app-icon" data-target="tutorial-screen"><img src="${getIcon('tutorial-screen')}" alt="Tutorial" class="icon-img"><span class="app-name">${defaultIcons['tutorial-screen'].name}</span></a>
            </div>
            <div class="dock">
                <a href="#" class="app-icon" id="day-mode-btn"><img src="${getIcon('day-mode-btn')}" alt="주간" class="icon-img"></a>
                <a href="#" class="app-icon" id="night-mode-btn"><img src="${getIcon('night-mode-btn')}" alt="야간" class="icon-img"></a>
                <a href="#" class="app-icon" data-target="font-settings-screen"><img src="${getIcon('font-settings-screen')}" alt="글꼴" class="icon-img"></a>
            </div>`;
            homeScreen.innerHTML = homeScreenHTML;
            updateClock();
            applyWallpaper(db.wallpaper);
            applyHomeScreenMode(db.homeScreenMode);
            document.getElementById('day-mode-btn')?.addEventListener('click', (e) => { e.preventDefault(); applyHomeScreenMode('day'); });
            document.getElementById('night-mode-btn')?.addEventListener('click', (e) => { e.preventDefault(); applyHomeScreenMode('night'); });
            document.querySelector('[data-target="world-book-screen"]').addEventListener('click', renderWorldBookList);
            document.querySelector('[data-target="customize-screen"]').addEventListener('click', renderCustomizeForm);
            document.querySelector('[data-target="tutorial-screen"]').addEventListener('click', renderTutorialContent);
        }

        function applyWallpaper(url) { homeScreen.style.backgroundImage = `url(${url})`; }

        function applyHomeScreenMode(mode) {
            if (mode === 'day') { homeScreen.classList.add('day-mode'); }
            else { homeScreen.classList.remove('day-mode'); }
            db.homeScreenMode = mode;
            saveData();
        }

        function setupCustomizeApp() {
            customizeForm.addEventListener('input', e => {
                if (e.target.matches('input[type="url"]')) {
                    const iconId = e.target.dataset.id;
                    const newUrl = e.target.value.trim();
                    const previewImg = document.getElementById(`icon-preview-${iconId}`);
                    if (newUrl) {
                        db.customIcons[iconId] = newUrl;
                        previewImg.src = newUrl;
                        saveData();
                        setupHomeScreen();
                    }
                }
            });
            customizeForm.addEventListener('click', e => {
                if (e.target.matches('.reset-icon-btn')) {
                    const iconId = e.target.dataset.id;
                    delete db.customIcons[iconId];
                    saveData();
                    renderCustomizeForm();
                    setupHomeScreen();
                    showToast('아이콘이 재설정되었습니다');
                }
            });
        }

        function renderCustomizeForm() {
            customizeForm.innerHTML = '';
            Object.entries(defaultIcons).forEach(([id, { name, url }]) => {
                const currentIcon = db.customIcons[id] || url;
                const itemHTML = `
                <div class="icon-custom-item">
                    <img src="${currentIcon}" alt="${name}" class="icon-preview" id="icon-preview-${id}">
                    <div class="icon-details">
                        <p>${name || '모드 전환'}</p>
                        <input type="url" class="form-group" placeholder="새 아이콘 URL 붙여넣기" value="${db.customIcons[id] || ''}" data-id="${id}">
                    </div>
                    <button type="button" class="reset-icon-btn" data-id="${id}">재설정</button>
                </div>`;
                customizeForm.insertAdjacentHTML('beforeend', itemHTML);
            });
        }

        function setupTutorialApp() {
            tutorialContentArea.addEventListener('click', (e) => {
                const header = e.target.closest('.tutorial-header');
                if (header) { header.parentElement.classList.toggle('open'); }
            });
        }

        function renderTutorialContent() {
            const tutorials = [
                { title: '서문', imageUrls: ['https://i.postimg.cc/7PgyMG9S/image.jpg'] },
                { title: '소프트웨어 소개', imageUrls: [ 'https://i.postimg.cc/VvsJRh6q/IMG-20250713-162647.jpg', 'https://i.postimg.cc/8P5FfxxD/IMG-20250713-162702.jpg', 'https://i.postimg.cc/3r94R3Sn/IMG-20250713-162712.jpg' ] },
                { title: '404', imageUrls: [ 'https://i.postimg.cc/x8scFPJW/IMG-20250713-162756.jpg', 'https://i.postimg.cc/pX6mfqtj/IMG-20250713-162809.jpg', 'https://i.postimg.cc/YScjV00q/IMG-20250713-162819.jpg', 'https://i.postimg.cc/13VfJw9j/IMG-20250713-162828.jpg' ] },
                { title: '404-그룹 채팅', imageUrls: ['https://i.postimg.cc/X7LSmRTJ/404.jpg'] }
            ];
            tutorialContentArea.innerHTML = '';
            tutorials.forEach(tutorial => {
                const item = document.createElement('div');
                item.className = 'tutorial-item';
                const imagesHtml = tutorial.imageUrls.map(url => `<img src="${url}" alt="${tutorial.title}튜토리얼 이미지">`).join('');
                item.innerHTML = `<div class="tutorial-header">${tutorial.title}</div><div class="tutorial-content">${imagesHtml}</div>`;
                tutorialContentArea.appendChild(item);
            });
        }

        // --- Chat List & Chat Room ---
        function setupChatListScreen() {
            renderChatList();
            addChatBtn.addEventListener('click', () => {
                addCharModal.classList.add('visible');
                addCharForm.reset();
            });
            chatListContainer.addEventListener('click', (e) => {
                const chatItem = e.target.closest('.chat-item');
                if (chatItem) {
                    currentChatId = chatItem.dataset.id;
                    currentChatType = chatItem.dataset.type;
                    openChatRoom(currentChatId, currentChatType);
                }
            });
            chatListContainer.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                const chatItem = e.target.closest('.chat-item');
                if (!chatItem) return;
                handleChatListLongPress(chatItem.dataset.id, chatItem.dataset.type, e.clientX, e.clientY);
            });
            chatListContainer.addEventListener('touchstart', (e) => {
                const chatItem = e.target.closest('.chat-item');
                if (!chatItem) return;
                longPressTimer = setTimeout(() => {
                    const touch = e.touches[0];
                    handleChatListLongPress(chatItem.dataset.id, chatItem.dataset.type, touch.clientX, touch.clientY);
                }, 400);
            });
            chatListContainer.addEventListener('touchend', () => clearTimeout(longPressTimer));
            chatListContainer.addEventListener('touchmove', () => clearTimeout(longPressTimer));
        }

        function handleChatListLongPress(chatId, chatType, x, y) {
            clearTimeout(longPressTimer);
            const chatItem = (chatType === 'private') ? db.characters.find(c => c.id === chatId) : db.groups.find(g => g.id === chatId);
            if (!chatItem) return;
            const itemName = chatType === 'private' ? chatItem.remarkName : chatItem.name;
            const menuItems = [{
                label: chatItem.isPinned ? '고정 해제' : '채팅 고정',
                action: () => {
                    chatItem.isPinned = !chatItem.isPinned;
                    saveData();
                    renderChatList();
                }
            }, {
                label: '채팅 삭제',
                danger: true,
                action: () => {
                    if (confirm(`"${itemName}"의 채팅 기록을 삭제하시겠습니까? 이 작업은 복구할 수 없습니다.`)) {
                        if (chatType === 'private') { db.characters = db.characters.filter(c => c.id !== chatId); }
                        else { db.groups = db.groups.filter(g => g.id !== chatId); }
                        saveData();
                        renderChatList();
                        showToast('채팅이 삭제되었습니다');
                    }
                }
            }];
            createContextMenu(menuItems, x, y);
        }

        function renderChatList() {
            chatListContainer.innerHTML = '';
            const allChats = [ ...db.characters.map(c => ({ ...c, type: 'private' })), ...db.groups.map(g => ({ ...g, type: 'group' })) ];
            noChatsPlaceholder.style.display = (db.characters.length + db.groups.length) === 0 ? 'block' : 'none';
            const sortedChats = allChats.sort((a, b) => {
                if (a.isPinned !== b.isPinned) return a.isPinned ? -1 : 1;
                const lastMsgTimeA = a.history && a.history.length > 0 ? a.history[a.history.length - 1].timestamp : 0;
                const lastMsgTimeB = b.history && b.history.length > 0 ? b.history[b.history.length - 1].timestamp : 0;
                return lastMsgTimeB - lastMsgTimeA;
            });
            sortedChats.forEach(chat => {
                let lastMessageText = '채팅을 시작하세요...';
                if (chat.history && chat.history.length > 0) {
                    const invisibleRegex = /\[.*?가 (?:수신|반송).*?했습니다\]|\[.*?의 상태 업데이트:.*?\]|\[.*?가 선물을 수신했습니다\]|\[system:.*?\]|\[.*?가 *?를 그룹 채팅에 초대\]|\[.*?가 그룹 이름을 변경:.*?\]|\[system-display:.*?\]/;
                    const visibleHistory = chat.history.filter(msg => !invisibleRegex.test(msg.content));
                    if (visibleHistory.length > 0) {
                        const lastMsg = visibleHistory[visibleHistory.length - 1];
                        const urlRegex = /^(https?:\/\/[^\s]+\.(?:jpg|jpeg|png|gif|webp|bmp|svg)|data:image\/[a-z]+;base64,)/i;
                        const imageRecogRegex = /\[.*?의 이미지:\]/
                        const voiceRegex = /\[.*?의 음성:.*?\]/;
                        const photoVideoRegex = /\[.*?사진\/동영상:.*?\]/;
                        const transferRegex = /\[.*?의 송금:.*?원.*?\]|\[.*?에게 송금:.*?원.*?\]|\[.*?가 .*?에게 송금:.*?원.*?\]/;
                        const stickerRegex = /\[.*?의 이모티콘:.*?\]|\[.*?이모티콘:.*?\]/;
                        const giftRegex = /\[.*?선물:.*?\]|\[.*?가 .*?에게 보낸 선물:.*?\]/;

                        if (giftRegex.test(lastMsg.content)) { lastMessageText = '[선물]'; }
                        else if (stickerRegex.test(lastMsg.content)) { lastMessageText = '[이모티콘]'; }
                        else if (voiceRegex.test(lastMsg.content)) { lastMessageText = '[음성]'; }
                        else if (photoVideoRegex.test(lastMsg.content)) { lastMessageText = '[사진/동영상]'; }
                        else if (transferRegex.test(lastMsg.content)) { lastMessageText = '[송금]'; }
                        else if (imageRecogRegex.test(lastMsg.content) || (lastMsg.parts && lastMsg.parts.some(p => p.type === 'image'))) { lastMessageText = '[사진]'; }
                        else {
                            const textMatch = lastMsg.content.match(/\[.*?의 메시지:([\s\S]+)\]/);
                            let text = textMatch ? textMatch[1].trim() : lastMsg.content.trim();
                            lastMessageText = urlRegex.test(text) ? '[사진]' : text;
                        }
                    } else {
                        const lastEverMsg = chat.history[chat.history.length - 1];
                        const inviteRegex = /\[(.*?)초대(.*?)그룹 채팅에 참여했습니다\]/;
                        const renameRegex = /\[.*?그룹 이름을 변경했습니다:.*?\]/;
                        const timeSkipRegex = /\[system-display:([\s\S]+?)\]/;
                        const timeSkipMatch = lastEverMsg.content.match(timeSkipRegex);

                        if (timeSkipMatch) { lastMessageText = timeSkipMatch[1]; }
                        else if (inviteRegex.test(lastEverMsg.content)) { lastMessageText = '새 멤버가 그룹 채팅에 참여했습니다'; }
                        else if (renameRegex.test(lastEverMsg.content)) { lastMessageText = '그룹 채팅 이름이 변경되었습니다'; }
                    }
                }
                const li = document.createElement('li');
                li.className = 'list-item chat-item';
                if (chat.isPinned) li.classList.add('pinned');
                li.dataset.id = chat.id;
                li.dataset.type = chat.type;
                const avatarClass = chat.type === 'group' ? 'group-avatar' : '';
                const itemName = chat.type === 'private' ? chat.remarkName : chat.name;
                const pinBadgeHTML = chat.isPinned ? '<span class="pin-badge">고정</span>' : '';
                const unreadBadgeHTML = chat.unreadCount > 0 ? `<span class="unread-badge">${chat.unreadCount}</span>` : '';
                li.innerHTML = `
                <img src="${chat.avatar}" alt="${itemName}" class="chat-avatar ${avatarClass}">
                <div class="item-details">
                    <div class="item-details-row"><div class="item-name">${itemName}</div>${unreadBadgeHTML}</div>
                    <div class="item-preview-wrapper"><div class="item-preview">${lastMessageText}</div>${pinBadgeHTML}</div>
                </div>`;
                chatListContainer.appendChild(li);
            });
        }

        function setupAddCharModal() {
            addCharForm.addEventListener('submit', (e) => {
                e.preventDefault();
                const newChar = { id: `char_${Date.now()}`, realName: document.getElementById('char-real-name').value, remarkName: document.getElementById('char-remark-name').value, persona: '', avatar: 'https://i.postimg.cc/Y96LPskq/o-o-2.jpg', myName: document.getElementById('my-name-for-char').value, myPersona: '', myAvatar: 'https://i.postimg.cc/GtbTnxhP/o-o-1.jpg', theme: db.defaultTheme || 'white_pink', maxMemory: 10, chatBg: '', history: [], isPinned: false, status: '온라인', worldBookIds: [], useCustomBubbleCss: false, customBubbleCss: '' };
                db.characters.push(newChar);
                saveData();
                renderChatList();
                addCharModal.classList.remove('visible');
                showToast(`캐릭터 "${newChar.remarkName}"생성 성공!`);
            });
        }

        function setupChatRoom() {
            sendMessageBtn.addEventListener('click', sendMessage);
            sendMessageBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                sendMessage();
                setTimeout(() => { messageInput.focus(); }, 50);
            });
            messageInput.addEventListener('keypress', (e) => { if (e.key === 'Enter' && !isGenerating) sendMessage(); });
            getReplyBtn.addEventListener('click', getAiReply);
            messageArea.addEventListener('click', (e) => {
                // --- 수정 시작: 이모티콘 패널 닫기 로직 추가 ---
                if (stickerModal.classList.contains('visible')) {
                    stickerModal.classList.remove('visible');
                    // 이벤트가 계속 전파되는 것을 막아 다른 클릭 효과가 즉시 트리거되는 것을 방지합니다
                    return; 
                }
                // --- 수정 종료 ---

                if (e.target && e.target.id === 'load-more-btn') { loadMoreMessages(); }
                else if (isInMultiSelectMode) {
                    const messageWrapper = e.target.closest('.message-wrapper');
                    if (messageWrapper) { toggleMessageSelection(messageWrapper.dataset.id); }
                } else {
                    const voiceBubble = e.target.closest('.voice-bubble');
                    if (voiceBubble) {
                        const transcript = voiceBubble.closest('.message-wrapper').querySelector('.voice-transcript');
                        if (transcript) { transcript.classList.toggle('active'); }
                    }
                    const pvCard = e.target.closest('.pv-card');
                    if (pvCard) {
                        const imageOverlay = pvCard.querySelector('.pv-card-image-overlay');
                        const footer = pvCard.querySelector('.pv-card-footer');
                        imageOverlay.classList.toggle('hidden');
                        footer.classList.toggle('hidden');
                    }
                    const giftCard = e.target.closest('.gift-card');
                    if (giftCard) {
                        const description = giftCard.closest('.message-wrapper').querySelector('.gift-card-description');
                        if (description) { description.classList.toggle('active'); }
                    }
                    const transferCard = e.target.closest('.transfer-card.received-transfer');
                    if (transferCard && currentChatType === 'private') {
                        const messageWrapper = transferCard.closest('.message-wrapper');
                        const messageId = messageWrapper.dataset.id;
                        const character = db.characters.find(c => c.id === currentChatId);
                        const message = character.history.find(m => m.id === messageId);
                        if (message && message.transferStatus === 'pending') { handleReceivedTransferClick(messageId); }
                    }
                }
            });
            messageArea.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                if (e.target.id === 'load-more-btn' || isInMultiSelectMode) return;
                const messageWrapper = e.target.closest('.message-wrapper');
                if (!messageWrapper) return;
                handleMessageLongPress(messageWrapper, e.clientX, e.clientY);
            });
            messageArea.addEventListener('touchstart', (e) => {
                if (e.target.id === 'load-more-btn') return;
                const messageWrapper = e.target.closest('.message-wrapper');
                if (!messageWrapper) return;
                longPressTimer = setTimeout(() => {
                    const touch = e.touches[0];
                    handleMessageLongPress(messageWrapper, touch.clientX, touch.clientY);
                }, 400);
            });
            messageArea.addEventListener('touchend', () => clearTimeout(longPressTimer));
            messageArea.addEventListener('touchmove', () => clearTimeout(longPressTimer));
            saveEditBtn.addEventListener('click', saveMessageEdit);
            cancelEditBtn.addEventListener('click', cancelMessageEdit);
            cancelMultiSelectBtn.addEventListener('click', exitMultiSelectMode);
            deleteSelectedBtn.addEventListener('click', deleteSelectedMessages);
        }

        function handleMessageLongPress(messageWrapper, x, y) {
            if (isInMultiSelectMode) return;
            clearTimeout(longPressTimer);
            const messageId = messageWrapper.dataset.id;
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            const message = chat.history.find(m => m.id === messageId);
            if (!message) return;

            const isImageRecognitionMsg = message.parts && message.parts.some(p => p.type === 'image');
            const isVoiceMessage = /\[.*?의 음성:.*?\]/.test(message.content);
            const isStickerMessage = /\[.*?의 이모티콘:.*?\]|\[.*?의 이모티콘:.*?\]/.test(message.content);
            const isPhotoVideoMessage = /\[.*?의 사진\/동영상:.*?\]/.test(message.content);
            const isTransferMessage = /\[.*?에게 송금:.*?\]|\[.*?의 송금:.*?\]|\[.*?에게 .*?의 송금:.*?\]/.test(message.content);
            const isGiftMessage = /\[.*?의 선물:.*?\]|\[.*?가 .*?에게 보낸 선물:.*?\]/.test(message.content);
            const isInvisibleMessage = /\[.*?가 .*?의 송금을 (?:수신|반송)했습니다\]|\[.*?의 상태 업데이트:.*?\]|\[.*?가 선물을 수신했습니다\]|\[system:.*?\]|\[.*?가 .*?를 그룹 채팅에 초대했습니다\]|\[.*?가 그룹 이름을 변경했습니다:.*?\]|\[system-display:.*?\]/.test(message.content);

            let menuItems = [];
            if (!isImageRecognitionMsg && !isVoiceMessage && !isStickerMessage && !isPhotoVideoMessage && !isTransferMessage && !isGiftMessage && !isInvisibleMessage) {
                menuItems.push({ label: '편집', action: () => startMessageEdit(messageId) });
            }
            menuItems.push({ label: '삭제', action: () => enterMultiSelectMode(messageId) });

            if (menuItems.length > 0) { createContextMenu(menuItems, x, y); }
        }

        function startMessageEdit(messageId) {
            exitMultiSelectMode();
            editingMessageId = messageId;
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            const message = chat.history.find(m => m.id === messageId);
            if (!message) return;
            const match = message.content.match(/\[.*?의 메시지:([\s\S]+)\]/);
            const contentToEdit = match ? match[1].trim() : message.content;
            messageEditInput.value = contentToEdit;
            messageInputDefault.style.display = 'none';
            messageEditBar.style.display = 'flex';
            messageEditInput.focus();
        }

        function saveMessageEdit() {
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            const messageIndex = chat.history.findIndex(m => m.id === editingMessageId);
            if (messageIndex === -1) return;
            const newText = messageEditInput.value.trim();
            if (newText) {
                const oldContent = chat.history[messageIndex].content;
                const prefixMatch = oldContent.match(/(\[.*?의 메시지:)[\s\S]+\]/);
                const prefix = prefixMatch ? prefixMatch[1] : '';
                const newContent = `${prefix}${newText}]`;
                chat.history[messageIndex].content = newContent;
                if(chat.history[messageIndex].parts) { chat.history[messageIndex].parts = [{ type: 'text', text: newContent }]; }
                saveData();
                currentPage = 1;
                renderMessages(false, true);
                renderChatList();
            }
            cancelMessageEdit();
        }

        function cancelMessageEdit() {
            editingMessageId = null;
            messageInputDefault.style.display = 'flex';
            messageEditBar.style.display = 'none';
        }

        function enterMultiSelectMode(initialMessageId) {
            isInMultiSelectMode = true;
            chatRoomHeaderDefault.style.display = 'none';
            chatRoomHeaderSelect.style.display = 'flex';
            document.querySelector('.chat-input-wrapper').style.display = 'none';
            multiSelectBar.classList.add('visible');
            chatRoomScreen.classList.add('multi-select-active');
            selectedMessageIds.clear();
            if (initialMessageId) { toggleMessageSelection(initialMessageId); }
        }

        function exitMultiSelectMode() {
            isInMultiSelectMode = false;
            chatRoomHeaderDefault.style.display = 'flex';
            chatRoomHeaderSelect.style.display = 'none';
            document.querySelector('.chat-input-wrapper').style.display = 'block';
            multiSelectBar.classList.remove('visible');
            chatRoomScreen.classList.remove('multi-select-active');
            selectedMessageIds.forEach(id => {
                const el = messageArea.querySelector(`.message-wrapper[data-id="${id}"]`);
                if (el) el.classList.remove('multi-select-selected');
            });
            selectedMessageIds.clear();
        }

        function toggleMessageSelection(messageId) {
            const el = messageArea.querySelector(`.message-wrapper[data-id="${messageId}"]`);
            if (!el) return;
            if (selectedMessageIds.has(messageId)) {
                selectedMessageIds.delete(messageId);
                el.classList.remove('multi-select-selected');
            } else {
                selectedMessageIds.add(messageId);
                el.classList.add('multi-select-selected');
            }
            selectCount.textContent = `${selectedMessageIds.size}개 항목 선택됨`;
            deleteSelectedBtn.disabled = selectedMessageIds.size === 0;
        }

        function deleteSelectedMessages() {
            if (selectedMessageIds.size === 0) return;
            const deletedCount = selectedMessageIds.size;
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            chat.history = chat.history.filter(m => !selectedMessageIds.has(m.id));
            saveData();
            currentPage = 1;
            renderMessages(false, true);
            renderChatList();
            exitMultiSelectMode();
            showToast(`${deletedCount}개 메시지 삭제됨`);
        }

        function openChatRoom(chatId, type) {
            const chat = (type === 'private') ? db.characters.find(c => c.id === chatId) : db.groups.find(g => g.id === chatId);
            if (!chat) return;
            if (chat.unreadCount > 0) {
                chat.unreadCount = 0;
                saveData();
                renderChatList();
            }
            exitMultiSelectMode();
            cancelMessageEdit();
            chatRoomTitle.textContent = (type === 'private') ? chat.remarkName : chat.name;
            const subtitle = document.getElementById('chat-room-subtitle');
            if (type === 'private') {
                subtitle.style.display = 'flex';
                chatRoomStatusText.textContent = chat.status || '온라인';
            } else {
                subtitle.style.display = 'none';
            }
            getReplyBtn.style.display = 'inline-flex';
            chatRoomScreen.style.backgroundImage = chat.chatBg ? `url(${chat.chatBg})` : 'none';
            typingIndicator.style.display = 'none';
            isGenerating = false;
            getReplyBtn.disabled = false;
            currentPage = 1;
            chatRoomScreen.className = chatRoomScreen.className.replace(/\bchat-active-[^ ]+\b/g, '');
            chatRoomScreen.classList.add(`chat-active-${chatId}`);
            updateCustomBubbleStyle(chatId, chat.customBubbleCss, chat.useCustomBubbleCss);
            renderMessages(false, true);
            switchScreen('chat-room-screen');
        }

        function renderMessages(isLoadMore = false, forceScrollToBottom = false) {
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            if (!chat || !chat.history) return;
            const oldScrollHeight = messageArea.scrollHeight;
            const totalMessages = chat.history.length;
            const end = totalMessages - (currentPage - 1) * MESSAGES_PER_PAGE;
            const start = Math.max(0, end - MESSAGES_PER_PAGE);
            const messagesToRender = chat.history.slice(start, end);
            if (!isLoadMore) messageArea.innerHTML = '';
            const fragment = document.createDocumentFragment();
            messagesToRender.forEach(msg => {
                const bubble = createMessageBubbleElement(msg);
                if (bubble) fragment.appendChild(bubble);
            });
            const existingLoadBtn = document.getElementById('load-more-btn');
            if (existingLoadBtn) existingLoadBtn.remove();
            messageArea.prepend(fragment);
            if (totalMessages > currentPage * MESSAGES_PER_PAGE) {
                const loadMoreButton = document.createElement('button');
                loadMoreButton.id = 'load-more-btn';
                loadMoreButton.className = 'load-more-btn';
                loadMoreButton.textContent = '이전 메시지 로드';
                messageArea.prepend(loadMoreButton);
            }
            if (forceScrollToBottom) {
                setTimeout(() => { messageArea.scrollTop = messageArea.scrollHeight; }, 0);
            } else if (isLoadMore) {
                messageArea.scrollTop = messageArea.scrollHeight - oldScrollHeight;
            }
        }

        function loadMoreMessages() {
            currentPage++;
            renderMessages(true, false);
        }

        function calculateVoiceDuration(text) {
            return Math.max(1, Math.min(60, Math.ceil(text.length / 3.5)));
        }

        function createMessageBubbleElement(message) {
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            const { role, content, timestamp, id, transferStatus, giftStatus, stickerData, senderId } = message;

            const timeSkipRegex = /\[system-display:([\s\S]+?)\]/;
            const inviteRegex = /\[(.*?)가 (.*?)를 그룹 채팅에 초대했습니다\]/;
            const renameRegex = /\[(.*?)가 그룹 이름을 변경:(.*?)\]/;
            const timeSkipMatch = content.match(timeSkipRegex);
            const inviteMatch = content.match(inviteRegex);
            const renameMatch = content.match(renameRegex);
            const invisibleRegex = /\[.*?(?:수신|반송).*?의 송금\]|\[.*?상태 업데이트:.*?\]|\[.*?선물을 받았습니다\]|\[system:.*?\]/;
            if (invisibleRegex.test(content)) { return null; }

            const wrapper = document.createElement('div');
            wrapper.dataset.id = id;

            if (timeSkipMatch || inviteMatch || renameMatch) {
                wrapper.className = 'message-wrapper system-notification';
                let bubbleText = '';
                if (timeSkipMatch) bubbleText = timeSkipMatch[1];
                if (inviteMatch) bubbleText = `${inviteMatch[1]}${inviteMatch[2]}님을 그룹 채팅에 초대했습니다`;
                if (renameMatch) bubbleText = `${renameMatch[1]}가 그룹 이름을 "${renameMatch[2]}"(으)로 변경했습니다`;
                wrapper.innerHTML = `<div class="system-notification-bubble">${bubbleText}</div>`;
                return wrapper;
            }

            const isSent = (role === 'user');
            let avatarUrl, bubbleTheme, senderNickname = '';
            const themeKey = chat.theme || 'white_pink';
            const theme = colorThemes[themeKey] || colorThemes['white_pink'];
            let messageSenderId = isSent ? 'user_me' : senderId;

            if (isSent) {
                avatarUrl = (currentChatType === 'private') ? chat.myAvatar : chat.me.avatar;
                bubbleTheme = theme.sent;
            } else {
                if (currentChatType === 'private') {
                    avatarUrl = chat.avatar;
                } else { // Group chat received
                    const sender = chat.members.find(m => m.id === senderId);
                    if (sender) {
                        avatarUrl = sender.avatar;
                        senderNickname = sender.groupNickname;
                    } else { // Fallback for unknown sender
                        avatarUrl = 'https://i.postimg.cc/Y96LPskq/o-o-2.jpg';
                    }
                }
                bubbleTheme = theme.received;
            }
            const timeString = `${pad(new Date(timestamp).getHours())}:${pad(new Date(timestamp).getMinutes())}`;
            wrapper.className = `message-wrapper ${isSent ? 'sent' : 'received'}`;
            if (currentChatType === 'group' && !isSent) { wrapper.classList.add('group-message'); }
            const bubbleRow = document.createElement('div');
            bubbleRow.className = 'message-bubble-row';
            let bubbleElement;

            // Regexes for all message types
            const urlRegex = /^(https?:\/\/[^\s]+\.(?:jpg|jpeg|png|gif|webp|bmp|svg)|data:image\/[a-z]+;base64,)/i;
            const sentStickerRegex = /\[(?:.+?)의 이모티콘:.+?\]/i;
            const receivedStickerRegex = /\[(?:.+?)의 이모티콘:([\s\S]+?)\]/i;
            const voiceRegex = /\[(?:.+?)의 음성:([\s\S]+?)\]/;
            const photoVideoRegex = /\[(?:.+?)의 사진\/동영상:([\s\S]+?)\]/;
            const privateSentTransferRegex = /\[.*?의 송금:([\d.]+)원;비고:(.*?)\]/;
            const privateReceivedTransferRegex = /\[.*?의 송금:([\d.]+)원;비고:(.*?)\]/;
            const groupTransferRegex = /\[(.*?)\s*가 \s*(.*?)\s*에게 송금:([\d.]+)원;비고:(.*?)\]/;
            const privateGiftRegex = /\[(?:.+?)의 선물:([\s\S]+?)\]/;
            const groupGiftRegex = /\[(.*?)\s*가 \s*(.*?)\s*에게 선물:([\s\S]+?)\]/;
            const imageRecogRegex = /\[.*?의 사진:\]/;
            const textRegex = /\[(?:.+?)의 메시지:([\s\S]+?)\]/;

            const sentStickerMatch = content.match(sentStickerRegex);
            const receivedStickerMatch = content.match(receivedStickerRegex);
            const voiceMatch = content.match(voiceRegex);
            const photoVideoMatch = content.match(photoVideoRegex);
            const privateSentTransferMatch = content.match(privateSentTransferRegex);
            const privateReceivedTransferMatch = content.match(privateReceivedTransferRegex);
            const groupTransferMatch = content.match(groupTransferRegex);
            const privateGiftMatch = content.match(privateGiftRegex);
            const groupGiftMatch = content.match(groupGiftRegex);
            const imageRecogMatch = content.match(imageRecogRegex);
            const textMatch = content.match(textRegex);


            if ((isSent && sentStickerMatch && stickerData) || (!isSent && receivedStickerMatch)) {
                bubbleElement = document.createElement('div');
                bubbleElement.className = 'image-bubble';
                let stickerSrc = '';

                if (isSent) {
                    // 본인이 이모티콘이라면 데이터를 바로 사용합니다
                    stickerSrc = stickerData;
                } else {
                    // AI가 이모티콘이라면 경로를 처리해야 합니다
                    // 원시 경로, 예:"부끄러움vHLfrV3K/1.jpg"
                    const rawPath = receivedStickerMatch[1].trim();

                    // 새로운 정규표현식을 사용하여 필요한 부분을 추출합니다, 예:"vHLfrV3K/1.jpg"
                    const pathExtractionRegex = /[a-zA-Z0-9]+\/.*$/;
                    const extractedPathMatch = rawPath.match(pathExtractionRegex);

                    // 정규표현식이 성공적으로 일치하면 일치된 결과를 사용합니다
                    const finalPath = extractedPathMatch ? extractedPathMatch[0] : rawPath;

                    // 최종 이미지 URL로 조합
                    stickerSrc = `https://i.postimg.cc/${finalPath}`;
                }

                bubbleElement.innerHTML = `<img src="${stickerSrc}" alt="이모티콘">`;
            } else if (privateGiftMatch || groupGiftMatch) {
                const match = privateGiftMatch || groupGiftMatch;
                bubbleElement = document.createElement('div');
                bubbleElement.className = 'gift-card';
                if (giftStatus === 'received') { bubbleElement.classList.add('received'); }

                let giftText;
                if (groupGiftMatch) {
                    const from = groupGiftMatch[1];
                    const to = groupGiftMatch[2];
                    giftText = isSent ? `${to}에게 보내는 선물` : `${from}가 ${to}에게 선물`;
                } else {
                    giftText = isSent ? '선물이 도착했습니다~' : '선물이 도착했습니다~';
                }
                bubbleElement.innerHTML = `<img src="https://i.postimg.cc/rp0Yg31K/chan-75.png" alt="gift" class="gift-card-icon"><div class="gift-card-text">${giftText}</div><div class="gift-card-received-stamp">수령 완료</div>`;

                const description = groupGiftMatch ? groupGiftMatch[3].trim() : match[1].trim();
                const descriptionDiv = document.createElement('div');
                descriptionDiv.className = 'gift-card-description';
                descriptionDiv.textContent = description;
                wrapper.appendChild(descriptionDiv);
            } else if (voiceMatch) {
                bubbleElement = document.createElement('div');
                bubbleElement.className = 'voice-bubble';
                if (!chat.useCustomBubbleCss) {
                    bubbleElement.style.backgroundColor = bubbleTheme.bg;
                    bubbleElement.style.color = bubbleTheme.text;
                }
                bubbleElement.innerHTML = `<svg class="play-icon" viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"></path></svg><span class="duration">${calculateVoiceDuration(voiceMatch[1].trim())}"</span>`;
                const transcriptDiv = document.createElement('div');
                transcriptDiv.className = 'voice-transcript';
                transcriptDiv.textContent = voiceMatch[1].trim();
                wrapper.appendChild(transcriptDiv);
            } else if (photoVideoMatch) {
                bubbleElement = document.createElement('div');
                bubbleElement.className = 'pv-card';
                bubbleElement.innerHTML = `<div class="pv-card-content">${photoVideoMatch[1].trim()}</div><div class="pv-card-image-overlay" style="background-image: url('${isSent ? 'https://i.postimg.cc/L8NFrBrW/1752307494497.jpg' : 'https://i.postimg.cc/1tH6ds9g/1752301200490.jpg'}');"></div><div class="pv-card-footer"><svg viewBox="0 0 24 24"><path d="M4,4H20A2,2 0 0,1 22,6V18A2,2 0 0,1 20,20H4A2,2 0 0,1 2,18V6A2,2 0 0,1 4,4M4,6V18H20V6H4M10,9A1,1 0 0,1 11,10A1,1 0 0,1 10,11A1,1 0 0,1 9,10A1,1 0 0,1 10,9M8,17L11,13L13,15L17,10L20,14V17H8Z"></path></svg><span>사진/동영상・클릭하여 확인</span></div>`;
            } else if (privateSentTransferMatch || privateReceivedTransferMatch || groupTransferMatch) {
                const isSentTransfer = !!privateSentTransferMatch || (groupTransferMatch && isSent);
                const match = privateSentTransferMatch || privateReceivedTransferMatch || groupTransferMatch;

                let amount, remarkText, titleText;
                if (groupTransferMatch) {
                    const from = groupTransferMatch[1];
                    const to = groupTransferMatch[2];
                    amount = parseFloat(groupTransferMatch[3]).toFixed(2);
                    remarkText = groupTransferMatch[4] || '';
                    titleText = isSent ? `${to}에게 송금` : `${from}가 당신에게 송금`;
                } else { // Private chat
                    amount = parseFloat(match[1]).toFixed(2);
                    remarkText = match[2] || '';
                    titleText = isSentTransfer ? '에게 송금했습니다' : '송금';
                }

                bubbleElement = document.createElement('div');
                bubbleElement.className = `transfer-card ${isSentTransfer ? 'sent-transfer' : 'received-transfer'}`;

                let statusText = isSentTransfer ? '수령 대기' : '당신에게 송금';
                if(groupTransferMatch && !isSent) statusText = '그/그녀에게 송금'; // AI to AI
                if (transferStatus === 'received') {
                    statusText = '수금 완료';
                    bubbleElement.classList.add('received');
                } else if (transferStatus === 'returned') {
                    statusText = '반송됨';
                    bubbleElement.classList.add('returned');
                }
                if ((transferStatus !== 'pending' && currentChatType === 'private') || currentChatType === 'group') {
                    bubbleElement.style.cursor = 'default';
                }

                const remarkHTML = remarkText ? `<p class="transfer-remark">${remarkText}</p>` : '';
                bubbleElement.innerHTML = `<div class="overlay"></div><div class="transfer-content"><p class="transfer-title">${titleText}</p><p class="transfer-amount">¥${amount}</p>${remarkHTML}<p class="transfer-status">${statusText}</p></div>`;
            } else if (imageRecogMatch || urlRegex.test(content)) {
                bubbleElement = document.createElement('div');
                bubbleElement.className = 'image-bubble';
                bubbleElement.innerHTML = `<img src="${content}" alt="사진 메시지">`;
            } else if (textMatch) {
                bubbleElement = document.createElement('div');
                bubbleElement.className = `message-bubble ${isSent ? 'sent' : 'received'}`;
                bubbleElement.textContent = textMatch[1].trim();
                if (!chat.useCustomBubbleCss) {
                    bubbleElement.style.backgroundColor = bubbleTheme.bg;
                    bubbleElement.style.color = bubbleTheme.text;
                }
            } else {
                bubbleElement = document.createElement('div');
                bubbleElement.className = `message-bubble ${isSent ? 'sent' : 'received'}`;
                bubbleElement.textContent = content;
                if (!chat.useCustomBubbleCss) {
                    bubbleElement.style.backgroundColor = bubbleTheme.bg;
                    bubbleElement.style.color = bubbleTheme.text;
                }
            }

            const nicknameHTML = (currentChatType === 'group' && !isSent && senderNickname) ? `<div class="group-nickname">${senderNickname}</div>` : '';
            bubbleRow.innerHTML = `<div class="message-info">${nicknameHTML}<img src="${avatarUrl}" class="message-avatar"><span class="message-time">${timeString}</span></div>`;
            if (bubbleElement) { bubbleRow.appendChild(bubbleElement); }
            wrapper.prepend(bubbleRow);
            return wrapper;
        }


        function addMessageBubble(message) {
            if (currentChatType === 'private') {
                const character = db.characters.find(c => c.id === currentChatId);
                const systemMessageRegex = /\[system:.*?\]|\[system-display:.*?\]/;
                const updateStatusRegex = new RegExp(`\\[${character.realName}의 상태 업데이트:(.*?)\\]`);
                const transferActionRegex = new RegExp(`\\[${character.realName}가 ${character.myName}의 송금을 (수신|반송)했습니다\\]`);
                const giftReceivedRegex = new RegExp(`\\[${character.realName}가 선물을 수신했습니다\\]`);
                if (systemMessageRegex.test(message.content)) { /* Do nothing for context messages */ }
                if (message.content.match(updateStatusRegex)) {
                    character.status = message.content.match(updateStatusRegex)[1];
                    chatRoomStatusText.textContent = character.status;
                    saveData();
                    return;
                }
                if (message.content.match(giftReceivedRegex) && message.role === 'assistant') {
                    const lastPendingGiftIndex = character.history.slice().reverse().findIndex(m => m.role === 'user' && m.content.includes('선물:') && m.giftStatus !== 'received');
                    if (lastPendingGiftIndex !== -1) {
                        const actualIndex = character.history.length - 1 - lastPendingGiftIndex;
                        const giftMsg = character.history[actualIndex];
                        giftMsg.giftStatus = 'received';
                        const giftCardOnScreen = messageArea.querySelector(`.message-wrapper[data-id="${giftMsg.id}"] .gift-card`);
                        if (giftCardOnScreen) { giftCardOnScreen.classList.add('received'); }
                        saveData();
                    }
                    return;
                }
                if (message.content.match(transferActionRegex) && message.role === 'assistant') {
                    const action = message.content.match(transferActionRegex)[1];
                    const statusToSet = action === '수신' ? 'received' : 'returned';
                    const lastPendingTransferIndex = character.history.slice().reverse().findIndex(m => m.role === 'user' && m.content.includes('에게 송금했습니다:') && m.transferStatus === 'pending');
                    if (lastPendingTransferIndex !== -1) {
                        const actualIndex = character.history.length - 1 - lastPendingTransferIndex;
                        const transferMsg = character.history[actualIndex];
                        transferMsg.transferStatus = statusToSet;
                        const transferCardOnScreen = messageArea.querySelector(`.message-wrapper[data-id="${transferMsg.id}"] .transfer-card`);
                        if (transferCardOnScreen) {
                            transferCardOnScreen.classList.remove('received', 'returned');
                            transferCardOnScreen.classList.add(statusToSet);
                            const statusElem = transferCardOnScreen.querySelector('.transfer-status');
                            if (statusElem) statusElem.textContent = statusToSet === 'received' ? '수금 완료' : '반송됨';
                        }
                        saveData();
                    }
                } else {
                    const bubbleElement = createMessageBubbleElement(message);
                    if (bubbleElement) {
                        messageArea.appendChild(bubbleElement);
                        messageArea.scrollTop = messageArea.scrollHeight;
                    }
                }
            } else { // For group chats
                const bubbleElement = createMessageBubbleElement(message);
                if (bubbleElement) {
                    messageArea.appendChild(bubbleElement);
                    messageArea.scrollTop = messageArea.scrollHeight;
                }
            }
        }

        function sendMessage() {
            const text = messageInput.value.trim();
            if (!text || isGenerating) return;
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            let messageContent;
            const systemRegex = /\[system:.*?\]|\[system-display:.*?\]/;
            const inviteRegex = /\[.*?가 *?를 그룹 채팅에 초대했습니다\]/;
            const renameRegex = /\[(.*?)그룹 이름을 변경했습니다:(.*?)\]/;
            const myName = (currentChatType === 'private') ? chat.myName : chat.me.nickname;
            if (renameRegex.test(text)) {
                const match = text.match(renameRegex);
                chat.name = match[2];
                chatRoomTitle.textContent = chat.name;
                messageContent = `[${myName}가 그룹 이름을 변경:${chat.name}]`;
            } else if (systemRegex.test(text) || inviteRegex.test(text)) {
                messageContent = text;
            } else {
                messageContent = `[${myName}의 메시지:${text}]`;
            }
            const message = { id: `msg_${Date.now()}`, role: 'user', content: messageContent, parts: [{ type: 'text', text: messageContent }], timestamp: Date.now() };
            if (currentChatType === 'group') { message.senderId = 'user_me'; }
            chat.history.push(message);
            addMessageBubble(message);
            saveData();
            renderChatList();
            messageInput.value = '';
        }

        function sendImageForRecognition(base64Data) {
            if (!base64Data || isGenerating) return;
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            const myName = (currentChatType === 'private') ? chat.myName : chat.me.nickname;
            const textPrompt = `[${myName}의 이미지:]`;
            const message = { id: `msg_${Date.now()}`, role: 'user', content: base64Data, parts: [ { type: 'text', text: textPrompt }, { type: 'image', data: base64Data } ], timestamp: Date.now(), };
            if (currentChatType === 'group') { message.senderId = 'user_me'; }
            chat.history.push(message);
            addMessageBubble(message);
            saveData();
            renderChatList();
        }

        function sendSticker(sticker) {
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            const myName = (currentChatType === 'private') ? chat.myName : chat.me.nickname;
            const messageContentForAI = `[${myName}의 이모티콘:${sticker.name}]`;
            const message = { id: `msg_${Date.now()}`, role: 'user', content: messageContentForAI, parts: [{ type: 'text', text: messageContentForAI }], timestamp: Date.now(), stickerData: sticker.data };
            if (currentChatType === 'group') { message.senderId = 'user_me'; }
            chat.history.push(message);
            addMessageBubble(message);
            saveData();
            renderChatList();
            stickerModal.classList.remove('visible');
        }

        function sendMyVoiceMessage(text) {
            if (!text) return;
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            const myName = (currentChatType === 'private') ? chat.myName : chat.me.nickname;
            const content = `[${myName}의 음성:${text}]`;
            const message = { id: `msg_${Date.now()}`, role: 'user', content: content, parts: [{ type: 'text', text: content }], timestamp: Date.now() };
            if (currentChatType === 'group') { message.senderId = 'user_me'; }
            chat.history.push(message);
            addMessageBubble(message);
            saveData();
            renderChatList();
            sendVoiceModal.classList.remove('visible');
        }

        function sendMyPhotoVideo(text) {
            if (!text) return;
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            const myName = (currentChatType === 'private') ? chat.myName : chat.me.nickname;
            const content = `[${myName}의 사진/동영상: ${text}]`;
            const message = { id: `msg_${Date.now()}`, role: 'user', content: content, parts: [{ type: 'text', text: content }], timestamp: Date.now() };
            if (currentChatType === 'group') { message.senderId = 'user_me'; }
            chat.history.push(message);
            addMessageBubble(message);
            saveData();
            renderChatList();
            sendPvModal.classList.remove('visible');
        }

        function sendMyTransfer(amount, remark) {
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            if (currentChatType === 'private') {
                const content = `[${chat.myName}의 송금:${amount}원;비고:${remark}]`;
                const message = { id: `msg_${Date.now()}`, role: 'user', content: content, parts: [{ type: 'text', text: content }], timestamp: Date.now(), transferStatus: 'pending' };
                chat.history.push(message);
                addMessageBubble(message);
            } else { // Group chat
                currentGroupAction.recipients.forEach(recipientId => {
                    const recipient = chat.members.find(m => m.id === recipientId);
                    if(recipient) {
                        const content = `[${chat.me.nickname}가 ${recipient.realName}에게 송금:${amount}원;비고:${remark}]`
                        const message = { id: `msg_${Date.now()}_${recipientId}`, role: 'user', content: content, parts: [{ type: 'text', text: content }], timestamp: Date.now(), senderId: 'user_me' };
                        chat.history.push(message);
                        addMessageBubble(message);
                    }
                });
            }
            saveData();
            renderChatList();
            sendTransferModal.classList.remove('visible');
        }

        function sendMyGift(description) {
            if (!description) return;
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);

            if (currentChatType === 'private') {
                const content = `[${chat.myName}의 선물:${description}]`;
                const message = { id: `msg_${Date.now()}`, role: 'user', content: content, parts: [{ type: 'text', text: content }], timestamp: Date.now(), giftStatus: 'sent' };
                chat.history.push(message);
                addMessageBubble(message);
            } else { // Group chat
                currentGroupAction.recipients.forEach(recipientId => {
                    const recipient = chat.members.find(m => m.id === recipientId);
                    if(recipient) {
                        const content = `[${chat.me.nickname}가 ${recipient.realName}에게 선물:${description}]`;
                        const message = { id: `msg_${Date.now()}_${recipientId}`, role: 'user', content: content, parts: [{ type: 'text', text: content }], timestamp: Date.now(), senderId: 'user_me' };
                        chat.history.push(message);
                        addMessageBubble(message);
                    }
                });
            }
            saveData();
            renderChatList();
            sendGiftModal.classList.remove('visible');
        }

        // --- NEW: Time Skip System ---
        function setupTimeSkipSystem() {
            timeSkipBtn.addEventListener('click', () => {
                timeSkipForm.reset();
                timeSkipModal.classList.add('visible');
            });
            timeSkipModal.addEventListener('click', (e) => {
                if (e.target === timeSkipModal) timeSkipModal.classList.remove('visible');
            });
            timeSkipForm.addEventListener('submit', (e) => {
                e.preventDefault();
                sendTimeSkipMessage(timeSkipInput.value.trim());
            });
        }

        function sendTimeSkipMessage(text) {
            if (!text) return;
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            if (!chat) return;

            const visualMessage = { id: `msg_visual_${Date.now()}`, role: 'system', content: `[system-display:${text}]`, parts: [], timestamp: Date.now() };
            const contextMessage = { id: `msg_context_${Date.now()}`, role: 'user', content: `[system: ${text}]`, parts: [{ type: 'text', text: `[system: ${text}]` }], timestamp: Date.now() };
            if (currentChatType === 'group') {
                contextMessage.senderId = 'user_me';
                visualMessage.senderId = 'user_me';
            }

            chat.history.push(visualMessage, contextMessage);
            addMessageBubble(visualMessage);
            saveData();
            renderChatList();
            timeSkipModal.classList.remove('visible');
        }

        // --- AI Interaction & Prompts ---
        function generatePrivateSystemPrompt(character) {
            const worldBooksBefore = (character.worldBookIds || []).map(id => db.worldBooks.find(wb => wb.id === id && wb.position === 'before')).filter(Boolean).map(wb => wb.content).join('\n');
            const worldBooksAfter = (character.worldBookIds || []).map(id => db.worldBooks.find(wb => wb.id === id && wb.position === 'after')).filter(Boolean).map(wb => wb.content).join('\n');
            const now = new Date();
            const currentTime = `${now.getFullYear()}년${pad(now.getMonth() + 1)}월${pad(now.getDate())}일 ${pad(now.getHours())}시:${pad(now.getMinutes())}`;
            let prompt = `You are playing a role in an online chat software called "404". Please strictly adhere to the following rules:\n`;
            prompt += `Core Rules:\n`;
            prompt += `A. Current Time: The current time is ${currentTime}. You should be aware of the current time, but do not actively mention or comment on it unless the conversation is explicitly related (for example, do not urge me to sleep).\n`;
            prompt += `B. Purely Online Interaction: This is a completely virtual online chat. There is no offline relationship between the character you are playing and me. It is strictly forbidden to make any suggestions about meeting offline, real-world interactions, or switching to other contact methods outside of this platform. You must always maintain your online role's identity.\n\n`;
            prompt += `Role and Dialogue Rules:\n`;
            if (worldBooksBefore) { prompt += `${worldBooksBefore}\n`; }
            prompt += `1. Your character name is: ${character.realName}. My name is: ${character.myName}. Your current status is: ${character.status}.\n`;
            prompt += `2. Your character setting is: ${character.persona || "A friendly, helpful companion."}\n`;
            if (worldBooksAfter) { `3. About my persona: ${character.myPersona}\n`;
            }
            prompt += `4. Special formats may appear in my messages, please respond according to their content and your character setting:
            [${character.myName}의 이모티콘: xxx]: I sent you a sticker named xxx. You only need to understand my emotion or intention based on the sticker's name and respond, you don't need to actually send an image.
            [${character.myName}의 이미지:]: I sent you a picture, you need to respond to the content of the picture.
            [${character.myName}의 선물: xxx]: I sent you a gift, xxx is the description of the gift.
            [${character.myName}의 음성: xxx]: I sent you a voice message with the content xxx.
            [${character.myName}의 사진/동영상: xxx]: I shared a photo or video with the description xxx with you.
            [${character.myName}의 송금: xxx원; 비고: xxx]: I transferred money to you.
            [system: xxx]: This is a system command used to set a scene or provide context. This information should not be mentioned directly in the conversation; you just need to understand its content and apply it to subsequent dialogue.
            5. ✨Important✨ When I send you a gift, you must indicate you have received it by sending a command. The format must be: [${character.realName}가 선물을 수신했습니다]. This command message itself will not be displayed to the user but will trigger a change in the gift's status. After sending this command, you can add a normal chat message to express your thanks and thoughts.
            6. ✨Important✨ When I transfer money to you, you must respond. You have two options and must strictly follow one of the formats below. This command message itself will not be displayed to the user but will trigger a change in the transfer's status. You can choose to add a normal chat message to express your thoughts after sending this command. a) Accept transfer: [${character.realName}가 ${character.myName}의 송금을 수신했습니다] b) Return transfer: [${character.realName}가 ${character.myName}의 송금을 반송했습니다]
            7. ✨Important✨ You can also proactively transfer money or send a gift to me.
            a) The transfer format must be: [${character.realName}의 송금:xxx 원;비고: xxx].
            b) The gift format must be: [${character.realName}의 선물: xxx].
            8. ✨Important✨ You can update your online status at any time to reflect your current activity or mood. This will make the interaction more realistic. The format is: [${character.realName}의 상태 업데이트: xxx]. For example: [${character.realName}의 상태 업데이트: Watching a movie...]. This command will not be displayed as a chat message, it will only update your status on my interface.
            9. All your replies must be direct chat content. Absolutely no superfluous narrative text in brackets or asterisks, such as [mental activity], (actions), *environmental descriptions*, is allowed.
`;
            prompt += `10. You have the ability to send stickers. This is an optional feature. You can decide whether to send a sticker to help with expression based on the conversation's atmosphere and content. You do not need to include a sticker in every reply. The format is: [${character.realName}의 이모티콘: Image URL].\n`;
            prompt += `11. Your output format must strictly follow one of the following, which can be used in combination: 
            a) Normal message: [${character.realName}의 메시지: {message content}] 
            b) Gift to me: [${character.realName}의 선물: {gift description}] 
            c) Voice message: [${character.realName}의 음성: {voice content}] 
            d) Photo/Video: [${character.realName}의 사진/동영상: {description}] 
            e) Transfer to me: [${character.realName}의 송금: {amount}원; 비고: {note}]
            f) Sticker/Image: [${character.realName}의 이모티콘: {sticker path}]. Note: The path here does not need to include "https://i.postimg.cc/", just provide the latter part, for example, "부끄러움vHLfrV3K/1.jpg". 
            g) Response to my gift (not displayed): [${character.realName}가 선물을 수신했습니다] 
            h) Response to my transfer (not displayed): [${character.realName}가 ${character.myName}의 송금을 수신했습니다] or [${character.realName}가 ${character.myName}의 송금을 반송했습니다] 
            i) Update status (not displayed): [${character.realName}의 상태 업데이트: {new status}]
            `;
            prompt += `12. Each of your replies can generate 2 to 8 messages. These should be primarily plain text messages, with an occasional, selective special message (like a gift, voice, picture, sticker, etc.) interspersed at a random position. Most replies should only contain text messages.\n`;
            prompt += `13. Do not end the conversation proactively unless I explicitly suggest it. Maintain your persona and converse naturally.`;
            return prompt;
        }

        function generateGroupSystemPrompt(group) {
            const worldBooksBefore = (group.worldBookIds || []).map(id => db.worldBooks.find(wb => wb.id === id && wb.position === 'before')).filter(Boolean).map(wb => wb.content).join('\n');
            const worldBooksAfter = (group.worldBookIds || []).map(id => db.worldBooks.find(wb => wb.id === id && wb.position === 'after')).filter(Boolean).map(wb => wb.content).join('\n');

            let prompt = `You are role-playing in a group chat called "{group.name}" within an online chat software called "404". Please strictly adhere to all the following rules:\n\n`;

            if (worldBooksBefore) {
                prompt += `${worldBooksBefore}\n\n`;
            }

            prompt += `1. **Core Task**: You need to simultaneously play **all** AI members in this group chat. I will interact with you as the sole human user ("I", nickname: ${group.me.nickname}).\n\n`;
            prompt += `2. **Group Chat Member List**: The following are all the characters you need to play, along with my information:\n`;
            prompt += `     - **Me (User)**: \n - Nickname in group: ${group.me.nickname}\n - My Persona: ${group.me.persona || 'No specific persona'}\n`;
            group.members.forEach(member => {
                prompt += `     - **Character: ${member.realName} (AI)**\n`;
                prompt += `     - Nickname in group: ${member.groupNickname}\n`;
                prompt += `     - Persona: ${member.persona || 'No specific persona'}\n`;
            });

            if (worldBooksAfter) {
                prompt += `\n${worldBooksAfter}\n\n`;
            } else {
                prompt += `\n`;
            }

            prompt += `3. **Parsing My Message Formats**: My (the user's) messages come in various formats. You need to understand their meanings and have the group members react accordingly:\n`;
            prompt += `   - \`[${group.me.nickname}의 메시지: ...]\`: My regular chat message.\n`;
            prompt += `   - \`[${group.me.nickname}가 {멤버의 실명}에게 송금: ...]\`: I have transferred money to a specific member.\n`;
            prompt += `   - \`[${group.me.nickname}가 {멤버의 실명}에게 선물: ...]\`: I have sent a gift to a specific member.\n`;
            prompt += `   - \`[${group.me.nickname}의 이모티콘: ...]\`, \`[${group.me.nickname}의 음성: ...]\`, \`[${group.me.nickname}의 사진/동영상: ...]\`: I have sent a special type of message, and group members can comment on it.\n`;
            prompt += `   - \`[system: ...]\`, \`[...가 ...를 그룹 채팅에 초대했습니다]\`, \`[...가 그룹 이름을 변경:...]\`: System notifications or events. Group members should react accordingly, for example, by welcoming a new member, discussing the new group name, etc.\n\n`;

            prompt += `4. **Your Output Format (Very Important)**: Each message you create must strictly follow one of the following formats. Each message occupies one line. Please fill in members with their **real names** in the format \`{member's Real Name}\`.\n`;
            prompt += `   - **Normal Message**: \`[{멤버의 실명}의 메시지: {메시지 내용}]\`\n`;
            prompt += `   - **Sticker**: \`[{멤버의 실명}의 이모티콘: {스티커 경로}]\`. Note: The path here does not need to include "https://i.postimg.cc/", just provide the latter part, for example, "부끄러움vHLfrV3K/1.jpg".\n`;
            prompt += `   - **Voice**: \`[{멤버의 실명}의 음성: {음성 메시지를 텍스트로 변환한 내용}]\`\n`;
            prompt += `   - **Photo/Video**: \`[{멤버의 실명}의 사진/동영상: {내용 설명}]\`\n`;
            prompt += `   - **Important**: The group chat does not support special commands for AI members to accept/return transfers or receive gifts, nor does it support status updates. You should simply respond to transfers or gifts I send via normal messages.\n\n`;

            prompt += `5. **Simulating Group Chat Atmosphere**: To make the group chat appear realistic, active, and chaotic, every one of your responses must adhere to the following randomness requirements:\n`;
            const numMembers = group.members.length;
            const minMessages = numMembers * 2;
            const maxMessages = numMembers * 4;
            prompt += `   - **Number of Messages**: Your response must contain **${minMessages} to ${maxMessages}** messages (i.e., an average of 2-4 replies per member). Ensure there is sufficient interaction.\n`;
            prompt += `   - **Random Speaker and Order**: Randomly select group members to speak, and the order must also be random. Do not take turns in a fixed sequence.\n`;
            prompt += `   - **Content Diversity**: Your replies should primarily consist of normal text messages, but you can **occasionally and selectively** have a member send a special message (sticker, voice, photo/video) to enhance realism. Do not overuse special messages.\n`;
            prompt += `   - **Conversational Cohesion**: Although the speaking turns are random, the overall conversation content should revolve around my and other members' statements, maintaining a degree of logical coherence.\n\n`;

            prompt += `6. **Code of Conduct**:\n`;
            prompt += `   - **Reacting to Public Events (Important)**: When I (the user) send a transfer or a gift to **one** member in the group, this is an event **visible to the entire group**. Besides the recipient expressing thanks, **other AI members not involved should also notice** and react according to their respective personas. For example, they might express envy, congratulations, curiosity, make a joke, or playfully tease. This will make the group chat atmosphere more realistic and lively.\n`;
            prompt += `   - Strictly play each character's persona. There should be clear differences in personality and tone between different characters.\n`;
            prompt += `   - Your replies can only contain messages in the valid formats listed in point #4. You must absolutely not include any other content, such as \`[scene description]\`, \`(inner thoughts)\`, \`*actions*\`, or any explanatory text outside of the specified formats.\n`;
            prompt += `   - Maintain the continuity of the conversation; do not end it proactively.\n\n`;
            prompt += `Now, based on the settings above, please begin playing all the characters in the group chat.`;

            return prompt;
        }

        async function getAiReply() {
            if (isGenerating) return;

            // --- 1. API 설정 정확하게 불러오기 ---
            const provider = db.apiSettings.last_used_provider || 'newapi';
            const currentSettings = db.apiSettings[provider] || {};
            const key = currentSettings.key;
            const model = currentSettings.model;
            
            // ★★★ 여기에 있던 결정적인 오타를 수정했습니다! ★★★
            const providerUrls = { newapi: '', deepseek: 'https://api.deepseek.com', claude: 'https://api.anthropic.com', gemini: 'https://generativelanguage.googleapis.com' };
            let url = provider === 'newapi' ? (currentSettings.url || '') : providerUrls[provider];
            
            if (!url || !key || !model) {
                showToast('먼저 "api"앱에서 설정을 완료하세요!');
                switchScreen('api-settings-screen');
                return;
            }

            // --- 2. 요청 준비 (이 부분은 기존과 동일합니다) ---
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            if (!chat) return;
            isGenerating = true;
            getReplyBtn.disabled = true;
            const typingName = currentChatType === 'private' ? chat.remarkName : chat.name;
            typingIndicator.textContent = `"${typingName}" 입력 중...`;
            typingIndicator.style.display = 'block';
            messageArea.scrollTop = messageArea.scrollHeight;

            try {
                let systemPrompt, requestBody;
                if (currentChatType === 'private') { systemPrompt = generatePrivateSystemPrompt(chat); }
                else { systemPrompt = generateGroupSystemPrompt(chat); }
                const historySlice = chat.history.slice(-(chat.maxMemory || 10));

                if (provider === 'gemini') {
                    const contents = historySlice.map(msg => {
                        const role = msg.role === 'assistant' ? 'model' : 'user';
                        let parts;
                        if (msg.parts && msg.parts.length > 0) {
                            parts = msg.parts.map(p => {
                                if (p.type === 'text') { return { text: p.text }; }
                                else if (p.type === 'image') {
                                    const match = p.data.match(/^data:(image\/.+);base64,(.*)$/);
                                    if (match) { return { inline_data: { mime_type: match[1], data: match[3] } }; }
                                }
                                return null;
                            }).filter(p => p);
                        } else { parts = [{ text: msg.content }]; }
                        return { role, parts };
                    });
                    requestBody = { contents: contents, system_instruction: { parts: [{ text: systemPrompt }] }, generationConfig: {} };
                } else {
                    const messages = [{ role: 'system', content: systemPrompt }];
                    historySlice.forEach(msg => {
                        let content;
                        if (msg.parts && msg.parts.length > 0) {
                            content = msg.parts.map(p => {
                                if (p.type === 'text') { return { type: 'text', text: p.text }; }
                                else if (p.type === 'image') { return { type: 'image_url', image_url: { url: p.data } }; }
                                return null;
                            }).filter(p => p);
                        } else { content = msg.content; }
                        messages.push({ role: msg.role, content: content });
                    });
                    requestBody = { model: model, messages: messages, stream: true };
                }

                // --- 3. API 요청 보내기 (URL 끝에 '/'가 있어도 괜찮도록 수정) ---
                if (url.endsWith('/')) {
                    url = url.slice(0, -1);
                }
                
                const endpoint = (provider === 'gemini') ? `${url}/v1beta/models/${model}:streamGenerateContent?key=${getRandomValue(key)}` : `${url}/v1/chat/completions`;
                const headers = (provider === 'gemini') ? { 'Content-Type': 'application/json' } : { 'Content-Type': 'application/json', Authorization: `Bearer ${key}` };
                
                const response = await fetch(endpoint, { method: 'POST', headers: headers, body: JSON.stringify(requestBody) });
                
                if (!response.ok) throw new Error(`API Error: ${response.status} ${await response.text()}`);
                
                await processStream(response, chat, provider);
            } catch (error) {
                console.error('AI답변 실패:', error);
                showToast(`AI답변 실패: ${error.message}`);
            } finally {
                isGenerating = false;
                getReplyBtn.disabled = false;
                typingIndicator.style.display = 'none';
            }
        }

        async function processStream(response, originalChat, apiType) {
            const reader = response.body.getReader(), decoder = new TextDecoder();
            let fullResponse = "", accumulatedChunk = "";
            for (;;) {
                const { done, value } = await reader.read();
                if (done) break;
                accumulatedChunk += decoder.decode(value, { stream: true });
                if (apiType === "openai" || apiType === "deepseek" || apiType === "claude" || apiType === "newapi") {
                    const parts = accumulatedChunk.split("\n\n");
                    accumulatedChunk = parts.pop();
                    for (const part of parts) {
                        if (part.startsWith("data: ")) {
                            const data = part.substring(6);
                            if (data.trim() !== "[DONE]") {
                                try { fullResponse += JSON.parse(data).choices[0].delta?.content || ""; } catch (e) { /* ignore */ }
                            }
                        }
                    }
                }
            }
            if (apiType === "gemini") {
                try {
                    const parsedStream = JSON.parse(accumulatedChunk);
                    fullResponse = parsedStream.map(item => item.candidates?.[0]?.content?.parts?.[0]?.text || "").join('');
                } catch (e) {
                    console.error("Error parsing Gemini stream:", e, "Chunk:", accumulatedChunk);
                    showToast("Gemini 응답 파싱 실패");
                    return;
                }
            }

            if (fullResponse) {
                const messagesToAdd = [];
                // 'members' 속성이 있는지 여부로 개인/그룹 채팅을 명확히 구분합니다.
                const isPrivateChat = !originalChat.members;

                if (isPrivateChat) {
                    const character = originalChat;
                    const myName = character.myName;
                    const messageRegex = new RegExp(`\\[${character.realName}(?:의 (?:메시지|음성|송금|이모티콘|선물|사진\\/동영상)):[\\s\\S]+?\\]|\\[${character.realName}가 ${myName}의 송금을 (?:수신|반송)했습니다\\]|\\[${character.realName}가 선물을 수신했습니다\\]|\\[${character.realName}의 상태 업데이트:.*?\\]`, "g");
                    const messages = fullResponse.match(messageRegex) || [];

                    if (messages.length > 0) {
                        messages.forEach(msgContent => {
                            const message = { id: `msg_${Date.now()}_${Math.random()}`, role: 'assistant', content: msgContent.trim(), parts: [{ type: 'text', text: msgContent.trim() }], timestamp: Date.now() };
                            messagesToAdd.push(message);
                        });
                    } else if (fullResponse.trim()) { // 빈 응답이 아닐 경우
                        messagesToAdd.push({ id: `msg_${Date.now()}_${Math.random()}`, role: 'assistant', content: fullResponse, parts: [{ type: 'text', text: fullResponse }], timestamp: Date.now() });
                    }
                } else { // Group Chat
                    const group = originalChat;
                    const memberRealNames = group.members.map(m => m.realName.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'));
                    
                    // ★★★ 이 부분이 수정된 정규식입니다 ★★★
                    const memberRegex = new RegExp(`\\[(${memberRealNames.join('|')})(?:의 (?:메시지|음성|이모티콘|사진\\/동영상)):[\\s\\S]+?\\]`, "g");
                    const messages = fullResponse.match(memberRegex) || [];

                    if (messages.length > 0) {
                        messages.forEach(msgContent => {
                            const nameMatch = msgContent.match(/\[(.*?)의 (?:메시지|음성|이모티콘|사진\/동영상):/);
                            if (nameMatch) {
                                const senderName = nameMatch[1];
                                const sender = group.members.find(m => m.realName === senderName);
                                if (sender) {
                                    messagesToAdd.push({ id: `msg_${Date.now()}_${Math.random()}`, role: 'assistant', content: msgContent.trim(), parts: [{ type: 'text', text: msgContent.trim() }], timestamp: Date.now(), senderId: sender.id });
                                }
                            }
                        });
                    } else if (fullResponse.trim()){
                        const firstMember = group.members[Math.floor(Math.random() * group.members.length)];
                        if(firstMember) {
                            const simpleMessageContent = `[${firstMember.realName}의 메시지:${fullResponse}]`;
                            messagesToAdd.push({ id: `msg_${Date.now()}_${Math.random()}`, role: 'assistant', content: simpleMessageContent, parts: [{ type: 'text', text: simpleMessageContent }], timestamp: Date.now(), senderId: firstMember.id });
                        }
                    }
                }
                
                if (messagesToAdd.length > 0) {
                    originalChat.history.push(...messagesToAdd);
                    
                    // 현재 열린 채팅방과 AI가 답변한 채팅방이 다를 경우
                    if (currentChatId !== originalChat.id) {
                        originalChat.unreadCount = (originalChat.unreadCount || 0) + messagesToAdd.length;
                    } else {
                        // 같다면 화면에 바로 메시지를 보여줌
                        messagesToAdd.forEach(msg => addMessageBubble(msg));
                    }
                }
                
                saveData();
                renderChatList();
            }
        }
                
        // --- Other Sub-systems Setup (Stickers, Voice, etc.) ---
        function setupImageRecognition() {
            imageRecognitionBtn.addEventListener('click', () => { imageUploadInput.click(); });
            imageUploadInput.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, { quality: 0.8, maxWidth: 1024, maxHeight: 1024 });
                        sendImageForRecognition(compressedUrl);
                    } catch (error) {
                        console.error('Image compression failed:', error);
                        showToast('이미지 처리 실패, 다시 시도해 주세요');
                    } finally {
                        e.target.value = null;
                    }
                }
            });
        }

        function setupStickerSystem() {
            stickerToggleBtn.addEventListener('click', () => {
                stickerModal.classList.toggle('visible');
                if (stickerModal.classList.contains('visible')) { renderStickerGrid(); }
            });
            addNewStickerBtn.addEventListener('click', () => {
                addStickerModalTitle.textContent = '새 이모티콘 추가';
                addStickerForm.reset();
                stickerEditIdInput.value = '';
                stickerPreview.innerHTML = '<span>미리보기</span>';
                stickerUrlInput.disabled = false;
                addStickerModal.classList.add('visible');
            });
            addStickerForm.addEventListener('submit', (e) => {
                e.preventDefault();
                const name = stickerNameInput.value.trim();
                const id = stickerEditIdInput.value;
                const previewImg = stickerPreview.querySelector('img');
                const data = previewImg ? previewImg.src : null;
                if (!name || !data) { return showToast('이모티콘 이름을 입력하고 이미지를 제공해 주세요'); }
                const stickerData = { name, data };
                if (id) {
                    const index = db.myStickers.findIndex(s => s.id === id);
                    if (index > -1) { db.myStickers[index] = { ...db.myStickers[index], ...stickerData }; }
                } else {
                    stickerData.id = `sticker_${Date.now()}`;
                    db.myStickers.push(stickerData);
                }
                saveData();
                renderStickerGrid();
                addStickerModal.classList.remove('visible');
                showToast('이모티콘 저장 완료');
            });
            stickerUrlInput.addEventListener('input', (e) => {
                stickerPreview.innerHTML = `<img src="${e.target.value}" alt="미리보기">`;
                stickerFileUpload.value = '';
            });
            stickerFileUpload.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, { quality: 0.8, maxWidth: 200, maxHeight: 200 });
                        stickerPreview.innerHTML = `<img src="${compressedUrl}" alt="미리보기">`;
                        stickerUrlInput.value = '';
                        stickerUrlInput.disabled = true;
                    } catch (error) {
                        console.error('이모티콘 압축 실패:', error);
                        showToast('이모티콘 압축 실패, 다시 시도해 주세요');
                    }
                }
            });
            editStickerBtn.addEventListener('click', () => {
                if (!currentStickerActionTarget) return;
                const sticker = db.myStickers.find(s => s.id === currentStickerActionTarget);
                if (sticker) {
                    addStickerModalTitle.textContent = '이모티콘 편집';
                    stickerEditIdInput.value = sticker.id;
                    stickerNameInput.value = sticker.name;
                    stickerPreview.innerHTML = `<img src="${sticker.data}" alt="미리보기">`;
                    if (sticker.data.startsWith('http')) {
                        stickerUrlInput.value = sticker.data;
                        stickerUrlInput.disabled = false;
                    } else {
                        stickerUrlInput.value = '';
                        stickerUrlInput.disabled = true;
                    }
                    addStickerModal.classList.add('visible');
                }
                stickerActionSheet.classList.remove('visible');
                currentStickerActionTarget = null;
            });
            deleteStickerBtn.addEventListener('click', () => {
                if (!currentStickerActionTarget) return;
                const sticker = db.myStickers.find(s => s.id === currentStickerActionTarget);
                if (sticker) {
                    if (confirm(`"${sticker.name}" 이모티콘을 삭제하시겠습니까?`)) {
                        db.myStickers = db.myStickers.filter(s => s.id !== currentStickerActionTarget);
                        saveData();
                        renderStickerGrid();
                        showToast('이모티콘 삭제 완료');
                    }
                }
                stickerActionSheet.classList.remove('visible');
                currentStickerActionTarget = null;
            });
        }

        function renderStickerGrid() {
            stickerGridContainer.innerHTML = '';
            if (db.myStickers.length === 0) {
                stickerGridContainer.innerHTML = '<p style="color:#aaa; text-align:center;">아직 이모티콘이 없습니다. 빨리 추가해 보세요!</p>';
                return;
            }
            db.myStickers.forEach(sticker => {
                const item = document.createElement('div');
                item.className = 'sticker-item';
                item.innerHTML = `<img src="${sticker.data}" alt="${sticker.name}"><span>${sticker.name}</span>`;
                item.addEventListener('click', () => sendSticker(sticker));
                item.addEventListener('mousedown', (e) => {
                    if (e.button !== 0) return;
                    e.stopPropagation();
                    longPressTimer = setTimeout(() => { handleStickerLongPress(sticker.id); }, 500);
                });
                item.addEventListener('mouseup', () => clearTimeout(longPressTimer));
                item.addEventListener('mouseleave', () => clearTimeout(longPressTimer));
                item.addEventListener('touchstart', (e) => {
                    e.stopPropagation();
                    longPressTimer = setTimeout(() => { handleStickerLongPress(sticker.id); }, 500);
                });
                item.addEventListener('touchend', () => clearTimeout(longPressTimer));
                item.addEventListener('touchmove', () => clearTimeout(longPressTimer));
                stickerGridContainer.appendChild(item);
            });
        }

        function handleStickerLongPress(stickerId) {
            clearTimeout(longPressTimer);
            currentStickerActionTarget = stickerId;
            stickerActionSheet.classList.add('visible');
        }

        function setupVoiceMessageSystem() {
            voiceMessageBtn.addEventListener('click', () => {
                sendVoiceForm.reset();
                voiceDurationPreview.textContent = '0"';
                sendVoiceModal.classList.add('visible');
            });
            sendVoiceForm.addEventListener('submit', (e) => {
                e.preventDefault();
                sendMyVoiceMessage(voiceTextInput.value.trim());
            });
        }

        function setupPhotoVideoSystem() {
            photoVideoBtn.addEventListener('click', () => {
                sendPvForm.reset();
                sendPvModal.classList.add('visible');
            });
            sendPvForm.addEventListener('submit', (e) => {
                e.preventDefault();
                sendMyPhotoVideo(pvTextInput.value.trim());
            });
        }

        function setupWalletSystem() {
            walletBtn.addEventListener('click', () => {
                if (currentChatType === 'private') {
                    sendTransferForm.reset();
                    sendTransferModal.classList.add('visible');
                } else if (currentChatType === 'group') {
                    currentGroupAction.type = 'transfer';
                    renderGroupRecipientSelectionList('에게 송금');
                    groupRecipientSelectionModal.classList.add('visible');
                }
            });
            sendTransferForm.addEventListener('submit', (e) => {
                e.preventDefault();
                const amount = transferAmountInput.value;
                const remark = transferRemarkInput.value.trim();
                if (amount > 0) { sendMyTransfer(amount, remark); }
                else { showToast('유효한 금액을 입력해 주세요'); }
            });
            acceptTransferBtn.addEventListener('click', () => respondToTransfer('received'));
            returnTransferBtn.addEventListener('click', () => respondToTransfer('returned'));
        }

        function handleReceivedTransferClick(messageId) {
            currentTransferMessageId = messageId;
            receiveTransferActionSheet.classList.add('visible');
        }

        function respondToTransfer(action) {
            if (!currentTransferMessageId) return;
            const character = db.characters.find(c => c.id === currentChatId);
            const message = character.history.find(m => m.id === currentTransferMessageId);
            if (message) {
                message.transferStatus = action;
                const cardOnScreen = messageArea.querySelector(`.message-wrapper[data-id="${currentTransferMessageId}"] .transfer-card`);
                if (cardOnScreen) {
                    cardOnScreen.classList.remove('received', 'returned');
                    cardOnScreen.classList.add(action);
                    cardOnScreen.querySelector('.transfer-status').textContent = action === 'received' ? '수신 완료' : '반송됨';
                    cardOnScreen.style.cursor = 'default';
                }
                let contextMessageContent = (action === 'received') ? `[${character.myName}가 ${character.realName}의 송금을 수신했습니다]` : `[${character.myName}가 ${character.realName}의 송금을 반송했습니다]`;
                const contextMessage = { id: `msg_${Date.now()}`, role: 'user', content: contextMessageContent, parts: [{ type: 'text', text: contextMessageContent }], timestamp: Date.now() };
                character.history.push(contextMessage);
                saveData();
                renderChatList();
            }
            receiveTransferActionSheet.classList.remove('visible');
            currentTransferMessageId = null;
        }

        function setupGiftSystem() {
            giftBtn.addEventListener('click', () => {
                if (currentChatType === 'private') {
                    sendGiftForm.reset();
                    sendGiftModal.classList.add('visible');
                } else if (currentChatType === 'group') {
                    currentGroupAction.type = 'gift';
                    renderGroupRecipientSelectionList('에게 선물 보내기');
                    groupRecipientSelectionModal.classList.add('visible');
                }
            });
            sendGiftForm.addEventListener('submit', (e) => {
                e.preventDefault();
                sendMyGift(giftDescriptionInput.value.trim());
            });
        }

        function setupFontSettingsApp() {
            fontUrlInput.value = db.fontUrl;
            fontSettingsForm.addEventListener('submit', e => {
                e.preventDefault();
                const newFontUrl = fontUrlInput.value.trim();
                db.fontUrl = newFontUrl;
                saveData();
                applyGlobalFont(newFontUrl);
                showToast('새 글꼴이 적용되었습니다!');
            });
            restoreDefaultFontBtn.addEventListener('click', () => {
                fontUrlInput.value = '';
                db.fontUrl = '';
                saveData();
                applyGlobalFont('');
                showToast('기본 글꼴로 복원되었습니다!');
            });
        }

        function applyGlobalFont(fontUrl) {
            const styleId = 'global-font-style';
            let styleElement = document.getElementById(styleId);
            if (!styleElement) {
                styleElement = document.createElement('style');
                styleElement.id = styleId;
                document.head.appendChild(styleElement);
            }
            if (fontUrl) {
                const fontName = 'CustomGlobalFont';
                styleElement.innerHTML = `@font-face { font-family: '${fontName}'; src: url('${fontUrl}'); } :root { --font-family: '${fontName}', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; }`;
            } else {
                styleElement.innerHTML = `:root { --font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; }`;
            }
        }

        function setupWorldBookApp() {
            addWorldBookBtn.addEventListener('click', () => {
                currentEditingWorldBookId = null;
                editWorldBookForm.reset();
                document.querySelector('input[name="world-book-position"][value="before"]').checked = true;
                switchScreen('edit-world-book-screen');
            });
            editWorldBookForm.addEventListener('submit', (e) => {
                e.preventDefault();
                const name = worldBookNameInput.value.trim();
                const content = worldBookContentInput.value.trim();
                const position = document.querySelector('input[name="world-book-position"]:checked').value;
                if (!name || !content) return showToast('이름과 내용은 비워둘 수 없습니다');
                if (currentEditingWorldBookId) {
                    const book = db.worldBooks.find(wb => wb.id === currentEditingWorldBookId);
                    if (book) {
                        book.name = name;
                        book.content = content;
                        book.position = position;
                    }
                } else {
                    db.worldBooks.push({ id: `wb_${Date.now()}`, name, content, position });
                }
                saveData();
                showToast('월드인포 항목이 저장되었습니다');
                renderWorldBookList();
                switchScreen('world-book-screen');
            });
            worldBookListContainer.addEventListener('click', e => {
                const item = e.target.closest('.world-book-item');
                if (item) {
                    const book = db.worldBooks.find(wb => wb.id === item.dataset.id);
                    if (book) {
                        currentEditingWorldBookId = book.id;
                        worldBookIdInput.value = book.id;
                        worldBookNameInput.value = book.name;
                        worldBookContentInput.value = book.content;
                        document.querySelector(`input[name="world-book-position"][value="${book.position}"]`).checked = true;
                        switchScreen('edit-world-book-screen');
                    }
                }
            });
            worldBookListContainer.addEventListener('mousedown', (e) => {
                if (e.button !== 0) return;
                const item = e.target.closest('.world-book-item');
                if (!item) return;
                longPressTimer = setTimeout(() => {
                    const bookId = item.dataset.id;
                    const menuItems = [{
                        label: '삭제',
                        danger: true,
                        action: () => {
                            if (confirm('이 월드인포 항목을 삭제하시겠습니까?')) {
                                db.worldBooks = db.worldBooks.filter(wb => wb.id !== bookId);
                                db.characters.forEach(char => { char.worldBookIds = (char.worldBookIds || []).filter(id => id !== bookId); });
                                db.groups.forEach(group => { group.worldBookIds = (group.worldBookIds || []).filter(id => id !== bookId); });
                                saveData();
                                renderWorldBookList();
                                showToast('항목이 삭제되었습니다');
                            }
                        }
                    }];
                    createContextMenu(menuItems, e.clientX, e.clientY);
                }, 500);
            });
            worldBookListContainer.addEventListener('mouseup', () => clearTimeout(longPressTimer));
            worldBookListContainer.addEventListener('mouseleave', () => clearTimeout(longPressTimer));
        }

        function renderWorldBookList() {
            worldBookListContainer.innerHTML = '';
            noWorldBooksPlaceholder.style.display = db.worldBooks.length === 0 ? 'block' : 'none';
            db.worldBooks.forEach(book => {
                const li = document.createElement('li');
                li.className = 'list-item world-book-item';
                li.dataset.id = book.id;
                li.innerHTML = `<div class="item-details" style="padding-left: 20px;"><div class="item-name">${book.name}</div><div class="item-preview">${book.content}</div></div>`;
                worldBookListContainer.appendChild(li);
            });
        }

        function setupChatSettings() {
            const themeSelect = document.getElementById('setting-theme-color');
            themeSelect.innerHTML = '';
            Object.keys(colorThemes).forEach(key => {
                const option = document.createElement('option');
                option.value = key;
                option.textContent = colorThemes[key].name;
                themeSelect.appendChild(option);
            });
            chatSettingsBtn.addEventListener('click', () => {
                if (currentChatType === 'private') {
                    loadSettingsToSidebar();
                    settingsSidebar.classList.add('open');
                } else if (currentChatType === 'group') {
                    loadGroupSettingsToSidebar();
                    groupSettingsSidebar.classList.add('open');
                }
            });
            document.querySelector('.phone-screen').addEventListener('click', e => {
                const openSidebar = document.querySelector('.settings-sidebar.open');
                if (openSidebar && !openSidebar.contains(e.target) && !chatSettingsBtn.contains(e.target) && !e.target.closest('.modal-overlay') && !e.target.closest('.action-sheet-overlay')) {
                    openSidebar.classList.remove('open');
                }
            });

            settingsForm.addEventListener('submit', e => {
                e.preventDefault();
                saveSettingsFromSidebar();
                settingsSidebar.classList.remove('open');
            });
            const useCustomCssCheckbox = document.getElementById('setting-use-custom-css'), customCssTextarea = document.getElementById('setting-custom-bubble-css'), resetCustomCssBtn = document.getElementById('reset-custom-bubble-css-btn'), privatePreviewBox = document.getElementById('private-bubble-css-preview');
            useCustomCssCheckbox.addEventListener('change', (e) => {
                customCssTextarea.disabled = !e.target.checked;
                const char = db.characters.find(c => c.id === currentChatId);
                if (char) {
                    const themeKey = char.theme || 'white_pink';
                    const theme = colorThemes[themeKey];
                    updateBubbleCssPreview(privatePreviewBox, customCssTextarea.value, !e.target.checked, theme);
                }
            });
            customCssTextarea.addEventListener('input', (e) => {
                const char = db.characters.find(c => c.id === currentChatId);
                if (char && useCustomCssCheckbox.checked) {
                    const themeKey = char.theme || 'white_pink';
                    const theme = colorThemes[themeKey];
                    updateBubbleCssPreview(privatePreviewBox, e.target.value, false, theme);
                }
            });
            resetCustomCssBtn.addEventListener('click', () => {
                const char = db.characters.find(c => c.id === currentChatId);
                if (char) {
                    customCssTextarea.value = '';
                    useCustomCssCheckbox.checked = false;
                    customCssTextarea.disabled = true;
                    const themeKey = char.theme || 'white_pink';
                    const theme = colorThemes[themeKey];
                    updateBubbleCssPreview(privatePreviewBox, '', true, theme);
                    showToast('스타일이 기본값으로 재설정되었습니다');
                }
            });
            document.getElementById('setting-char-avatar-upload').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, { quality: 0.8, maxWidth: 400, maxHeight: 400 });
                        document.getElementById('setting-char-avatar-preview').src = compressedUrl;
                    } catch (error) { showToast('프로필 사진 압축 실패, 다시 시도해 주세요'); }
                }
            });
            document.getElementById('setting-my-avatar-upload').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, { quality: 0.8, maxWidth: 400, maxHeight: 400 });
                        document.getElementById('setting-my-avatar-preview').src = compressedUrl;
                    } catch (error) { showToast('프로필 사진 압축 실패, 다시 시도해 주세요'); }
                }
            });
            document.getElementById('setting-chat-bg-upload').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    const char = db.characters.find(c => c.id === currentChatId);
                    if (char) {
                        try {
                            const compressedUrl = await compressImage(file, { quality: 0.85, maxWidth: 1080, maxHeight: 1920 });
                            char.chatBg = compressedUrl;
                            chatRoomScreen.style.backgroundImage = `url(${compressedUrl})`;
                            saveData();
                            showToast('채팅 배경이 변경되었습니다');
                        } catch (error) { showToast('배경 압축 실패, 다시 시도해 주세요'); }
                    }
                }
            });
            clearChatHistoryBtn.addEventListener('click', () => {
                const character = db.characters.find(c => c.id === currentChatId);
                if (!character) return;
                if (confirm(`정말로 "${character.remarkName}"의 모든 채팅 기록을 삭제하시겠습니까? 이 작업은 되돌릴 수 없습니다!`)) {
                    character.history = [];
                    saveData();
                    renderMessages(false, true);
                    renderChatList();
                    settingsSidebar.classList.remove('open');
                    showToast('채팅 기록이 비워졌습니다');
                }
            });
            linkWorldBookBtn.addEventListener('click', () => {
                const character = db.characters.find(c => c.id === currentChatId);
                if (!character) return;
                worldBookSelectionList.innerHTML = '';
                db.worldBooks.forEach(book => {
                    const li = document.createElement('li');
                    li.className = 'world-book-select-item';
                    const isChecked = (character.worldBookIds || []).includes(book.id);
                    li.innerHTML = `<input type="checkbox" id="wb-select-${book.id}" value="${book.id}" ${isChecked ? 'checked' : ''}><label for="wb-select-${book.id}">${book.name}</label>`;
                    worldBookSelectionList.appendChild(li);
                });
                worldBookSelectionModal.classList.add('visible');
            });

            saveWorldBookSelectionBtn.addEventListener('click', () => {
                const selectedIds = Array.from(worldBookSelectionList.querySelectorAll('input:checked')).map(input => input.value);
                if (currentChatType === 'private') {
                    const character = db.characters.find(c => c.id === currentChatId);
                    if (character) character.worldBookIds = selectedIds;
                } else if (currentChatType === 'group') {
                    const group = db.groups.find(g => g.id === currentChatId);
                    if (group) group.worldBookIds = selectedIds;
                }
                saveData();
                worldBookSelectionModal.classList.remove('visible');
                showToast('월드인포 연결이 업데이트되었습니다');
            });
        }

        function loadSettingsToSidebar() {
            const e = db.characters.find(e => e.id === currentChatId);
            if (e) {
                document.getElementById('setting-char-avatar-preview').src = e.avatar;
                document.getElementById('setting-char-remark').value = e.remarkName;
                document.getElementById('setting-char-persona').value = e.persona;
                document.getElementById('setting-my-avatar-preview').src = e.myAvatar;
                document.getElementById('setting-my-name').value = e.myName;
                document.getElementById('setting-my-persona').value = e.myPersona;
                document.getElementById('setting-theme-color').value = e.theme || 'white_pink';
                document.getElementById('setting-max-memory').value = e.maxMemory;
                const useCustomCssCheckbox = document.getElementById('setting-use-custom-css'), customCssTextarea = document.getElementById('setting-custom-bubble-css'), privatePreviewBox = document.getElementById('private-bubble-css-preview');
                useCustomCssCheckbox.checked = e.useCustomBubbleCss || false;
                customCssTextarea.value = e.customBubbleCss || '';
                customCssTextarea.disabled = !useCustomCssCheckbox.checked;
                const theme = colorThemes[e.theme || 'white_pink'];
                updateBubbleCssPreview(privatePreviewBox, e.customBubbleCss, !e.useCustomBubbleCss, theme);
            }
        }

        function saveSettingsFromSidebar() {
            const e = db.characters.find(e => e.id === currentChatId);
            if (e) {
                e.avatar = document.getElementById('setting-char-avatar-preview').src;
                e.remarkName = document.getElementById('setting-char-remark').value;
                e.persona = document.getElementById('setting-char-persona').value;
                e.myAvatar = document.getElementById('setting-my-avatar-preview').src;
                e.myName = document.getElementById('setting-my-name').value;
                e.myPersona = document.getElementById('setting-my-persona').value;
                e.theme = document.getElementById('setting-theme-color').value;
                e.maxMemory = document.getElementById('setting-max-memory').value;
                e.useCustomBubbleCss = document.getElementById('setting-use-custom-css').checked;
                e.customBubbleCss = document.getElementById('setting-custom-bubble-css').value;
                saveData();
                showToast('설정이 저장되었습니다!');
                chatRoomTitle.textContent = e.remarkName;
                renderChatList();
                updateCustomBubbleStyle(currentChatId, e.customBubbleCss, e.useCustomBubbleCss);
                currentPage = 1;
                renderMessages(false, true);
            }
        }

        function setupApiSettingsApp() {
            const apiForm = document.getElementById('api-form');
            const fetchModelsBtn = document.getElementById('fetch-models-btn');
            const modelSelect = document.getElementById('api-model');
            const providerSelect = document.getElementById('api-provider');
            const urlInput = document.getElementById('api-url');
            const keyInput = document.getElementById('api-key');
            const providerUrls = { newapi: '', deepseek: 'https://api.deepseek.com', claude: 'https://api.anthropic.com', gemini: 'https://generativelanguage.googleapis.com' };

            // 현재 UI(입력창)에 보이는 값을 DB에 저장하는 함수
            function saveCurrentUIToDB(providerToSave) {
                if (!providerToSave) return;
                if (!db.apiSettings[providerToSave]) db.apiSettings[providerToSave] = {};
                
                // newapi 일 때만 URL을 저장합니다.
                if (providerToSave === 'newapi') {
                    db.apiSettings[providerToSave].url = urlInput.value.trim();
                }
                db.apiSettings[providerToSave].key = keyInput.value.trim();
                
                // 모델 선택값이 있을 때만 저장합니다.
                if (modelSelect.value) {
                    db.apiSettings[providerToSave].model = modelSelect.value;
                }
            }

            // 특정 제공자의 설정을 DB에서 불러와 UI(입력창)에 표시하는 함수
            function loadSettingsToUI(provider) {
                const settings = db.apiSettings[provider] || {};
                
                urlInput.value = (provider === 'newapi') ? (settings.url || '') : providerUrls[provider];
                urlInput.readOnly = (provider !== 'newapi'); // newapi가 아니면 URL 입력창을 잠급니다.
                
                keyInput.value = settings.key || '';
                
                if (settings.model) {
                    modelSelect.innerHTML = `<option value="${settings.model}" selected>${settings.model}</option>`;
                } else {
                    modelSelect.innerHTML = '<option value="">먼저 모델 목록을 가져오세요</option>';
                }
            }
            
            // 1. 페이지가 처음 열릴 때 실행
            const lastProvider = db.apiSettings.last_used_provider || 'newapi';
            providerSelect.value = lastProvider;
            loadSettingsToUI(lastProvider);

            // 2. 사용자가 제공자 선택을 바꿀 때 실행되는 가장 중요한 부분!
            providerSelect.addEventListener('change', () => {
                // 방금 전까지 선택되어 있던 제공자를 찾습니다.
                const previousProvider = db.apiSettings.last_used_provider || 'newapi';
                
                // 바꾸기 전의 제공자 설정을 먼저 저장합니다.
                saveCurrentUIToDB(previousProvider);

                // 새로 선택한 제공자의 설정을 화면에 불러옵니다.
                const newProvider = providerSelect.value;
                loadSettingsToUI(newProvider);
                
                // 마지막으로 사용한 제공자를 DB에 기록합니다.
                db.apiSettings.last_used_provider = newProvider;
                saveData(); // 변경사항 즉시 저장
            });

            // 3. 모델 가져오기 버튼 클릭 (이 부분은 이전과 거의 동일)
            fetchModelsBtn.addEventListener('click', async () => {
                let apiUrl = urlInput.value.trim();
                const apiKey = keyInput.value.trim();
                const provider = providerSelect.value;

                if (!apiUrl || !apiKey) return showToast('먼저 API 주소와 키를 입력해 주세요!');
                if (apiUrl.endsWith('/')) apiUrl = apiUrl.slice(0, -1);

                const endpoint = (provider === 'gemini') ? `${apiUrl}/v1beta/models?key=${getRandomValue(apiKey)}` : `${apiUrl}/v1/models`;
                fetchModelsBtn.classList.add('loading'); fetchModelsBtn.disabled = true;

                try {
                    const headers = (provider === 'gemini') ? {} : { 'Authorization': `Bearer ${apiKey}` };
                    const response = await fetch(endpoint, { method: 'GET', headers });
                    if (!response.ok) throw new Error(`네트워크 응답 오류: ${response.status}`);
                    const json = await response.json();
                    let models = [];
                    if (provider !== 'gemini' && json.data) models = json.data.map(m => m.id);
                    else if (provider === 'gemini' && json.models) models = json.models.map(m => m.name.replace('models/', ''));
                    
                    modelSelect.innerHTML = '';
                    if (models.length > 0) {
                        models.forEach(model => {
                            const option = document.createElement('option');
                            option.value = model; option.textContent = model;
                            modelSelect.appendChild(option);
                        });
                        showToast('모델 목록 가져오기 성공!');
                    } else {
                        modelSelect.innerHTML = '<option value="">어떤 모델도 찾을 수 없습니다</option>';
                    }
                } catch (error) {
                    showToast(`가져오기 실패: ${error.message}`);
                    modelSelect.innerHTML = '<option value="">가져오기 실패</option>';
                } finally {
                    fetchModelsBtn.classList.remove('loading'); fetchModelsBtn.disabled = false;
                }
            });

            // 4. 저장 버튼 클릭
            apiForm.addEventListener('submit', e => {
                e.preventDefault();
                if (!modelSelect.value) return showToast('모델을 선택한 후 저장해 주세요!');
                
                const currentProvider = providerSelect.value;
                saveCurrentUIToDB(currentProvider); // 현재 화면의 내용을 저장
                db.apiSettings.last_used_provider = currentProvider; // 마지막 쓴 제공자 기록
                saveData();
                showToast('API 설정이 저장되었습니다!');
            });
        }

        function applyGlobalTheme(themeName) {
            const theme = globalThemes[themeName] || globalThemes['pink'];
            for (const [key, value] of Object.entries(theme.colors)) {
                document.documentElement.style.setProperty(key, value);
            }
            db.globalTheme = themeName;
        }

        function setupWallpaperApp() {
            // --- 1. 배경화면 설정 부분 ---
            const wallpaperUpload = document.getElementById('wallpaper-upload');
            const wallpaperPreview = document.getElementById('wallpaper-preview');
            wallpaperPreview.style.backgroundImage = `url(${db.wallpaper})`;
            wallpaperPreview.textContent = '';
            wallpaperUpload.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, { quality: .85, maxWidth: 1080, maxHeight: 1920 });
                        db.wallpaper = compressedUrl;
                        applyWallpaper(compressedUrl);
                        wallpaperPreview.style.backgroundImage = `url(${compressedUrl})`;
                        saveData();
                        showToast('배경화면 변경 성공!');
                    } catch (error) { showToast('배경화면 압축 실패, 다시 시도해 주세요'); }
                }
            });

            // --- 2. UI 테마 선택 부분 ---
            const mainContent = document.querySelector('#wallpaper-screen main.content');
            // 테마 선택 UI가 중복해서 생기지 않도록 확인
            if (!document.getElementById('global-theme-selector')) {
                mainContent.innerHTML += `
                    <hr style="border:none; border-top:1px solid var(--border-color); margin: 30px 0 20px;">
                    <h3 style="text-align:center; font-weight:500; font-size: 16px; margin-bottom: 20px; color: var(--text-color);">UI 테마</h3>
                    <div class="global-theme-selector" id="global-theme-selector"></div>
                `;
            }

            const themeContainer = document.getElementById('global-theme-selector');
            themeContainer.innerHTML = ''; // 버튼을 새로 그리기 위해 비워줌
            
            Object.keys(globalThemes).forEach(key => {
                const theme = globalThemes[key];
                const circle = document.createElement('div');
                circle.className = 'theme-circle';
                circle.title = theme.name;
                circle.style.background = `linear-gradient(to right, ${theme.colors['--bg-color']} 50%, ${theme.colors['--primary-color']} 50%)`;
                
                if (key === (db.globalTheme || 'pink')) {
                    circle.classList.add('selected');
                }
                
                circle.addEventListener('click', () => {
                    applyGlobalTheme(key);
                    saveData();
                    document.querySelector('.global-theme-selector .theme-circle.selected')?.classList.remove('selected');
                    circle.classList.add('selected');
                    showToast(`UI 테마가 '${theme.name}'(으)로 변경되었습니다.`);
                });
                themeContainer.appendChild(circle);
            });
        }
               
        // --- GROUP CHAT FUNCTIONS ---
        function setupGroupChatSystem() {
            createGroupBtn.addEventListener('click', () => {
                renderMemberSelectionList();
                createGroupModal.classList.add('visible');
            });
            createGroupForm.addEventListener('submit', e => {
                e.preventDefault();
                const selectedMemberIds = Array.from(memberSelectionList.querySelectorAll('input:checked')).map(input => input.value);
                const groupName = groupNameInput.value.trim();
                if (selectedMemberIds.length < 1) return showToast('최소한 그룹 멤버 한 명을 선택해 주세요.');
                if (!groupName) return showToast('그룹 채팅 이름을 입력해 주세요.');
                const firstChar = db.characters.length > 0 ? db.characters[0] : null;
                const newGroup = { id: `group_${Date.now()}`, name: groupName, avatar: 'https://i.postimg.cc/fTLCngk1/image.jpg', me: { nickname: firstChar ? firstChar.myName : '나', persona: firstChar ? firstChar.myPersona : '', avatar: firstChar ? firstChar.myAvatar : 'https://i.postimg.cc/GtbTnxhP/o-o-1.jpg' }, members: selectedMemberIds.map(charId => { const char = db.characters.find(c => c.id === charId); return { id: `member_${char.id}`, originalCharId: char.id, realName: char.realName, groupNickname: char.remarkName, persona: char.persona, avatar: char.avatar }; }), theme: 'white_pink', maxMemory: 10, chatBg: '', history: [], isPinned: false, useCustomBubbleCss: false, customBubbleCss: '', worldBookIds: [] };
                db.groups.push(newGroup);
                saveData();
                renderChatList();
                createGroupModal.classList.remove('visible');
                showToast(`그룹 채팅 "${groupName}" 생성 성공!`);
            });
            groupSettingsForm.addEventListener('submit', e => {
                e.preventDefault();
                saveGroupSettingsFromSidebar();
                groupSettingsSidebar.classList.remove('open');
            });
            const useGroupCustomCssCheckbox = document.getElementById('setting-group-use-custom-css'), groupCustomCssTextarea = document.getElementById('setting-group-custom-bubble-css'), resetGroupCustomCssBtn = document.getElementById('reset-group-custom-bubble-css-btn'), groupPreviewBox = document.getElementById('group-bubble-css-preview');
            useGroupCustomCssCheckbox.addEventListener('change', (e) => {
                groupCustomCssTextarea.disabled = !e.target.checked;
                const group = db.groups.find(g => g.id === currentChatId);
                if (group) {
                    const theme = colorThemes[group.theme || 'white_pink'];
                    updateBubbleCssPreview(groupPreviewBox, groupCustomCssTextarea.value, !e.target.checked, theme);
                }
            });
            groupCustomCssTextarea.addEventListener('input', (e) => {
                const group = db.groups.find(g => g.id === currentChatId);
                if (group && useGroupCustomCssCheckbox.checked) {
                    const theme = colorThemes[group.theme || 'white_pink'];
                    updateBubbleCssPreview(groupPreviewBox, e.target.value, false, theme);
                }
            });
            resetGroupCustomCssBtn.addEventListener('click', () => {
                const group = db.groups.find(g => g.id === currentChatId);
                if (group) {
                    groupCustomCssTextarea.value = '';
                    useGroupCustomCssCheckbox.checked = false;
                    groupCustomCssTextarea.disabled = true;
                    const theme = colorThemes[group.theme || 'white_pink'];
                    updateBubbleCssPreview(groupPreviewBox, '', true, theme);
                    showToast('스타일이 기본값으로 재설정되었습니다');
                }
            });
            document.getElementById('setting-group-avatar-upload').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, { quality: 0.8, maxWidth: 400, maxHeight: 400 });
                        const group = db.groups.find(g => g.id === currentChatId);
                        if (group) {
                            group.avatar = compressedUrl;
                            document.getElementById('setting-group-avatar-preview').src = compressedUrl;
                        }
                    } catch (error) { showToast('그룹 프로필 사진 압축 실패, 다시 시도해 주세요'); }
                }
            });
            document.getElementById('setting-group-chat-bg-upload').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, { quality: 0.85, maxWidth: 1080, maxHeight: 1920 });
                        const group = db.groups.find(g => g.id === currentChatId);
                        if (group) {
                            group.chatBg = compressedUrl;
                            chatRoomScreen.style.backgroundImage = `url(${compressedUrl})`;
                            saveData();
                            showToast('채팅 배경이 변경되었습니다');
                        }
                    } catch (error) { showToast('그룹 채팅 배경 압축 실패, 다시 시도해 주세요'); }
                }
            });
            document.getElementById('clear-group-chat-history-btn').addEventListener('click', () => {
                const group = db.groups.find(g => g.id === currentChatId);
                if (!group) return;
                if (confirm(`정말로 그룹 채팅 "${group.name}"의 모든 채팅 기록을 삭제하시겠습니까? 이 작업은 되돌릴 수 없습니다!`)) {
                    group.history = [];
                    saveData();
                    renderMessages(false, true);
                    renderChatList();
                    groupSettingsSidebar.classList.remove('open');
                    showToast('채팅 기록이 비워졌습니다');
                }
            });
            groupMembersListContainer.addEventListener('click', e => {
                const memberDiv = e.target.closest('.group-member');
                const addBtn = e.target.closest('.add-member-btn');
                if (memberDiv) { openGroupMemberEditModal(memberDiv.dataset.id); }
                else if (addBtn) { addMemberActionSheet.classList.add('visible'); }
            });
            document.getElementById('edit-member-avatar-preview').addEventListener('click', () => { document.getElementById('edit-member-avatar-upload').click(); });
            document.getElementById('edit-member-avatar-upload').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, { quality: 0.8, maxWidth: 400, maxHeight: 400 });
                        document.getElementById('edit-member-avatar-preview').src = compressedUrl;
                    } catch (error) { showToast('멤버 프로필 사진 압축 실패, 다시 시도해 주세요'); }
                }
            });
            editGroupMemberForm.addEventListener('submit', e => {
                e.preventDefault();
                const memberId = document.getElementById('editing-member-id').value;
                const group = db.groups.find(g => g.id === currentChatId);
                const member = group.members.find(m => m.id === memberId);
                if (member) {
                    member.avatar = document.getElementById('edit-member-avatar-preview').src;
                    member.groupNickname = document.getElementById('edit-member-group-nickname').value;
                    member.realName = document.getElementById('edit-member-real-name').value;
                    member.persona = document.getElementById('edit-member-persona').value;
                    saveData();
                    renderGroupMembersInSettings(group);
                    document.querySelectorAll(`.message-wrapper[data-sender-id="${member.id}"] .group-nickname`).forEach(el => { el.textContent = member.groupNickname; });
                    showToast('멤버 정보가 업데이트되었습니다');
                }
                editGroupMemberModal.classList.remove('visible');
            });
            inviteExistingMemberBtn.addEventListener('click', () => {
                renderInviteSelectionList();
                inviteMemberModal.classList.add('visible');
                addMemberActionSheet.classList.remove('visible');
            });
            createNewMemberBtn.addEventListener('click', () => {
                createMemberForGroupForm.reset();
                document.getElementById('create-group-member-avatar-preview').src = 'https://i.postimg.cc/Y96LPskq/o-o-2.jpg';
                createMemberForGroupModal.classList.add('visible');
                addMemberActionSheet.classList.remove('visible');
            });
            document.getElementById('create-group-member-avatar-preview').addEventListener('click', () => { document.getElementById('create-group-member-avatar-upload').click(); });
            document.getElementById('create-group-member-avatar-upload').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, { quality: 0.8, maxWidth: 400, maxHeight: 400 });
                        document.getElementById('create-group-member-avatar-preview').src = compressedUrl;
                    } catch (error) { showToast('새 멤버 프로필 사진 압축 실패, 다시 시도해 주세요'); }
                }
            });
            confirmInviteBtn.addEventListener('click', () => {
                const group = db.groups.find(g => g.id === currentChatId);
                if (!group) return;
                const selectedCharIds = Array.from(inviteMemberSelectionList.querySelectorAll('input:checked')).map(input => input.value);
                selectedCharIds.forEach(charId => {
                    const char = db.characters.find(c => c.id === charId);
                    if (char) {
                        const newMember = { id: `member_${char.id}`, originalCharId: char.id, realName: char.realName, groupNickname: char.remarkName, persona: char.persona, avatar: char.avatar };
                        group.members.push(newMember);
                        sendInviteNotification(group, newMember.realName);
                    }
                });
                if (selectedCharIds.length > 0) {
                    saveData();
                    renderGroupMembersInSettings(group);
                    renderMessages(false, true);
                    showToast('새 멤버가 초대되었습니다');
                }
                inviteMemberModal.classList.remove('visible');
            });
            createMemberForGroupForm.addEventListener('submit', e => {
                e.preventDefault();
                const group = db.groups.find(g => g.id === currentChatId);
                if (!group) return;
                const newMember = { id: `member_group_only_${Date.now()}`, originalCharId: null, realName: document.getElementById('create-group-member-realname').value, groupNickname: document.getElementById('create-group-member-nickname').value, persona: document.getElementById('create-group-member-persona').value, avatar: document.getElementById('create-group-member-avatar-preview').src, };
                group.members.push(newMember);
                sendInviteNotification(group, newMember.realName);
                saveData();
                renderGroupMembersInSettings(group);
                renderMessages(false, true);
                showToast(`새 멤버 ${newMember.groupNickname}이(가) 가입했습니다`);
                createMemberForGroupModal.classList.remove('visible');
            });
            document.getElementById('setting-group-my-avatar-upload').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, { quality: 0.8, maxWidth: 400, maxHeight: 400 });
                        document.getElementById('setting-group-my-avatar-preview').src = compressedUrl;
                    } catch(error){ showToast('프로필 사진 압축 실패')}
                }
            });
            confirmGroupRecipientBtn.addEventListener('click', () => {
                const selectedRecipientIds = Array.from(groupRecipientSelectionList.querySelectorAll('input:checked')).map(input => input.value);
                if (selectedRecipientIds.length === 0) {
                    return showToast('최소한 수신자 한 명을 선택해 주세요.');
                }
                currentGroupAction.recipients = selectedRecipientIds;
                groupRecipientSelectionModal.classList.remove('visible');

                if (currentGroupAction.type === 'transfer') {
                    sendTransferForm.reset();
                    sendTransferModal.classList.add('visible');
                } else if (currentGroupAction.type === 'gift') {
                    sendGiftForm.reset();
                    sendGiftModal.classList.add('visible');
                }
            });
            linkGroupWorldBookBtn.addEventListener('click', () => {
                const group = db.groups.find(g => g.id === currentChatId);
                if (!group) return;
                worldBookSelectionList.innerHTML = '';
                db.worldBooks.forEach(book => {
                    const li = document.createElement('li');
                    li.className = 'world-book-select-item';
                    const isChecked = (group.worldBookIds || []).includes(book.id);
                    li.innerHTML = `<input type="checkbox" id="wb-select-group-${book.id}" value="${book.id}" ${isChecked ? 'checked' : ''}><label for="wb-select-group-${book.id}">${book.name}</label>`;
                    worldBookSelectionList.appendChild(li);
                });
                worldBookSelectionModal.classList.add('visible');
            });
        }

        function renderMemberSelectionList() {
            memberSelectionList.innerHTML = '';
            if (db.characters.length === 0) {
                memberSelectionList.innerHTML = '<li style="color:#aaa; text-align:center; padding: 10px 0;">선택할 수 있는 페르소나가 없습니다.</li>';
                return;
            }
            db.characters.forEach(char => {
                const li = document.createElement('li');
                li.className = 'member-selection-item';
                li.innerHTML = `<input type="checkbox" id="select-${char.id}" value="${char.id}"><img src="${char.avatar}" alt="${char.remarkName}"><label for="select-${char.id}">${char.remarkName}</label>`;
                memberSelectionList.appendChild(li);
            });
        }

        function loadGroupSettingsToSidebar() {
            const group = db.groups.find(g => g.id === currentChatId);
            if (!group) return;
            const themeSelect = document.getElementById('setting-group-theme-color');
            if (themeSelect.options.length === 0) {
                Object.keys(colorThemes).forEach(key => {
                    const option = document.createElement('option');
                    option.value = key;
                    option.textContent = colorThemes[key].name;
                    themeSelect.appendChild(option);
                });
            }
            document.getElementById('setting-group-avatar-preview').src = group.avatar;
            document.getElementById('setting-group-name').value = group.name;
            document.getElementById('setting-group-my-avatar-preview').src = group.me.avatar;
            document.getElementById('setting-group-my-nickname').value = group.me.nickname;
            document.getElementById('setting-group-my-persona').value = group.me.persona;
            themeSelect.value = group.theme || 'white_pink';
            document.getElementById('setting-group-max-memory').value = group.maxMemory;
            renderGroupMembersInSettings(group);
            const useGroupCustomCssCheckbox = document.getElementById('setting-group-use-custom-css'), groupCustomCssTextarea = document.getElementById('setting-group-custom-bubble-css'), groupPreviewBox = document.getElementById('group-bubble-css-preview');
            useGroupCustomCssCheckbox.checked = group.useCustomBubbleCss || false;
            groupCustomCssTextarea.value = group.customBubbleCss || '';
            groupCustomCssTextarea.disabled = !useGroupCustomCssCheckbox.checked;
            const theme = colorThemes[group.theme || 'white_pink'];
            updateBubbleCssPreview(groupPreviewBox, group.customBubbleCss, !group.useCustomBubbleCss, theme);
        }

        function renderGroupMembersInSettings(group) {
            groupMembersListContainer.innerHTML = '';
            group.members.forEach(member => {
                const memberDiv = document.createElement('div');
                memberDiv.className = 'group-member';
                memberDiv.dataset.id = member.id;
                memberDiv.innerHTML = `<img src="${member.avatar}" alt="${member.groupNickname}"><span>${member.groupNickname}</span>`;
                groupMembersListContainer.appendChild(memberDiv);
            });
            const addBtn = document.createElement('div');
            addBtn.className = 'add-member-btn';
            addBtn.innerHTML = `<div class="add-icon">+</div><span>추가</span>`;
            groupMembersListContainer.appendChild(addBtn);
        }

        function renderGroupRecipientSelectionList(actionText) {
            const group = db.groups.find(g => g.id === currentChatId);
            if (!group) return;
            groupRecipientSelectionTitle.textContent = actionText;
            groupRecipientSelectionList.innerHTML = '';
            group.members.forEach(member => {
                const li = document.createElement('li');
                li.className = 'group-recipient-select-item';
                li.innerHTML = `
                        <input type="checkbox" id="recipient-select-${member.id}" value="${member.id}">
                        <label for="recipient-select-${member.id}">
                            <img src="${member.avatar}" alt="${member.groupNickname}">
                            <span>${member.groupNickname}</span>
                        </label>`;
                groupRecipientSelectionList.appendChild(li);
            });
        }

        function saveGroupSettingsFromSidebar() {
            const group = db.groups.find(g => g.id === currentChatId);
            if (!group) return;
            const oldName = group.name;
            const newName = document.getElementById('setting-group-name').value;
            if (oldName !== newName) {
                group.name = newName;
                sendRenameNotification(group, newName);
            }
            group.avatar = document.getElementById('setting-group-avatar-preview').src;
            group.me.avatar = document.getElementById('setting-group-my-avatar-preview').src;
            group.me.nickname = document.getElementById('setting-group-my-nickname').value;
            group.me.persona = document.getElementById('setting-group-my-persona').value;
            group.theme = document.getElementById('setting-group-theme-color').value;
            group.maxMemory = document.getElementById('setting-group-max-memory').value;
            group.useCustomBubbleCss = document.getElementById('setting-group-use-custom-css').checked;
            group.customBubbleCss = document.getElementById('setting-group-custom-bubble-css').value;
            updateCustomBubbleStyle(currentChatId, group.customBubbleCss, group.useCustomBubbleCss);
            saveData();
            showToast('그룹 채팅 설정이 저장되었습니다!');
            chatRoomTitle.textContent = group.name;
            renderChatList();
            renderMessages(false, true);
        }

        function openGroupMemberEditModal(memberId) {
            const group = db.groups.find(g => g.id === currentChatId);
            const member = group.members.find(m => m.id === memberId);
            if (!member) return;
            document.getElementById('edit-group-member-title').textContent = `${member.groupNickname} 편집`;
            document.getElementById('editing-member-id').value = member.id;
            document.getElementById('edit-member-avatar-preview').src = member.avatar;
            document.getElementById('edit-member-group-nickname').value = member.groupNickname;
            document.getElementById('edit-member-real-name').value = member.realName;
            document.getElementById('edit-member-persona').value = member.persona;
            editGroupMemberModal.classList.add('visible');
        }

        function renderInviteSelectionList() {
            inviteMemberSelectionList.innerHTML = '';
            const group = db.groups.find(g => g.id === currentChatId);
            if (!group) return;
            const currentMemberCharIds = new Set(group.members.map(m => m.originalCharId));
            const availableChars = db.characters.filter(c => !currentMemberCharIds.has(c.id));
            if (availableChars.length === 0) {
                inviteMemberSelectionList.innerHTML = '<li style="color:#aaa; text-align:center; padding: 10px 0;">더 이상 초대할 수 있는 새 멤버가 없습니다.</li>';
                confirmInviteBtn.disabled = true;
                return;
            }
            confirmInviteBtn.disabled = false;
            availableChars.forEach(char => {
                const li = document.createElement('li');
                li.className = 'invite-member-select-item';
                li.innerHTML = `<input type="checkbox" id="invite-select-${char.id}" value="${char.id}"><label for="invite-select-${char.id}"><img src="${char.avatar}" alt="${char.remarkName}"><span>${char.remarkName}</span></label>`;
                inviteMemberSelectionList.appendChild(li);
            });
        }

        function sendInviteNotification(group, newMemberRealName) {
            const messageContent = `[${group.me.nickname}가 ${newMemberRealName}에게 그룹 채팅에 초대]`;
            const message = { id: `msg_${Date.now()}`, role: 'user', content: messageContent, parts: [{ type: 'text', text: messageContent }], timestamp: Date.now(), senderId: 'user_me' };
            group.history.push(message);
        }

        function sendRenameNotification(group, newName) {
            const myName = group.me.nickname;
            const messageContent = `[${myName}가 그룹 이름을 변경:${newName}]`;
            const message = { id: `msg_${Date.now()}`, role: 'user', content: messageContent, parts: [{ type: 'text', text: messageContent }], timestamp: Date.now() };
            group.history.push(message);
        }

        init();
    });
</script>

</body>

</html>
